{
	"_id": "14309208",
	"site": "https://github.com/adam-hanna/sessions",
	"title": " User sessions for go http servers",
	"author": "telefonica",
	"date": "2017-06-13T13:08:56.414Z",
	"tags": {
		"categories": [
			"opensource",
			"go"
		],
		"languages": [
			"go",
			"makefile"
		]
	},
	"content": "readme.md sessions dead simple, highly performant, highly customizable sessions service go http servers. default, service stores sessions redis, transports sessions clients cookies. however, are easily customizeable. instance, storage interface implements three methods:// serviceinterface defines behavior the session storetype serviceinterface interface {saveusersession(usersession *user.session) errordeleteusersession(sessionid string) errorfetchvalidusersession(sessionid string) (*user.session, error)}readme contents:quickstartperformancedesignapitest coverageexamplelicensequickstartvar sesh *sessions.service// issue new session write session the responsewriterusersession, err := sesh.issueusersession(\"fakeuserid\", \"{\\\"foo\\\":\\\"bar\\\"}\", w) err != nil {log.printf(\"err issuing user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}...// fetch pointer a valid user session a request. nil pointer indicates or invalid sessionusersession, err := sesh.getusersession(r) err != nil {log.printf(\"err fetching user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}// nil session pointers indicate 401 unauthorized usersession == nil {http.error(w, \"unathorized\", http.statusunauthorized)return}...// extend session expiry. note session expiry's need be manually extended err := sesh.extendusersession(usersession, r, w); err != nil {log.printf(\"err extending user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}...// invalidate user session, deleting from redis expiring cookie the responsewriter err := sesh.clearusersession(usersession, w); err != nil {log.printf(\"err clearing user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}performancebenchmarks require redis-server running. set redis_url environment variable, otherwise benchmarks for \":6379\".ymmv$ (cd benchmark && test -bench=.)setting benchmark testsbenchmarkbaseserver-2 20000 72479 ns/opbenchmarkvalidsession-2 10000 151650 ns/oppassshutting down benchmark testsok github.com/adam-hanna/sessions/benchmark 3.727sdesign default, service stores sessions redis, transports hashed sessionids clients cookies. however, are easily customizeable through creation custom structs implement interface. general flow the session service is follows:create store, auth transport services calling respective (...) functions ( create own custom services implement service's interface methods). pass services the sessions.(...) constructor. a user logs , call sessions.issueusersession(...) function. function creates new user.session. sessionids are rfc 4122 version 4 uuids. next, service hashes sessionid the provided key. hashing algorithm is sha-512, therefore key used should between 64 128 bytes. , the service stores session redis finally writes hashed sessionid the response writer a cookie. sessions written the redis db utilize expireat automatically destory expired sessions. check a valid session was included a request, the sessions.getusersession(...) function. function grabs hashed sessionid the session cookie, verifies hmac signature finally looks the session the redis db. the session is expired, fails hmac signature verification, function return nil pointer a user session. the session is valid, you'd to extend session's expiry, can call session.extendusersession(...). session expiry's are never automatically extended, through calling function the session's expiry extended. a user logs , call sessions.clearusersession(...) function. function destroys session the db also destroys cookie the responsewriter.apiuser.sessiontype session struct {id stringuserid stringexpiresat .timejson string}session is struct is used store session data. json field allows to set custom information 'd . see exampleissueusersessionfunc (s *service) issueusersession(userid string, json string, w http.responsewriter) (*user.session, error)issueusersession grants new user session, writes session info the store writes session the http.responsewriter. method should called a user logs , for example.clearusersessionfunc (s *service) clearusersession(usersession *user.session, w http.responsewriter) errorclearusersession is used remove user session the store clear cookies the responsewriter. method should called a user logs , for example.getusersessionfunc (s *service) getusersession(r *http.request) (*user.session, error)getusersession returns user session the hashed sessionid included the request. method returns valid sessions. therefore, sessions have expired that fail signature verification return nil pointer.extendusersessionfunc (s *service) extendusersession(usersession *user.session, r *http.request, w http.responsewriter) errorextendusersession extends expiresat a session the options.expirationdurationnote this function must called, manually! extension user session expiry's does happen automatically!testing coverageok github.com/adam-hanna/sessions9.012s coverage: 94.1% statementsok github.com/adam-hanna/sessions/auth0.003s coverage: 100.0% statementsok github.com/adam-hanna/sessions/store0.006s coverage: 85.4% statementsok github.com/adam-hanna/sessions/benchmark0.004s coverage: 0.0% statements [ tests run]ok github.com/adam-hanna/sessions/transport0.004s coverage: 95.2% statementsok github.com/adam-hanna/sessions/user0.003s coverage: 100.0% statementstests are broken down three categories: unit, integration e2e. integration e2e tests require connection a redis server. connection address be set the redis_url environment variable. default is \":6379\". run tests, simply:$ test -tags=\"unit integration e2e\" ./...// $ make test// $ make test-cover-html && tool cover -html=coverage-.out run tests one the categories:$ test -tags=\"integration\" ./... run unit integration tests:$ test -tags=\"unit integration\" ./...example following example is demonstration using session service along a csrf code check authentication. csrf code is stored the user.session json field.package mainimport (\"crypto/rand\"\"encoding/base64\"\"encoding/json\"\"io\"\"log\"\"net/http\"\"\"\"github.com/adam-hanna/sessions\"\"github.com/adam-hanna/sessions/auth\"\"github.com/adam-hanna/sessions/store\"\"github.com/adam-hanna/sessions/transport\")// sessionjson is used marshalling unmarshalling custom session json information.// 're using as opportunity tie csrf strings sessions prevent csrf attackstype sessionjson struct {csrf string `json:\"csrf\"`}var sesh *sessions.servicevar issuesession = http.handlerfunc(func(w http.responsewriter, r *http.request) {csrf, err := generatekey() err != nil {log.printf(\"err generating csrf: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}myjson := sessionjson{csrf: csrf,}jsonbytes, err := json.marshal(myjson) err != nil {log.printf(\"err marhsalling json: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}usersession, err := sesh.issueusersession(\"fakeuserid\", string(jsonbytes[:]), w) err != nil {log.printf(\"err issuing user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}log.printf(\" issue; user's session: %v\", usersession)// note: set csrf a cookie, look it request headerscsrfcookie := http.cookie{name: \"csrf\",value: csrf,expires: usersession.expiresat,path: \"/\",httponly: false,secure: false, // note: 't secure cookies development}http.setcookie(w, &csrfcookie)w.writeheader(http.statusok)})var requiressession = http.handlerfunc(func(w http.responsewriter, r *http.request) {usersession, err := sesh.getusersession(r) err != nil {log.printf(\"err fetching user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}// nil session pointers indicate 401 unauthorized usersession == nil {http.error(w, \"unathorized\", http.statusunauthorized)return}log.printf(\" require; user session expiration before extension: %v\", usersession.expiresat.utc())myjson := sessionjson{} err := json.unmarshal([]byte(usersession.json), &myjson); err != nil {log.printf(\"err unmarshalling json: %v\", err)http.error(w, err.error(), http.statusinternalservererror)return}log.printf(\" require; user's custom json: %v\", myjson)// note: set csrf a cookie, look it request headerscsrf := r.header.(\"x-csrf-token\") csrf != myjson.csrf {log.printf(\"unauthorized! csrf token doesn't match user session\")http.error(w, \"unauthorized\", http.statusunauthorized)return}// note session expiry's need be manually extended err = sesh.extendusersession(usersession, r, w); err != nil {log.printf(\"err extending user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}log.printf(\" require; users session expiration extension: %v\", usersession.expiresat.utc())// need extend csrf cookie, toocsrfcookie := http.cookie{name: \"csrf\",value: csrf,expires: usersession.expiresat,path: \"/\",httponly: false,secure: false, // note: 't secure cookies development}http.setcookie(w, &csrfcookie)w.writeheader(http.statusok)})var clearsession = http.handlerfunc(func(w http.responsewriter, r *http.request) {usersession, err := sesh.getusersession(r) err != nil {log.printf(\"err fetching user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}// nil session pointers indicate 401 unauthorized usersession == nil {http.error(w, \"unathorized\", http.statusunauthorized)return}log.printf(\" clear; session: %v\", usersession)myjson := sessionjson{} err := json.unmarshal([]byte(usersession.json), &myjson); err != nil {log.printf(\"err unmarshalling json: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}log.printf(\" require; user's custom json: %v\", myjson)// note: set csrf a cookie, look it request headerscsrf := r.header.(\"x-csrf-token\") csrf != myjson.csrf {log.printf(\"unauthorized! csrf token doesn't match user session\")http.error(w, \"unauthorized\", http.statusunauthorized)return} err = sesh.clearusersession(usersession, w); err != nil {log.printf(\"err clearing user session: %v\", err)http.error(w, \"internal server error\", http.statusinternalservererror)return}// need clear csrf cookie, tooalongtimeago := .now().add(-1000 * .hour)csrfcookie := http.cookie{name: \"csrf\",value: \"\",expires: alongtimeago,path: \"/\",httponly: false,secure: false, // note: 't secure cookies development}http.setcookie(w, &csrfcookie)w.writeheader(http.statusok)})func main() {seshstore := store.(store.options{})// e.g. `$ openssl rand -base64 64`seshauth, err := auth.(auth.options{key: []byte(\"dozdgbdmhglimnk0bgygoui+h1n7u+odxczpctmbefcsuaom2afu4jpv4qj11hbcb5yam4wdunp/3b7b+bnfhw==\"),}) err != nil {log.fatal(err)}seshtransport := transport.(transport.options{httponly: true,secure: false, // note: 't secure cookies development!})sesh = sessions.(seshstore, seshauth, seshtransport, sessions.options{})http.handlefunc(\"/issue\", issuesession)http.handlefunc(\"/require\", requiressession)http.handlefunc(\"/clear\", clearsession) // requires valid sessionlog.println(\"listening localhost:3000\")log.fatal(http.listenandserve(\"127.0.0.1:3000\", nil))}// thanks// https://astaxie.gitbooks.io/build-web-application--golang/en/06.2.html#unique-session-idsfunc generatekey() (string, error) {b := ([]byte, 16) _, err := io.readfull(rand.reader, b); err != nil {return \"\", err}return base64.urlencoding.encodetostring(b), nil}license mit license (mit)copyright (c) 2017 adam hannapermission is hereby granted, free charge, any person obtaining copy this software associated documentation files ( \"software\"), deal the software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /or sellcopies the software, to permit persons whom software isfurnished do , subject the following conditions: above copyright notice this permission notice shall included allcopies substantial portions the software. software is provided \" is\", without warranty any kind, express implied, including not limited the warranties merchantability,fitness a particular purpose noninfringement. no event shall authors copyright holders liable any claim, damages otherliability, whether an action contract, tort otherwise, arising ,out or connection the software the or dealings thesoftware."
}