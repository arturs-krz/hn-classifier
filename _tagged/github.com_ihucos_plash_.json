{
	"_id": "14341942",
	"site": "https://github.com/ihucos/plash/",
	"title": " Alternative to Dockerfile",
	"author": "nomoral",
	"date": "2017-06-13T13:08:16.222Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"python",
			"shell"
		]
	},
	"content": "readme.md plashplash is flexible build tool docker images. current version is 0.2 alpha.installapi configuration format unstablepip3 install git+https://github.com/ihucos/plash.gitcrash course plash can run nvim without installing to operating system.$ plash ubuntu :add-apt-repository ppa:neovim-ppa/stable :apt neovim -- nvim myfile home directory is mounted home the container.building is cached, you run command twice, building not happen again. can import command line arguments files$ plash @nvim$ cat nvim#!/usr/bin/env plashexecubuntunvim:add-apt-repository ppa:neovim-ppa/stable:apt neovimnote shebang, marking file named nvim executable can directly run you also put into path. main idea plash is have programms run you need inside container. plashs vision containers is similiar a chroot, the file system is virtualized other resources accesible. plash script should behave a \"native\" programm. (currently plash is top docker, want change to libcontainer/runc an overlay file system)here is another simple example a plash file::aptpackage1package2:layer # layering is explicit:run touch myfileplash scripts be seen one dimensional lisp, 'layer' instance is actually macro.:layer aptpackage1package2package3results the same :layer:apt package1:layer:apt package2:layer:apt package3:layeranother macro is action 'warp'::warp run cp -r {./data_dir_at_host} /app/databuildtime mounts are supported:mount .:pwd .:rebuild--changedmyfilemydir can buildtime arguments, with other actions rebuilding happens necessary.:import-env mydir path:host_path: run # applies each argument its argumentsmkdir $mydircd $mydiraltough can done, plash does try be general purpose language. can define actions are external scripts.:define touchtouch $1:touch myfile if don't bash::apt python:define mkdir#!/usr/bin/env pythonimport sys, osos.mkdir(sys.argv[1]):mkdir mydir this is actually for quick -shot functions. can implement actions importing python modules have callables registered the plash.eval.register decorator. stdlib.py examples.plash ubuntu ---stdlib :import myplashlib :funcyfunc two actions are build , import layer. rest comes the stdlib can easily extended replaced.using plash create docker imagesplash scripts be saved a docker image$ plash @myplashscript --save-image myimage --build-$ docker push dockeruser485/myimage$ plash myimage bash case example: virtualenv replacement of python's virtualenvs shortcoming is packages often not compiled another computer. plash can isolate dependencies inside container still very leightweight the development side.#!/usr/bin/env plashexecdebianpython:aptpythonpython-pippython-devbinutils:layer:warp run pip install -r {myapp/requirements.txt}:layer:import-env myapp_devrequirements:warp script[ \"$myapp_devrequirements\" = \"1\" ] && pip install -r \\{myapp/devrequirements.txt}true could inside executable file named python inside bin folder your project root checked version control. way will a python executes app inside container the required libraries. note this example you export myapp_devrequirements=1 order also comforts e.g. ipdb inside container.roadmap is alpha release. next step is get stable minimalistic stdlib is easy understand fits needs building images.'d actually to docker as backend can used actually rely runc/libcontainer. configuration management part plash should very leightweight, transparent decopuled. do want create next ansible turing complete scripting language. vision containers plash is they actually isolate file system, a chroot. resources should accesible inside container. should play with unix world, you need something docker-compose, supervisord. you need more isolation existing tools be used."
}