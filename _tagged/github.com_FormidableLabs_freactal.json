{
	"_id": "14248539",
	"site": "https://github.com/FormidableLabs/freactal",
	"title": " Freactal: Dead-simple, composable state management for React",
	"author": "divmain",
	"date": "2017-06-13T13:32:49.279Z",
	"tags": {
		"categories": [
			"opensource",
			"react",
			"state-management",
			"state",
			"preact",
			"inferno"
		],
		"languages": [
			"javascript",
			"css"
		]
	},
	"content": "readme.md fr(e)actalfreactal is composable state management library react. library grew the idea state should just flexible your react code; state containers build freactal are components, you compose however 'd . in way, attempts address often exponential relationship between application size complexity growing projects. flux react general, freactal builds the principle unidirectional flow data. however, does in way feels idiomatic es2015+ doesn't in way. building application, can replace redux, mobx, reselect, redux-loop, redux-thunk, redux-saga, [fill--the-blank sub-app composition technique], potentially recompose, depending how 're using .its design philosophy aligns closely the zen python:beautiful is better ugly.explicit is better implicit.simple is better complex.complex is better complicated.flat is better nested.sparse is better dense.readability counts.table contentsguidecontaining stateaccessing state a child componenttransforming statetransforming state (cont.)intermediate stateeffect argumentscomputed state valuescomposing multiple state containerstestingstateless functional componentsstate effectsconclusionapi documentationprovidestateinitialstateeffectsinitializecomputedmiddlewareinjectstatehydrate initializehelper functionshardupdatesoftupdate'mergeintostate'server-side rendering react#rendertostring rapscallionhydrate state the clientguide guide is intended get familiar the freactal of doing things. you're looking something specific, a at api documentation. you're starting with freactal, read !containing state state management solutions react put state one place. freactal doesn't suffer that constraint, it is good place start. let's what might like.import { providestate } \"freactal\";const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 })}); the above example, define new state container type using providestate, provide an argument. can about arguments passed providestate the schema your state container; 'll more familiar the possible arguments later the guide. initialstate function is invoked whenever component it is wrapping is instantiated. so far, state container is wrapping anything, let's expand example bit.import react, { component } \"react\";import { render } \"react-dom\";const parent = ({ state }) => ( <div> { ` counter is : ${state.counter}` } </div>);render(<parent />, document.getelementbyid(\"root\"));'s very basic react app. let's what looks to add very basic state that application.import react, { component } \"react\";import { render } \"react-dom\";import { providestate } \"freactal\";const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 })});const parent = wrapcomponentwithstate(({ state }) => ( <div> { ` counter is : ${state.counter}` } </div>));render(<parent />, document.getelementbyid(\"root\"));alright, 're getting close. we're missing important piece: injectstate. providestate, injectstate is component wrapper. links application component the state it has access .it may be readily apparent you why injectstate is necessary, let's it clear each freactal function is doing. providestate, define state template can be applied any component. once applied, component act a \"headquarters\" a piece state the effects transform (more that later). you had reason, same template be applied multiple components, they'd each their own state based the template defined. that tracks state. doesn't that state accessible the developer. 's injectstate is .in early versions freactal, state was directly accessible the component providestate wrapped. however, meant whenever state change occurred, entire tree need re-render. injectstate intelligently tracks pieces state you actually access, a re-render occurs those pieces state undergo change.alright, let's finalize example all pieces play.import react, { component } \"react\";import { render } \"react-dom\";import { providestate, injectstate } \"freactal\";const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 })});const parent = wrapcomponentwithstate(injectstate(({ state }) => ( <div> { ` counter is : ${state.counter}` } </div>)));render(<parent />, document.getelementbyid(\"root\"));'ll just fine!accessing state a child component was mentioned above, providestate-wrapped component isn't really one provides access state. 's injectstate's job. what stop from injecting state a child component isn't containing state itself? answer is nothing!let's modify example that 're injecting state a child component.import react, { component } \"react\";import { render } \"react-dom\";import { providestate, injectstate } \"freactal\";const child = injectstate(({ state }) => ( <div> { ` counter is : ${state.counter}` } </div>));const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 })});const parent = wrapcomponentwithstate(({ state }) => ( <child />));render(<parent />, document.getelementbyid(\"root\"));let's review 's going here.using providestate, define state-container template intended store single piece state: counter. template is applied the parent component. the parent is rendered, see it references child component. child component is wrapped injectstate. child is contained within subtree where parent is root node, has access the parent component's state. could insert another component the end, injectstate the grandchild component, it work same.transforming statealright, we how setup state containers, them initial state, consume state child components. all this is very useful state is never updated. 's where effects in.effects are one only to change freactal state your application. effects are defined part your state container template calling providestate, they be invoked anywhere state has been injected ( injectstate).let's a at first part.const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 }), effects: { addone: () => state => object.assign({}, state, { counter: state.counter + 1 }) }}); might wondering why have extra () => right before state => the addone definition. 'll explained the next section - now, let's at the pieces. the above example, 've defined effect , when invoked, update counter our state container adding 1.since updating element state based previous state ( potentially information) is something 'll doing often, freactal provides shorthand make a bit more readable:const wrapcomponentwithstate = providestate({ initialstate: () => ({ counter: 0 }), effects: { addone: softupdate(state => ({ counter: state.counter + 1 })) }}); let's at you might trigger effect:const child = injectstate(({ state, effects }) => ( <div> { ` counter is : ${state.counter}` } <button onclick={effects.addone}>add </button> </div>));wherever <child /> is your application, state effects references be accessible, long the state container is somewhere further in tree.transforming state (cont.) you've used redux, effects are roughly comparable an action-reducer pair, a couple important differences. first those differences relates asychronicity. under hood, freactal relies heavily promises schedule state updates. fact, following effects are functionally equivalent:addone: () => state => object.assign({}, state, { counter: state.counter + 1 })/* vs */addone: () => promise.resolve(state => object.assign({}, state, { counter: state.counter + 1 }))/* vs */addone: () => promise(resolve => resolve(state => object.assign({}, state, { counter: state.counter + 1 }))) put explicitly, value provide each key your effects object is: function takes some arguments ('ll cover those shortly) returns... promise resolves ...a function takes state returns... updated state.step 2 optionally omitted, since freactal wraps values promise.resolve. most developers, pattern is probably least familiar those freactal relies upon. it allows some powerful expressive state transitions basically boilerplate. example, number things occur between time an effect is invoked the that state is updated. \"things\" might include doing calculations, talking an api, integrating some js library., you might define following effect:updateposts: () => fetch(\"/api/posts\") .(result => result.json()) .(({ posts }) => state => object.assign({}, state, { posts })) other words, action your application might , that ultimately result a state change be simply expressed an effect. only , but pattern allows effects ui components be tested clean separation., perhaps importantly, pattern allows intermediate state.intermediate state far, haven't any arguments the , outer- function our effect definitions. simple scenarios, outer-function may seem unnecessary, in illustration above. what cases where want state be updated part- through operation? could put this logic your ui code, invoke effects there multiple times. that's ideal a number reasons: single effect might invoked multiple places your application. code influences state might transformed is living multiple places. is much harder test.fundamentally, problem is this pattern violates principle separation concerns., what's alternative?, we've already defined effect a function , when invoked, resolve another function transforms state. why couldn't re- this pattern represent \"part-\" (or intermediate) state? answer is: nothing is stopping !the argument passed an effect the outer function is same effects object is exposed components where state has been injected. these effects be invoked the same . even more importantly, effects always resolve a promise, can wait an intermediate state transition complete before continuing our original state transition. might a lot take , so let's at example:const wrapcomponentwithstate = providestate({ initialstate: () => ({ posts: null, postspending: false }), effects: { setpostspending: softupdate((state, postspending) => ({ postspending })), getposts: effects => effects.setpostspending(true) .(() => fetch(\"/api/posts\")) .(result => result.json()) .(({ posts }) => effects.setpostspending(false).(() => posts)) .(posts => state => object.assign({}, state, { posts })) }});'s lot going there, let's through piece piece. initial state is set two keys, posts postspending.posts eventually contain array blog posts something that.postspending is flag , when true, indicates we are currently fetching posts. effects are defined.setpostspending sets postspending flag either true false.getposts does number things: invokes setpostspending, setting pending flag true. waits the setpostspending effect complete before continuing. fetches data an api. parses data json. invokes setpostspending a value false, waits it complete. resolves a function updates posts state value. the above example, setpostspending has synchronous- behavior - immediately resolves a state update function. it just easily something asynchronous, make ajax call interact the indexeddb api. because of is promise composition, can put together helper functions give consistency intermediate state updates. here's example:const wrapwithpending = (pendingkey, cb) => effects => effects.setflag(pendingkey, true) .(cb) .(value => effects.setflag(pendingkey, false).(() => value)); could consumed so:const wrapcomponentwithstate = providestate({ initialstate: () => ({ posts: null, postspending: false }), effects: { setflag: softupdate((state, key, value) => ({ [key]: value })), getposts: wrapwithpending(\"postspending\", () => fetch(\"/api/posts\") .(result => result.json()) .(({ posts }) => state => object.assign({}, state, { posts })) ) }});effect arguments what you to update state some value you captured the user? redux parlance: about action payloads? you were looking closely, may noticed already did something that we invoked setpostspending.whether are invoking effect your ui code from another effect, can pass arguments directly the invocation. those arguments show after effects argument your effect definition.here's example:const wrapcomponentwithstate = providestate({ initialstate: () => ({ thing: \"val\" }), effects: { setthing: (effects, newval) => state => object.assign({}, state, { thing: newval }) }}); it invoked your component so:const child = injectstate(({ state, effects }) => { const onclick = () => effects.setthing(\" val\"); return ( <div> { ` \"thing\" value is: ${state.thing}` } <button onclick={onclick}>click here change thing!</button> </div> );});computed state values an application grows, becomes increasingly important have effective organizational tools. is especially true how store transform data.consider following state container:const wrapcomponentwithstate = providestate({ initialstate: () => ({ givenname: \"walter\", familyname: \"harriman\" }), effects: { setgivenname: softupdate((state, val) => ({ givenname: val })), setfamilyname: softupdate((state, val) => ({ familyname: val })) }});let's that 're implementing component we to display user's full name. might write component this:const welcomemessage = injectstate(({ state }) => { const fullname = `${state.givenname} ${state.familyname}`; return ( <div> {`hi, ${fullname}, welcome!`} </div> );}); seems a pretty reasonable piece code. , even a small piece data a full name, things get more complex the application grows. if 're displaying full name multiple components? should compute in those places, maybe inject state further the tree pass down a prop? can messy the point where 're passing down dozens props. if user is a non-english locale, where may place given names before family names? would to remember do everywhere. what we to derive another value off the generated fullname value? about multiple derived values, derived other derived values? if 're dealing names, more complex data structures instead?freactal's answer this is computed values.'ve probably run something this before. vue.js has computed properties. mobx has computed values. redux outsources concern libraries reselect. ultimately, all serve same function: exposing compound values the ui based simple state values.here's you define computed values freactal, throwing some the added complexities mentioned:const wrapcomponentwithstate = providestate({ initialstate: () => ({ givenname: \"walter\", familyname: \"harriman\", locale: \"en-\" }), effects: { setgivenname: softupdate((state, val) => ({ givenname: val })), setfamilyname: softupdate((state, val) => ({ familyname: val })) }, computed: { fullname: ({ givenname, familyname, locale }) => startswith(locale, \"en\") ? `${givenname} ${familyname}` : `${familyname} ${givenname}`, greeting: ({ fullname, locale }) => startswith(locale, \"en\") ? `hi, ${fullname}, welcome!` : `helló ${fullname}, és szívesen!` }});note: is a replacement a proper internationalization solution react-intl, is illustration purposes .here see computed values, fullname greeting. both rely the locale state value, greeting actually relies upon fullname, whereas fullname relies the given family names. might be consumed?const welcomemessage = injectstate(({ state }) => ( <div> {state.greeting} </div>)); another component, might to use fullname value:const elsewhere = injectstate(({ state }) => ( <div> {`are sure want do , ${state.fullname}?`} </div>));hopefully can that can a powerful tool help keep code organized readable.here are handful other things will nice you know.computed values are generated lazily. means if greeting value above is never accessed, will never computed.computed values are cached. once computed value is calculated once, second state retrieval return cached value.cached values are invalidated dependencies change. you were trigger setgivenname effect a name, fullname greeting values be recomputed soon react re-rendered ui.'s you need know use computed values effectively!composing multiple state containers started guide noting , while react state libraries contain state a single place, freactal approaches things differently.before dive how works, let's briefly consider of issues arise the centralized approach state management:oftentimes, is hard know to organize state-related code. definitions events actions live separately the ui triggers , which lives separately functions reduce those events state, also live separately code transforms state more complex values.while react components are re-usable ( component libraries), complex stateful components are hard nut crack. 's fuzzy line addressing complexity your own code , when crossed, means should using state library vs react's own setstate. how you that dry across applications team boundaries?sometimes might to compose full spas together various ways, if need interact the page share state some , how you about accomplishing ? the results here are almost universally ad-hoc. is often arduous process it comes to refactor application move state-dependant components different parts your application. wiring everything can tedious hell. are constraints freactal aims address. let's a at minimal example:const child = injectstate(({ state }) => ( <div> is child. {state.fromparent} {state.fromgrandparent} </div>));const parent = providestate({ initialstate: () => ({ fromparent: \"parentvalue\" })})(() => ( <div> is parent. <child /> </div>));const grandparent = providestate({ initialstate: () => ({ fromgrandparent: \"grandparentvalue\" })})(() => ( <div> is grandparent. <parent /> </div>)); important notice here child was able access state values both parent its grandparent. state keys be accessible the child, unless is key conflict between parent grandparent ( which case parent \"wins\"). pattern allows to co-locate code feature, rather by function. other words, you're rolling a feature your application, of new code - ui, state, effects, etc - go one place, rather scattered across code-base. of , refactoring becomes easier. to move component a different part your application? move directory update import the parents. if component accesses parent state? that parent is still anscestor, don't to change thing. it's , moving state a more appropriate place should part the refactor anyway. one word warning: accessing parent state be powerful, very useful, it necessarily couples child state the parent state. while coupling is \"loose\" coupling, still may introduce complexity should carefully thought-.one more thing.child effects also trigger parent effects. let's your ux team has indicated , whenever api call is flight, global spinner should shown. maybe data is needed certain parts the application. this scenario, could define beginapicall completeapicall effects track many api calls are active. above 0, show spinner. effects be accessed call-specific effects further down the state hierarchy, so:const child = injectstate(({ state, effects }) => ( <div> is child. {state.fromparent} {state.fromgrandparent} <button onclick={() => effects.changebothstates(\"newvalue\")} > click ! </button> </div>));const parent = providestate({ initialstate: () => ({ fromparent: \"parentvalue\" }), effects: { changeparentstate: (effects, fromparent) => state => object.assign({}, state, { fromparent }), changebothstates: (effects, value) => effects.changegrandparentstate(value).(state => object.assign({}, state, { fromparent: value }) ) }})(() => ( <div> is parent. <child /> </div>));const grandparent = providestate({ initialstate: () => ({ fromgrandparent: \"grandparentvalue\" }), effects: { changegrandparentstate: (effects, fromgrandparent) => state => object.assign({}, state, { fromgrandparent }) }})(() => ( <div> is grandparent. <parent /> </div>));testingbefore wrapping , let's a at additional benefit freactal brings the table: ease test-writing. you hadn't noticed already, of examples 've looked in guide relied upon stateless functional components. is coincidence - the beginning, primary goal freactal was encapsulate state freactal state containers. means shouldn't need use react's setstate all.here's bottom line: all state be contained within freactal state containers, rest your application components be \"dumb components\". approach allows to test state your components completely independent one another.let's a at simplified example above, then dive how might test application. the purposes this example, assume 're using mocha, chai, sinon, sinon-chai, enzyme., our application code:/*** app.js ***/import { wrapcomponentwithstate } \"./state\";export const app = ({ state, effects }) => { const { givenname, familyname, fullname, greeting } = state; const { setgivenname, setfamilyname } = effects; const onchangegiven = ev => setgivenname(ev.target.value); const onchangefamily = ev => setfamilyname(ev.target.value); return ( <div> <div id=\"greeting\"> { greeting } </div> <div> <label =\"given\">enter given name</label> <input id=\"given\" onchange={onchangegiven} value={givenname}/> <label =\"family\">enter family name</label> <input id=\"family\" onchange={onchangefamily} value={familyname}/> </div> </div> );};/* notice we're exporting both unwrapped the state-wrapped component... */export default wrapcomponentwithstate(app); then state template:/*** state.js ***/import { providestate, softupdate } \"freactal\";export const wrapcomponentwithstate = providestate({ initialstate: () => ({ givenname: \"walter\", familyname: \"harriman\" }), effects: { setgivenname: softupdate((state, val) => ({ givenname: val })), setfamilyname: softupdate((state, val) => ({ familyname: val })) }, computed: { fullname: ({ givenname, familyname }) => `${givenname} ${familyname}`, greeting: ({ fullname }) => `hi, ${fullname}, welcome!` }});next, let's add few tests!stateless functional componentsremember, goal here is test state ui isolation. read through following example see you might assertions 1) data-driven ui content, 2) ways which ui might trigger effect./*** app.spec.js ***/import { mount } \"enzyme\";// sure import _unwrapped_ component here!import { app } \"./app\";// 'll re-using values, let's put here convenience.const state = { givenname: \"charlie\", familyname: \"-the-box\", fullname: \"charlie -the-box\", greeting: \"howdy , kid!\"};describe(\" app\", () => { (\"displays greeting the user\", () => { // test should easy - we to is ensure // the string is passed is displayed correctly! // 're doing anything effects here, let's bother // setting for ... const effects = {}; // , we mount component, providing expected state effects. const el = mount(<app state={state} effects={effects}/>); // then can assertions the output. expect(el.find(\"#greeting\").text())..equal(\"howdy , kid!\"); }); (\"accepts changes the given name\", () => { // next 're testing conditions under our component might // interact the provided effects. const effects = { setgivenname: sinon.spy(), setfamilyname: sinon.spy() }; const el = mount(<app state={state} effects={effects}/>); // using `sinon-chai`, can readable assertions whether // spy function has been called. don't expect effect // be invoked the component mounts, let's that assertion // here. expect(effects.setgivenname)..to..been.called; // next, can simulate input-box value change. el.find(\"input.given\").simulate(\"change\", { target: { value: \"eric\" } }); // finally, can assert the effect - , rather, sinon // spy is standing for effect - was invoked the expected // value. expect(effects.setgivenname)..have.been.calledwith(\"eric\"); });}); takes care your sfcs. should really no different how might been testing presentational components the past, except with freactal, is only sort testing need do your react components.state effectsnext is state. you read through example below, note we make assertions the initial state any expected transformations that state without involving react component rendering the dom./*** state.spec.js ***/import { wrapcomponentwithstate } \"./state\";describe(\"state container\", () => { (\"supports fullname\", () => { // normally, 'd pass component the argument your // state template. however, you pass argument the state // template, 'll back test instance you extract // `state` `effects` . just don't try render thing! const { effects, getstate } = wrapcomponentwithstate(); expect(getstate().fullname)..equal(\"walter harriman\"); // since effects return promise, 're going make easy // ourselves wrap of assertions this point // inside promise. return promise.resolve() // a promise is provided the return value a promise's // `.` callback, outer promise awaits inner before // subsequent callbacks are fired. .(() => effects.setgivenname(\"alfred\")) // that `givenname` has been set \"alfred\", can an // assertion... .(() => expect(getstate().fullname)..equal(\"alfred harriman\")) // we do same the family name... .(() => effects.setfamilyname(\"hitchcock\")) // make final assertion. .(() => expect(getstate().fullname)..equal(\"alfred hitchcock\")); }); // could write similar assertions here (\"supports greeting\");});'s for testing!conclusion hope you found guide be helpful! you find a piece is missing would've helped understand freactal, please feel free open issue. help working through problem, reach on twitter, open issue, ping on gitter. can read through api docs below!api documentationprovidestate is used define state container, in turn wrap of application components.const statefulcomponent = providestate({/* options */})(statelesscomponent); options argument is object one more the following keys: initialstate, effects, initialize, computed.initialstate function defining state your state container it is initialized. function is invoked both the server during server-side render on client. however, might employ environment detection order yield divergent results.providestate({ initialstate: () => ({ : \"value \", b: \"set here\" })})effectseffects are mechanism which state is updated. effects value should an object, where keys are function names ( you later) the values are functions.each effect be provided or more arguments: effects reference ( note below), any arguments are passed the function they're invoked application code. return value is either 1) function takes old state returns state , 2) promise resolves #1. may seem opaque, please refer the guide information how use effectively.providestate({ effects: { dothing: (effects, arga) => promise.resolve(state => object.assign({}, state, { val: arga })) }});note: ithe effects object is passed each effect is the same the outer effects object you define here. instead, object is composition the hierarchy stateful effects.initializeeach state container define special effect called initialize. effect be implicitly invoked two circumstances:during ssr, each state container an initialize effect invoke , and rendering process await resolution that effect before continuing rendering. running the browser, each state container an initialize effect invoke when container is mounted the dom.computed computed object allows to define compound state values depend basic state values other computed values. value provided the computed option should an object where each key is name which computed value be referenced, each value is function taking state returning computed value.providestate({ initialstate: () => ({ : \"value \", b: \"set here\" }), computed: { aplusb: ({ , b }) => `${} + ${b}`, // \"value + set here\" typeofaplusb: ({ aplusb }) => typeof aplusb // \"string\" }})middlewaremiddleware is defined per state container, globally. each middleware function be invoked the order provided whenever state change has occurred. middleware, should able inject state values, intercept effects before begin, track effects complete, modify way which sub-components interact respond state containers further the tree. write middleware effectively, 'll probably to a at freactal's internal buildcontext method. fortunately is pretty straightforward. following is example will log whenever effect is invoked, arguments was provided, when effect completed:providestate({ middleware: [ freactalcxt => object.assign({}, freactalcxt, { effects: object.keys(freactalcxt.effects).reduce((memo, key) => { memo[key] = (...args) => { console.log(\"effect started\", key, args); return freactalcxt.effects[key](...args).(result => { console.log(\"effect completed\", key); return result; }) }; return memo; }, {}) }) ]})injectstatewhile providestate supplies means which declare state its possible transitions, injectstate is means which access state effects your ui code. default, injectstate detect keys you access your component, will force re-render those keys change the upstream state container.const statelesscomponent = ({ state: { myvalue } }) => <div>{ myvalue }</div>const withstate = injectstate(statelesscomponent); the above example, statelesscomponent only re-rendered second if myvalue changed the upstream state container.however, is possible explicitly define keys want \"listen\" . when using form, keys you specify are injected the wrapped component props.const statelesscomponent = ({ myvalue }) => <div>{ myvalue }</div>const statefulcomponent = injectstate(statelesscomponent, [\"myvalue\", \"othervaluetoo\"]); this example, statelesscomponent re-render myvalue changed, it also re-render othervaluetoo changed, though value is used the component.hydrate initialize functions are used deeply initialize state the ssr context then re-hydrate state the client. more information how use functions, the below documentation server-side rendering.helper functions may find following functions handy, a shorthand common tasks.hardupdate handy helper provides better ergonomics defining effect updates state, regardless the previous state. can consumed so:import { providestate, hardupdate } \"freactal\";const wrapcomponentwithstate = providestate({ // ... effects: { myeffect: hardupdate({ setthiskey: \" this value...\" }) }}); is equivalent the following:import { providestate } \"freactal\";const wrapcomponentwithstate = providestate({ // ... effects: { myeffect: () => state => object.assign({}, state, { setthiskey: \" this value...\" }) }});softupdatesoftupdate is provides shorthand updating element state is dependant the previous state. can consumed so:import { providestate, softupdate } \"freactal\";const wrapcomponentwithstate = providestate({ // ... effects: { myeffect: softupdate(state => ({ counter: state.counter + 1 })) }}); is equivalent the following:import { providestate, softupdate } \"freactal\";const wrapcomponentwithstate = providestate({ // ... effects: { myeffect: () => state => object.assign({}, state, { counter: state.counter + 1 }) }}); arguments are passed the invocation your effect also passed the function provide softupdate..e.effects: { updatecounterby: (effects, addval) => state => object.assign({}, state, { counter: state.counter + addval })}is equivalent :effects: { myeffect: softupdate((state, addval) => ({ counter: state.counter + addval }))}mergeintostateboth hardupdate softupdate are intended synchronous updates . but writing a state-update function asynchronous effects get tedious. 's where mergeintostate comes .mergeintostate(newdata)... is exactly equivalent ...state => object.assign({}, state, newdata)here's it might like practice:export const getdata = (effects, dataid) => fetch(`http://.url/${dataid}`) .(response => response.json()) .(body => mergeintostate({ data: body.data }));server-side renderinghistorically, server-side rendering stateful react applications has involved many moving pieces. freactal aims simplify area without sacrificing power its fractal architecture. are parts achieving ssr freactal: state initialization the server, state hydration the client.keep mind , if have state container whose state needs be initialized a particular , you should a at initialize effect.freactal supports both react's built- rendertostring method, well the newer rapscallion. react#rendertostring the server, 'll need recursively initialize state tree. is accomplished the initialize function, provided freactal/server./* , import rendertostring the initialize function. */import { rendertostring } \"react-dom/server\";import { initialize } \"freactal/server\";/* within context your node.js server route, pass root component the initialize function. */initialize(<statefulrootcomponent rootprop=\"hello\" />) /* invocation return promise resolves vdom state */ .(({ vdom, state }) => { /* pass vdom rendertostring get html . */ const apphtml = rendertostring(vdom); /* pass application html the application state ( object) a function inserts application html <html> <body> tags, serializes state, inserts state an accessible part the dom. */ const html = boilerplate(apphtml, state); /* finally, send full-page html the client */ return res.send(html).end(); }) can find full freactal example, including server ssr here. rapscallion above method involves partial render your application (initialize), ultimately relying upon react.rendertostring transform vdom an html string. is rendertostring is synchronous, freactal is asynchronous design. rapscallion is asynchronous design, is less ceremony involved./* , import rapscallion's render the capturestate function. */import { render } \"rapscallion\";import { capturestate } \"freactal/server\";/* within context your node.js server route, invoke `capturestate` your root component. */const { captured, state } = capturestate(<statefulrootcomponent rootprop=\"hello\" />);/* pass <captured /> component rapscallion's renderer */render(<captured />) .topromise() .(apphtml => { /* this point, `state` object be fully populated your state tree's data. pass application html state a function inserts application html <html> <body> tags, serializes state, inserts state an accessible part the dom. */ const html = boilerplate(apphtml, state); /* finally, send full-page html the client */ return res.send(html).end(); });hydrate state the clientusing of above methods, can capture application state while server-side rendering insert into resulting html. final piece the ssr puzzle is re-hydrating state containers inside browser. is accomplished hydrate the context your initialstate function.assuming 've serialized ssr state exposed as window.__state__, root state container should something this:import { providestate, hydrate } \"freactal\";const is_browser = typeof window === \"object\";const statetemplate = providestate({ initialstate: () => is_browser ? hydrate(window.__state__) : { /* typical state values */ }, effects: { /* ... */ }, computed: { /* ... */ }}); ssr, typical state values be provided your initial state. the browser, initial state be read window.__state__.assuming 've done with root state container, can similarly re-hydrate nested state containers so:import { providestate, hydrate } \"freactal\";const is_browser = typeof window === \"object\";const statetemplate = providestate({ initialstate: () => is_browser ? hydrate() : { /* typical state values */ }, effects: { /* ... */ }, computed: { /* ... */ }});note there is need pass window.__state__ the hydrate function nested state containers."
}