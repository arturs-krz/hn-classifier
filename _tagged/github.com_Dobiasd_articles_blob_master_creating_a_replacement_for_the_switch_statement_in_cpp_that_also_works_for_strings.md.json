{
	"_id": "14439273",
	"site": "https://github.com/Dobiasd/articles/blob/master/creating_a_replacement_for_the_switch_statement_in_cpp_that_also_works_for_strings.md",
	"title": "Creating a replacement for the switch statement in C++ also working for strings",
	"author": "Dobiasd",
	"date": "2017-06-13T13:55:33.743Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": []
	},
	"content": "creating replacement the switch statement c++ also works strings switch statement c++ works ints, enums a values convertible one them. probably not change the c++ standard soon, since low-level optimizations these statements depend it. the following chatbot, likely passes every turing test, sadly does compile.#include <iostream>#include <string>void (const std::string& text){ std::cout << text << std::endl;}void quit(const std::string& msg, bool* running_flag){ (running_flag) *running_flag = false; (msg);}int main(){ bool running = true; while (running) { std::string input; std::cin >> input; switch(input) { case \"hi\": (\"hey\"); break; case \"whazzup\": (\"wazzuuuup\"); break; case \"bye\": quit(\" ya\", &running); break; default: (\"wat?\"); break; } }}sure, could hash string an integral, we probably not run collisions that approach, it restricts case values compile constants, would render impossible for example them an external configuration. long - else chains are always nice read. let's - out curiosity, as exercise - create replacement switch, at least is suitable our particular case. perhaps learn something interesting our .ok, does switch actually ? it takes mapping possible values statements, default statement of course value match. since functions are -class citizens c++, should able write switch2 without ugly macros. possible implementation look follows:template<typename key_t>void switch2(const key_t& key, const std::unordered_map<key_t, std::function<void()>>& dict, const std::function<void()>& def){ const auto = dict.find(key); (it != dict.end()) ->second(); else def();} takes following three parameterskey is simply value want switch , input our example above.dict is mapping possible values functions should executed. such function of course include multiple statements execute arbitrary number side effects.def is function should executed key is present dict.switch2 simply looks key dict acts accordingly.naively could try use like : switch2(input, { {\"hi\", (\"hey\")}, {\"whazzup\", (\"wazzuuuup\")}, {\"bye\", quit(\" ya\", &running)}}, (\"wat?\")); even it compile ( it does ), it immediately run three calls say the call quit before switching happens. could done using lambdas: switch2(input, { {\"hi\", [](){ (\"hey\"); }}, {\"whazzup\", [](){ (\"wazzuuuup\"); }}, {\"bye\", [&](){ quit(\" ya\", &running); }}}, [](){ (\"wat?\"); }); that adds quite syntactical noise. let's try find way defer function call some way. is surprisingly easy c++. just need function takes another function f a list arguments returns nullary function, runs f the given arguments called. since are doing mental gymnastics exercise here anyway, can write on own instead using std::bind.template<typename f, typename... args>std::function<void()> defer(f f, args ... args){ return [f, args...]() { f(args...); };} we are the lucky situation be able do following: switch2(input, { {\"hi\", defer(, \"hey\")}, {\"whazzup\", defer(, \"wazzuuuup\")}, {\"bye\", defer(quit, \" ya\", &running)}}, defer(, \"wat?\")); reads that bad. need write defer we not need break statements more, can accidentally forgotten easily usual switch blocks. the important thing is can talk our awesome ai hours.is an advantage an - else chain the following ask? (input == \"hi\") (\"hey\"); else (input == \"whazzup\") (\"wazzuuuup\"); else (input == \"bye\") quit(\" ya\", &running); else (\"wat?\"); that is very question. to there was none, one fruit is hanging quite low. longer chains can happen one case is covered more once, produces strongly unwanted run- behavior. our switch2 can prevent from happening - at compile but least run .template<typename key_t>void switch2(const key_t& key, const std::vector<std::pair<key_t, std::function<void()>>>& pairs, const std::function<void()>& def){ std::unordered_map<key_t, std::function<void()>> dict; (const auto& entry : pairs) dict.insert(entry); assert(dict.size() == pairs.size()); const auto = dict.find(key); (it != dict.end()) ->second(); else def();} switch2 takes vector key-function pairs. the resulting dictionary does have same number entries the vector, least key was present more once our debugger tell immediately the call switch this invalid set keys.remember some run- overhead (hashing, lookup, perfect forwarding defer) is involved using switch2, that possibly show in profiler used a -critical section your code. you are interested learning more functional programming using c++ might enjoy video course udemy. promise contains code more useful everyday usage this article. ;) do think our little switch replacement? would happy read comments the reddit discussion.full code:#include <cassert>#include <functional>#include <iostream>#include <set>#include <string>#include <unordered_map>#include <vector>template<typename key_t>void switch2(const key_t& key, const std::vector<std::pair<key_t, std::function<void()>>>& pairs, const std::function<void()>& def){ std::unordered_map<key_t, std::function<void()>> dict; (const auto& entry : pairs) dict.insert(entry); assert(dict.size() == pairs.size()); const auto = dict.find(key); (it != dict.end()) ->second(); else def();}template<typename f, typename... args>std::function<void()> defer(f f, args ... args){ return [f, args...]() { f(args...); };}void (const std::string& text){ std::cout << text << std::endl;}void quit(const std::string& msg, bool* running_flag){ (running_flag) *running_flag = false; (msg);}int main(){ bool running = true; while (running) { std::string input; std::cin >> input; switch2(input, { {\"hi\", defer(, \"hey\")}, {\"whazzup\", defer(, \"wazzuuuup\")}, {\"bye\", defer(quit, \" ya\", &running)}}, defer(, \"wat?\")); }}"
}