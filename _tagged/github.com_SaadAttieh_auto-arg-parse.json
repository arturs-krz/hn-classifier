{
	"_id": "14453007",
	"site": "https://github.com/SaadAttieh/auto-arg-parse",
	"title": "C++ argument parser, combine the speed of C++ with the compactness of Python",
	"author": "SaadAttieh",
	"date": "2017-06-13T13:55:21.231Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c++",
			"cmake",
			"makefile"
		]
	},
	"content": "readme.md auto arg parsefast easy c++ argument parserautomatic validation program arguments,automatic generation usage instructions,type safe conversion string input desired type.featuresvalidation mandatory optional arguments,validation mandatory optional flags,arbitrary nesting, flags may themselves mandatory optional flags arguments,type safe, (built and user defined) conversions string input required type,add constraints arguments, a set flags exclusive,automatically trigger code successful parsing a flag argument,coming soonvariable number arguments,more built conversions ( number formats, file path->stream conversion, etc.)example usagesetting :code:#include <iostream>#include \"autoargparse/argparser.h\"using namespace std;using namespace autoargparse;argparser argparser;//declare flags args hereint main(const int argc, const char** argv) {// here // argparser.validateargs(argc, argv);}output: all flags args are validated, proceed normal, otherwise, error is printed the usage information ( below).mandatory flagcode:// let's add mandatory flag speedauto& speedflag = argparser.add<flag>(\"--speed\", policy::mandatory, \"specify speed limit.\");output:$./testprog error: missing mandatory argument(s). valid option(s) are: --speedsuccessfully parsed: ./testprog...optional flagcode:// let's add optional flag -p powerauto& powerflag = argparser.add<flag>(\"-p\", policy::optional, \" power.\");output:$./testprog -error: unexpected argument: -valid option(s): [-p]...$./testprog okay, -p is optional$./testprog -pokay, -p is optional has been usedtrigger code flag is detected:code:// let's add optional flag -p power// attach trigger prints message -p is detectedauto& powerflag = argparser.add<complexflag>( \"-p\", policy::optional, \"specify power output.\", [](const std::string&) { std::cout << \"triggered power flag\"; });output:$./testprog <no_output>$./testprog -ptriggered power flagnesting, flags may themselves flags arguments -p mandatory integer argument, type safe conversion string int automatically used.code:// let's add optional flag -p power.// time, -p is type complexflag.//allows nestingauto& powerflag = argparser.add<complexflag>(\"-p\", policy::optional, \"specify power output.\");// -p mandatory argument, integer. type safe conversion be usedauto& powerarg = powerflag.add<arg<int>>(\"number_watts\", policy::mandatory, \" integer representing number watts.\");output:$./testprog -p error: missing mandatory argument(s). valid option(s) are: number_wattssuccessfully parsed: ./testprog -p...$./testprog -p fudgeerror: not parse argument: number_watts not interpret \"fudge\" an integer....add constraint argument:power must in range 0-50 inclusive.code: modified above// let's add optional flag -p powerauto& powerflag = argparser.add<complexflag>(\"-p\", policy::optional, \"specify power output.\");// -p mandatory argument, integer. typesafe conversion be usedauto& powerarg = powerflag.add<arg<int>>( \"number_watts\", policy::mandatory, \" integer representing number watts the range 0..50.\", chain(converter<int>(), intrange(0, 50, true, true)));output:$./testprog -p 55 error: not parse argument: number_wattsexpected value be between 0(inclusive) 50(inclusive)....exclusive flags:code:auto& speedflag = argparser.add<complexflag>(\"--speed\", policy::mandatory, \"specify speed.\");auto& exclusivespeed = speedflag.makeexclusivegroup(policy::mandatory);// add three exclusive flags, fast, medium slow// need provide descriptions, are self explanatoryauto& slow = exclusivespeed.add<flag>(\"slow\", \"\");auto& medium = exclusivespeed.add<flag>(\"medium\", \"\");auto& fast = exclusivespeed.add<flag>(\"fast\", \"\");output:$ ./testprog --speed error: missing mandatory argument(s). valid option(s) are: slow, medium, fastsuccessfully parsed: ./testprog --speed...$ ./testprog --speed fast slowerror: following arguments are exclusive may be used conjunction: fast|medium|slowsuccessfully parsed: ./testprog --speed...add user defined constraint argumentcode:auto& fileflag = argparser.add<complexflag>(\"--file\", policy::optional, \"read specified file.\");//passing lambda function validates argument.auto& file = fileflag.add<arg<std::fstream>>( \"file_path\", policy::mandatory, \"path an existing file.\", [](const std::string& arg, std::fstream& stream) { stream.open(arg); (!stream.()) { throw errormessage(\"file \" + arg + \" does exist.\"); } });output:$ ./testprog --file fudge_file error: not parse argument: file_pathfile fudge_file does exist.successfully parsed: ./testprog --file...usage information:code: an error is reported, usage information is printed . otherwise, information be manually printed:int main(const int argc, const char** argv) { argparser.printallusageinfo(cout, argv[0]);}output:taken code src/exampleusage.cppusage: ./testprog [-p number_watts] --speed slow|medium|fast arguments: -p number_watts [optional] specify power output. number_watts: integer representing number watts. --speed slow|medium|fast specify speed. testing flag status validation:recommended, code triggers where possible, will automatically run a flag all sub flags are successfully parsed. need list long chains if/else blocks.attach code triggers arg objects chaining user defined constraints. constraints act code triggers they run arbitrary code ( chaining user defined constraints below).alternatively, flags arguments are implicitly convertible bool (true=parsed, false otherwise). example, can test an optional flag \"-p\" has been provided querying flag object (powerflag).retrieve value given an argument calling member function arg.().retrieve value used an exclusive group calling exclusivegroup.parsedvalue().code:int main(const int argc, const char** argv) { argparser.validateargs(argc, argv); // above print error exit not arguments were // successfully parsed // otherwise, testing flags is easy (powerflag) { int power = powerarg.(); // already converted integer cout << \"accepted power output \" << power << \" w\" << endl; } //either the string flag itself using: //exclusivespeed.parsedvalue() // test each flag object individually (slow) { cout << \"running slowly.\" << endl; } else (medium) { cout << \"running normally.\" << endl; } else (fast) { cout << \"running fast.\" << endl; } // allowed do }implementation faq:speed: aim has been make validation correct input fast. sometimes, leads slower error reporting. however, since finding error usually leads the program exiting, preference is given speeding the validating valid input. is however still very doubtful any speed differences ever noticed.memory management: long the argparser object is scope, flags arguments shall remain constructed. should never need copy copy-initialise flag argument object. maintain references where possible. e.g. auto& arg = ... auto arg = ... need maintain reference a flag, complexflag arg object unless wish query status. e.g.test an optional flag has been used,retrieve value given an argument. is therefore legal sometimes recommended.auto& somearg = argparser.add<complexflag>(\"--flag\", policy::optional, \"\").add<arg<int>>(\"somearg\", policy::mandatory, \"\");since somearg is mandatory argument --flag, can test a value somearg exists testing, (somearg). need test flag itself, though is course to .constructors copy constructors: argument types must default constructible. need be copyable. you are getting error due a missing copy constructor, check you are copy-initialising arguments (auto& arg = ... auto arg = ...). you are still getting error, please report as bug.built- and user defined converters: far, parsing args type arg<int> arg<std::string> require further , they trigger built- converters.however, you wish parse argument an unsupported type, have options: simplest option is provide fourth argument the add<arg>() method, object (e.g. lambda) implements:void operator()(const std::sotring& stringargtoparse, newtype& parsedvalue); this function:newtype& parsedvalue has been default constructed represents parsed value.const std::string& stringtoparse is string argument given the command line. signal error calling throw errormessage(\"error here\").here is example parsing string file path an fstream object, reporting error the file does exist:auto& file = argparser.add<arg<std::fstream>>( \"file_path\", policy::mandatory, \"path an existing file.\", [](const std::string& arg, std::fstream& stream) { stream.open(arg); (!stream.()) { throw errormessage(\"file \" + arg + \" does exist.\"); } });alternatively, may provide default converter all instances arg<newtype> specialising converter object within autoargparse namespace.namespace autoargparse {template <> struct converter<newtype> { inline void operator()(const std::string& stringtoparse, newtype& parsedvalue) { ... }}}built- and user defined constraints:user defined constraints are specified exactly the same method converters ( above). allows constraints be tested before after parsing string the argument type, ever is more efficient/convenient. satisfied constraint need perform additional actions they may report error via same method converters throw errormessage(\"error message here\");. far, intrange constraint has been provided a built- (see end section chaining), more are coming soon.chaining multiple converters constraints together: may wish apply multiple constraints an argument, perhaps apply conversion followed a constraint. can this calling auto'argparse::chain(...) function. below is example where use built conversion int followed a lambda function verify the int is within correct range.auto& intarg = argparser.add<arg<int>>( \"some_int\", policy::mandatory, \"description\", chain(converter<int>(), [](const std::string& arg, int& value) { (value < 0 || value > 50) { throw errormessage(\"integer is of range.\"); } })); convenience intrange constraint has already been added:auto& intarg = argparser.add<arg<int>>( \"some_int\", policy::mandatory, \"description\", chain(converter<int>(), intrange(0,50,true,true)));"
}