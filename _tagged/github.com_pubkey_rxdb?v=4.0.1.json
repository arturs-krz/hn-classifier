{
	"_id": "14347957",
	"site": "https://github.com/pubkey/rxdb?v=4.0.1",
	"title": " Rxdb â€“ A fast, reactive, client-side database",
	"author": "dsun176",
	"date": "2017-06-13T13:08:16.544Z",
	"tags": {
		"categories": [
			"opensource",
			"database",
			"serverless",
			"offline-first",
			"nosql",
			"reactive",
			"json-schema",
			"javascript",
			"rxjs",
			"browser",
			"nodejs",
			"electron",
			"cordova"
		],
		"languages": [
			"javascript",
			"html"
		]
	},
	"content": "readme.md announcement version 4.0.0 is released, read changelog reactive, serverless, client-side, offline- database javascript. featuresmultiplatform support browsers, nodejs, electron, cordova, react-native every javascript-runtimereactive data-handling based rxjsreplication between client server-data, compatible pouchdb, couchdb ibm cloudantschema-based the easy--learn standard jsonschemamango-query exactly you from mongodb mongooseencryption single data-fields protect users dataimport/export the database-state (json), awesome coding tddmulti-window synchronise data between different browser-windows nodejs-processesorm-capabilities easily handle data-code-relationsplatform-supportrxdb is made that can exactly same code browsers nodejs electron react-native cordova/phonegap nativescript optimized, double-checked made boilerplates you directly start use rxdb frameworks react angular/ng2 ionic2 vuejsquickstartinstallation:npm install rxdb --save# peerdependenciesnpm install rxjs babel-polyfill --saveimport/require: es7import 'babel-polyfill'; // needed you dont polyfillsimport * rxdb 'rxdb';const db = await rxdb.create({ name: 'heroesdb', adapter: 'websql', password: 'mylongandstupidpassword', // optional multiinstance: true // default: true }); // create databaseawait db.collection({name: 'heroes', schema: myschema}); // create collectiondb.heroes.insert({ name: 'bob' }); // insert document es5require('babel-polyfill'); // needed you dont polyfillsvar rxdb = require('rxdb');rxdb.create({ name: 'heroesdb', adapter: 'websql', password: 'mylongandstupidpassword', // optional multiinstance: true // default: true }) // create database .(function(db) {return db.collection({name: 'heroes', schema: myschema});}) // create collection .(function(collection) {collection.insert({name: 'bob'});}) // insert documentfeature-showroom (click toggle) mango-query find data your collection, the mquery api create chained mango-queries, you maybe from mongodb mongoose. mycollection .find() .where('name').ne('alice') .where('age').gt(18).lt(67) .limit(10) .sort('-age') .exec().( docs => { console.dir(docs); }); reactive rxdb implements rxjs make data reactive. makes easy always show real- database-state the dom without manually re-submitting queries.db.heroes .find() .sort('name') .$ // <- returns observable query .subscribe( docs => { mydomelement.innerhtml = docs .map(doc => '<li>' + doc.name + '</li>') .join(); }); multiwindow/tab two instances rxdb the same storage-engine, state action-stream be broadcasted. means two browser-windows change window #1 automatically affect window #2. works completely serverless. replication rxdb relies glorious pouchdb, is easy replicate data between devices servers. yes, changeevents are synced. schema schemas are defined via jsonschema are used describe data.const myschema = { title: \"hero schema\", version: 0, // <- incremental version-number description: \"describes simple hero\", type: \"object\", properties: { name: { type: \"string\", primary: true // <- means: unique, required, string will used '_id' }, secret: { type: \"string\", encrypted: true // <- means the value this field is stored encrypted }, skills: { type: \"array\", maxitems: 5, uniqueitems: true, item: { type: \"object\", properties: { name: { type: \"string\" }, damage: { type: \"number\" } } } } }, required: [\"color\"]}; encryption setting schema-field encrypted: true, value this field be stored encryption-mode can't read without password. course can encrypt nested objects. example:\"secret\": { \"type\": \"string\", \"encrypted\": true} level-adapters underlaying pouchdb use different adapters storage engine. you use rxdb different environments just switching adapter. example can websql the browser, localstorage mobile-browsers a leveldown-adapter nodejs.// requires localstorage-adapterrxdb.plugin(require('rxdb-adapter-localstorage'));// creates database the localstorage-adapterconst db = await rxdb.create('heroesdb', 'localstorage'); adapters can :indexeddblocalstoragefruitdownmemorywebsql any leveldown-adapter import / export rxdb lets import export whole database single collections json-objects. is helpful trace bugs your application to move a given state your tests.// export single collectionconst jsoncol = await mycollection.dump();// export whole databaseconst jsondb = await mydatabase.dump();// import dump the collectionawait emptycollection.importdump(json);// import dump the databaseawait emptydatabase.importdump(json); leader-election imagine website needs get piece data the server once every minute. accomplish task create websocket pull-interval. your user opens site 5 tabs parallel, will run interval create socket 5 times. is waste resources can solved rxdb's leaderelection.myrxdatabase.waitforleadership() .(() => { // this only run the instance becomes leader. mysocket = createwebsocket(); }); this example leader is marked the crown key-compression depending which adapter in environment use rxdb, client-side storage is limited some or other. save disc-space, rxdb has internal schema-based key-compression minimize size saved documents.example:// you save object big keysawait mycollection.insert({ firstname: 'foo' lastname: 'bar' stupidlongkey: 5});// rxdb internally transform to{ '|': 'foo' '|b': 'bar' '|c': 5}// instead 46 chars, compressed-version has 28// compression works internally, you of course still access values via original key.namesconsole.log(mydoc.firstname);// 'foo' querychangedetection similar meteors oplog-observe-driver, rxdb has querychangedetection optimize observed reused queries. makes sure when update/insert/remove documents, query does have re-run the whole database the results be calculated the events. creates huge performance-gain zero cost. querychangedetection works internally is currently beta (disabled default). -case-exampleimagine have very big collection many user-documents. your page want display toplist users have most points are currently logged .you create query subscribe it.const query = userscollection.find().where('loggedin').eq(true).sort('points');query.$.subscribe(users => { document.queryselector('body').innerhtml = users .reduce((prev, cur) => prev + cur.username+ '<br/>', '');}); you may detect, query take very long to run, you thousands users the collection. a user loggs , the whole query re-run the database takes again very long.anyuser.loggedin = false;await anyuser.save(); not the querychangedetection enabled., when user loggs , it calculate new results the current results plus rxchangeevent. often be done -memory without making io-requests the storage-engine. querychangedetection only works subscribed queries, also you multiple .exec()'s the same query.browser support major evergreen browsers ie11 are supported. tests automatically run against firefox chrome, manually a virtualbox ie11 edge. rxdb heavily relies pouchdb, their browser support more information. do keep mind different browsers different storage limits, especially mobile devices.getting started started by reading docs exploring example-projects.contributecheck how can contribute this project.follow follow rxdb twitter not miss latest enhancements.join chat gitter discussion.support rxdb patreonthank a big thank to every patreon-supporter every contributor this project."
}