{
	"_id": "14412919",
	"site": "https://github.com/minio/c2goasm",
	"title": " C to Go Assembly",
	"author": "krishnasrinivas",
	"date": "2017-06-13T13:06:44.655Z",
	"tags": {
		"categories": [
			"opensource",
			"gcc",
			"llvm",
			"clang",
			"golang",
			"go",
			"plan9",
			"asm",
			"runtime"
		],
		"languages": [
			"go",
			"assembly",
			"c++",
			"other"
		]
	},
	"content": "readme.md c2goasm: c go assemblyintroduction is tool convert assembly generated a c/c++ compiler golang assembly. is meant be used combination asm2plan9s order automatically generate pure wrappers c/c++ code ( may instance advantage compiler simd intrinsics template<> code).mode operation:$ c2goasm - /path//some/great/c-code.s /path//now/great/golang-code_amd64.s can optionally nicely format code using asmfmt passing an -f flag. project has been developed part developing go wrapper around simd. however should work other projects libraries. keep mind though it is intented 'port' complete c/c++ project a single action rather it a case--case basis per function/source file ( create accompanying high level code call the assembly code).command line options$ c2goasm --helpusage c2goasm: -immediately invoke asm2plan9s -ccompact byte codes -fformat using asmfmt -sstrip comments simple examplehere is simple c function doing avx2 intrinsics computation:void multiplyandadd(float* arg1, float* arg2, float* arg3, float* result) { __m256 vec1 = _mm256_load_ps(arg1); __m256 vec2 = _mm256_load_ps(arg2); __m256 vec3 = _mm256_load_ps(arg3); __m256 res = _mm256_fmadd_ps(vec1, vec2, vec3); _mm256_storeu_ps(result, res);}compiling assembly gives following__zn14multiplyandaddepfs1_s1_s1_: ## @_zn14multiplyandaddepfs1_s1_s1_## bb#0: push rbp mov rbp, rsp vmovups ymm0, ymmword ptr [rdi] vmovups ymm1, ymmword ptr [rsi] vfmadd213ps ymm1, ymm0, ymmword ptr [rdx] vmovups ymmword ptr [rcx], ymm1 pop rbp vzeroupper retrunning c2goasm generate following assembly (eg. saved multiplyandadd_amd64.s)//+build !noasm !appengine// auto-generated c2goasm -- not edittext Â·_multiplyandadd(sb), $0-32movq vec1+0(fp), dimovq vec2+8(fp), simovq vec3+16(fp), dxmovq result+24(fp), cxlong $0x0710fcc5 // vmovups ymm0, yword [rdi]long $0x0e10fcc5 // vmovups ymm1, yword [rsi]long $0xa87de2c4; byte $0x0a // vfmadd213ps ymm1, ymm0, yword [rdx]long $0x0911fcc5 // vmovups yword [rcx], ymm1vzeroupperret needs be accompanied the following code ( multiplyandadd_amd64.)//go:noescapefunc _multiplyandadd(vec1, vec2, vec3, result unsafe.pointer)func multiplyandadd(someobj object) {_multiplyandadd(someobj.getvec1(), someobj.getvec2(), someobj.getvec3(), someobj.getresult()))} as may gathered amd64. file needs be place order the arguments names be derived ( allow vet succeed).benchmark against cgo have run benchmarks c2goasm versus cgo both version 1.7.5 1.8.1. can find c2goasm benchmark test test/ the cgo test cgocmp/ respectively. here are results both versions:$ benchcmp ../cgocmp/cgo-1.7.5. c2goasm. benchmark old ns/op ns/op deltabenchmarkmultiplyandadd-12 382 10.9 -97.15%$ benchcmp ../cgocmp/cgo-1.8.1. c2goasm. benchmark old ns/op ns/op deltabenchmarkmultiplyandadd-12 236 10.9 -95.38% you see golang 1.8 has made significant improvement (38.2%) 1.7.5, it is still 20x slower directly calling assembly code wrapped c2goasm.converted projects-cv-simd (wip)internals basic process is (in prologue) setup stack registers how c code expects to the case, upon exiting subroutine ( the epilogue) revert to golang world pass return value if required. more details:define assembly subroutine proper golang decoration terms needed stack space overall size arguments plus return value.function arguments are loaded the golang stack registers prior starting c code arguments beyond 6 are stored c stack space.stack space is reserved setup the c code. depending the c code, stack pointer maybe aligned a certain boundary (especially needed code takes advantages simd instructions such avx etc.). constants table is generated ( needed) any rip-based references are replaced proper offsets where will put table.limitationsarguments need ( now) be 64-bit size, meaning either value a pointer ( requirement be lifted)maximum number 14 arguments (hard limit -- you hit maybe should rethink api anyway...)generally call statements (thus inline c code) a couple exceptions functions such memset memcpy ( clib_amd64.s)generate assembly c/c++ eg. projects using cmake, here is to a list assembly targets$ help | grep \"\\.s\" see actual command generate assembly$ -n simdavx2bgratogray.ssupported golang architectures now the amd64 architecture is supported. arm64 should just fine a similar fashion support is lacking the moment.compatible compilers following compilers been tested:clang (apple llvm version) osx/darwinclang linuxcompiler flags:-masm=intel -mno-red-zone -mstackrealign -mllvm -inline-threshold=1000 -fno-asynchronous-unwind-tables -fno-exceptions -fno-rttiflagexplanation-masm=inteloutput intel syntax assembly-mno-red-zone not write below stack pointer (avoid red zone)-mstackrealign explicit stack initialization-mllvm -inline-threshold=1000higher limit inlining heuristic (default=255)-fno-asynchronous-unwind-tables not generate unwind tables ( debug purposes)-fno-exceptionsdisable exception handling-fno-rttidisable run- type information following flags are available clang -cc1 frontend mode ( below):flagexplanation-fno-jump-tables not jump tables may generated select statementsclang vs clang -cc1 per clang faq, clang -cc1 is frontend, clang is (mostly gcc compatible) driver the frontend. see options the driver passes to frontend, -### like :$ clang -### -c hello.c\"/usr/lib/llvm/bin/clang\" \"-cc1\" \"-triple\" \"x86_64-pc-linux-gnu\" etc. etc. etc.command line flags clang see command line flags either clang --help clang --help-hidden the clang driver clang -cc1 -help the frontend.further optimization fine tuningusing llvm optimizer (opt) can further optimize code generation. opt -help opt -help-hidden all available options. option be passed via clang using -mllvm <value> option, such -mllvm -inline-threshold=1000 discussed above. llvm allows to tune specific functions via function attributes define void @f() alwaysinline norecurse { ... }. about gcc support? now gcc code not out the box. however is reason why gcc should work fundamentally (prs are welcome).resources function assemblycompiler explorer (interactive)stack frame layout x86-64licensec2goasm is released under apache license v2.0. can find complete text the file license.contributingcontributions are welcome, please send prs any enhancements."
}