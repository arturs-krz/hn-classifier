{
	"_id": "14510335",
	"site": "https://github.com/CoNarrative/precept",
	"title": "Precept: A Declarative Programming Framework",
	"author": "abustamam",
	"date": "2017-06-13T14:09:57.326Z",
	"tags": {
		"categories": [
			"opensource",
			"rules",
			"clojure",
			"clojurescript",
			"functional-relational-programming",
			"declarative-programming",
			"functional-reactive-programming"
		],
		"languages": [
			"clojure",
			"shell",
			"css",
			"html"
		]
	},
	"content": "readme.md declarative programming frameworkdocs| example| issues| roadmap| contributing\" need specify you require, how must achieved.\" - of tar pitquick start the command line:lein precept myprojcd myprojlein figwheel will start todomvc example localhost:3449 a nrepl server localhost:7002. can interact the code calling (cljs) once repl is connected. it is whyprecept is framework creating reactive web applications using rules engine, declarative logic, relational data modeling.large, complex applicationsmany frameworks programming languages introduce complexity has nothing do the applications are trying build. ideally, only complexity should face is which is inherent the problem. programming is truly declarative states logic directly complex applications be written simple terms.graph data modelprecept models state a graph. can add facts the world without concerning ourselves its location an object. can query data perform derived computations it as easily. it works are facts there are rules. facts are data, rules are declarative statements that data. application state is represented facts, all application logic is expressed rules.facts three parts: entity id, attribute, a value. model data relationally are expressed clojure vectors.here's example fact:[123 :todo/title \" precept\"] | | | | | | e v\"thing 123 has attribute :todo/title, value which is ' precept'.\"rules two parts: conditions the consequences. conditions state facts must true the consequence happen. are expressed using pattern matching. consequences are valid clojure clojurescript code. have full access all variables were matched the rule's condition.here's example rule:(rule todo-is-visible [[_ :visibility-filter :active]] [[?e :todo/done false]] => (println \" todo this entity id is visible: \" ?e)\" visibility filter is \"active todos\" there's todo 's done, print todo's id.\"instead printing message, if wanted make todo visible? consequence the rule be new fact:...=>(insert! [?e :todo/visible true]))whenever fact is inserted, rules a chance respond it.suppose also had rule:(rule print-visible-titles [[?e :todo/visible true]] [[?e :todo/title ?title]] => (println \"visible todo title: \" ?title))\" there is visible todo, its title, print .\"this rule attempt join entity id between title fact a visible fact, meaning will try find title whose entity id matches entity id a visible todo. our rules do anything, need add facts. session is container rules facts. given session an optional set initial facts, precept makes resultant state available your views.(defn todo [title done] (let [id 123] [[id :todo/title title] id :todo/done false]]))(defn visibility-filter [kw] [(uuid) :visibility-filter kw])(session -session '-ns.rules) (start! {:session -session :initial-facts [(todo \" precept\") (visibility-filter :active)]})=> todo this entity id is visible: 123=> visible todo title: preceptsubscriptionscomponents subscribe queries rerender whenever query result changes. query subscriptions are defined rules, enjoy same performance benefits rules. namely, are rerun there is possible their results have changed. rete algorithm.here's subscription definition a visible todo:(defsub :visible-todos [[?e :todo/visible true]] [(<- ?todo (entity ?e))] => {:visible-todo ?todo}components subscribe the keyword defined defsub:(defn visible-todo [] (let [{:keys [db/id todo/title todo/done]} @(subscribe [:visible-todo])])) [:div title done]precept converts its subscription results maps, making work rendering data the view layer same other frontend libraries frameworks.inserting factsviews insert facts the session then. :on-change handler inserts fact a todo edit looks this:[:input {:-change #( [id :todo/edit (-> % .-target .-value)])}]precept modify value :todo/edit each keypress retracting previous fact inserting new . this is precept enforces -to- cardinality all facts default (.e., any entity-attribute pair, value exist any point time). this case means can't more one value entity 123's :todo/edit.schema supportprecept enforces cardinality uniqueness according datomic-format schemas. we wanted entities have multiple values the :todo/edit attribute, can specify one--many relationship it:(attribute :todo/edit :db/cardinality :db.cardinality/-to-many)-to-many attributes then returned components a list.;; tuple format [[123 :todo/edit \"h\"] [123 :todo/edit \"\"] [123 :todo/edit \"hey\"]];; map format{:db/id 123 :todo/edit [\"h\" \"\" \"hey\"]}unique attributes are handled using same semantics datomic :db.unique/identity :db.unique/value. there is conflict, instead throwing error, precept inserts facts the error the session they may handled resolved through rules.precept supports both :db-schema a :client-schema. allows to easily access facts want persist, while still allowing schema definitions your client-side data. client db schemas are both enforced same .differences datomic datascript, redux, re-frame, other front-end data stores, precept does attempt maintain history all facts. agree datomic's design respect this, because precept runs a web browser, space is relatively limited. our application, see more value that space being occupied tens thousands facts represent current state the world instead e.g. 100 facts 100 histories.rete algorithm the ideal world, are concerned performance, our language infrastructure provide the generalsupport desire. - of tar pit, emphasis addedprecept wrapsclara, ground- implementation the rete algorithm clojure clojurescript.rule engines are usually written the browser mind. clara is perhaps first. declarative approach front-end web development not feasible without work: writing declarative code requires algorithms underlie to performant. rete algorithm creates network nodes each rule. nodes are indexed, may shared, contain memories the values match. overall, rete trades space time, calculates incremental changes almost effort. solves vast majority situations the front-end where performance becomes consideration. keeping filtered list n items does require entire list be iterated through recalculated a item is added.where 're headed project board contains most -to-date information what features are being discussed, prioritized, worked . here's few 're excited .rendering viewsusing rule engine allows to exactly changes one state the next. means don't need react's diff algorithm the concept subscriptions. we declare views the consequences rules, can automatically point update when facts care change.ruleset api want use general purpose rulesets same we libraries. e.g. drag drop, typeahead, etc. ruleset api is the works make easy the community write pluggable sets rules application authors integrate seamlessly their own.dev tools clara's sessions are immutable, can store each and cycle through . clara provides tools inspecting sessions show rules fired why, facts were inserted by rule, were retracted, so .in addition, changes precept's view model visualized tracked like redux devtools.general purpose algorithmsprecept aims enable teams build increasingly game- uis. sometimes requires algorithms path-finding, tweening, collision detection, distance calculation. want write applications where talking these things is trivial. means never having fall to imperative programming, while the same having performance provides. 're working support declarative statements (<- ?my-trip (distance ?paris ?london)) allow to focus what, how, calling performant, general-purpose algorithms under covers.thanksclaradatomicdatascriptre-framereagentmike fikesdmitri sotnikov the luminus frameworkbruce hauman figwheelcursiveprecursor"
}