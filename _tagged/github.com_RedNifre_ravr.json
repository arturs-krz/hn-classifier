{
	"_id": "14400453",
	"site": "https://github.com/RedNifre/ravr",
	"title": " Ravr brings Ramda-style parameter placeholders to vavr/java",
	"author": "RedNifre",
	"date": "2017-06-13T13:07:23.176Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"java"
		]
	},
	"content": "readme.md is partial port the ramda.js functional programming library work vavr types.v0.0.10 (experimental, incomplete)adding to projectmaven's on maven central yet, you find in jcenter. , add jcenter the repositories your pom: <repositories> <repository> <id>jcenter</id> <url>http://jcenter.bintray.com </url> </repository> </repositories> you import as usual: <dependencies> <dependency> <groupid>de.michaelzinn.ravr</groupid> <artifactid>ravr</artifactid> <version>0.0.10</version> </dependency> </dependencies>gradlecompile 'de.michaelzinn.ravr:ravr:0.0.10'curried functions & partial function applicationravr provides ways do partial application: either leave parameters the end use parameter placeholder:// the samelist.(1, 2, 3).map(x -> add(2, x));list.(1, 2, 3).map(add(2, __)); // works isn't idiomaticlist.(1, 2, 3).map(add(2)); // this instead// => [3, 4, 5]// placeholder should be used necessary.list.(7, 8, 9).map(subtract(__, 2));// => [5, 6, 7]function composition can compose functions two ways.composesimiliar mathematical composition. is vararg function.// classic javamap(add(1).compose(multiply(2)).compose(subtract(__, 1)), list(2, 3, 4));// => [3, 5, 7]// ravr stylemap(compose(add(1), multiply(2), subtract(__, 1)), list(1, 2, 3));// => [3, 5, 7]pipesame compose, with order inverted. can more readable putting functions separate lines.list<string> words = list.(\"xsihtx\", \"xsix\", \"xgnitseretnix\");assertthat(join(\"... \", words.map(pipe(ravr::reverse,ravr::tolower,ravr::init,ravr::tail))),is(\"... is... interesting\"));functor, applicative, monadravr provides map, ap, flatmap.patternstandard nameramda nameravr nametype signaturefunctormapmapmapfunctor m => ( -> b) -> m -> m bapplicativeapplyapapapplicative m => m ( -> b) -> m -> m bmonadbindchainflatmapmonad m => ( -> m b) -> m -> m bdue limits java's type system currently work lists, options, traversables futures.lenses (experimental)lenses work types implement included copyable interface, is simplified version the cloneable interface. simplest to implement is wrapping clone function:@getters // lombok@setters // lombok@allargsconstructor // lombokclass thing implements copyable<thing> {string name;int quality;@override public thing copy() { return safeclone(() -> clone()); }}note: ide might tell to replace lamda a method reference. might work of reasons. can create lens using pair getters setters. can the lens combination get, set over:lens<thing, string> name = lens(thing::getname, thing::setname);lens<thing, integer> quality = lens(thing::getquality, thing::setquality);thing lookingglass = thing(\"looking glass\", 5);(name, lookingglass); // \"looking glass\"function1<thing, thing>improve = pipe(set(name, \"ten times better\"),(quality, multiply(10)));thing betterthing = improve.apply(lookingglass);(quality, betterthing); // 50(quality, lookingglass); // 5 ( changed) functions can concatenate content a list<option<x>> list<x> the concatoptions function.list<string> strings = list(\">>>>\", \"\", \"====\");pipe(head(),// list.(option.(\">\"), option.none(), option.(\"=\"))concatoptions(),// list.(\">\", \"=\")join(\">\")// \">>=\").apply(strings);'s includediconmeaningworksworks issues implemented plannedbonus function originally included ramda.js list is generated automatically slightly inaccurate right .statusfunctionnoteaddaddindexadjustallpassalwaysanyanypassapapertureappendapplyapplyspecap_listap_optionaplistapoptionascendassocassocpathbinarybindbothcallchainclampclonecomparatorcomplementcomposecomposekcomposepconcatconcatoptionscondconstructconstructncontainsconvergecountcountbycurrycurryndecdefaulttodescenddifferencedifferencewithdissocdissocpathdividedropdroplastdroplastwhiledroprepeatsdroprepeatswithdropwhileeitheremptyendswitheqeqbyeqpropsequalsevolveffilterfindfindindexfindlastfindlastindexflatmapflatmap_listflatmap_optionflatmaplistflatmapoptionflattenflipforeachforeachobjindexedfrompairsgroupbygroupwithgtgtehashasinheadhead_stringheadstringidenticalidentityifelseincindexbyindexofinitinnerjoininsertinsertallintersectionintersectionwithintersperseinvertinvertobjinvokerisisemptyisnilisnonereplacement isnil, returns true option.none().issomereplacement complement(isnil), returns true option.(\"whatever\").joinjoinoption join, except it returns nothing joining empty lists.juxtkeyskeysinlastlastindexoflengthlenslensindexlenspathlenspropliftliftnltltemapmapaccummapaccumrightmapleftmaps left side an eithermapleft_eithermaplefteithermapobjindexedmap_eithermap_listmap_optionmapeithermaplistmapoptionmatchmathmodmaxmaxbymeanmedianmemoizememoizewithmergemergeallmergedeepleftmergedeeprightmergedeepwithmergedeepwithkeymergewithmergewithkeyminminbymodulomultiplynarynegatenonenthnthargnulltooobjofomitonceoverpairpartialpartialrightpartitionpathpatheqpathorpathsatisfiespickpickallpickbypipepipekpipeppluckprependproductprojectproppropeqpropisproporpropspropsatisfiesrangerangecclosed rangereducereducebyreducedreducerightreducewhilerejectremoverepeat't curried.replacereversescansequencesetslicesortsortbysortwithsplitsplitatspliteverysplitwhenstartswithsubtractsumsymmetricdifferencesymmetricdifferencewithttailtakelasttakelastwhiletakewhiletaptesttimestolowertopairstopairsintostringtouppertransducetransposetraversetrimtrycatchtypeunapplyunaryuncurrynunfoldunionunionwithuniquniqbyuniqwithunlessunnestuntilupdateusewithvaluesvaluesinviewwherewhereeqwithoutxprodzipzipobjzipwith_isarraylikefuture plans ramda functions be added needed.contributing scope this library is port ramda. extra functions concatoptions should the exception. contact on twitter.licensed under lgpl v3, the license file details."
}