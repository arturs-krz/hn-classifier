{
	"_id": "14401815",
	"site": "https://github.com/intrinio/intrinio-realtime-ruby-sdk",
	"title": " Real-Time Stock Price SDK for Ruby",
	"author": "civilframe",
	"date": "2017-06-13T13:07:22.839Z",
	"tags": {
		"categories": [
			"opensource",
			"intrinio",
			"real-time",
			"stock-prices",
			"sdk",
			"finance",
			"ruby"
		],
		"languages": [
			"ruby"
		]
	},
	"content": "readme.md intrinio ruby sdk real- stock pricesintrinio provides real- stock prices the iex stock exchange, via two- websocket connection. get started, subscribe here follow instructions below.requirementsruby 2.3.1featuresreceive streaming, real- price quotes the iex stock exchangebid, ask, last priceorder sizeorder execution timestampsubscribe updates individual securitiessubscribe updates all securities (contact for special access)installationgen install intrinio-realtimeexample usagerequire 'intrinio-realtime'require 'thread/pool'# provide intrinio api access keys (found https://intrinio.com/account)username = \"your_intrinio_api_username\"password = \"your_intrinio_api_password\"# setup loggerlogger = logger.($stdout)logger.level = logger::info# specify optionsoptions = { username: username, password: password, channels: [\"msft\",\"aapl\",\"ge\"], logger: logger}# setup pool 50 threads handle quotespool = thread.pool(50)# start listening quotesintrinio::realtime.connect(options) |quote| # process quote next available thread pool.process logger.info \"quote! #{quote}\" sleep 0.100 # simulate 100ms i/o operation endendhandling quotes handling quotes, sure do in non-blocking fashion. recommend using thread gem setup thread pool operations writing quotes database ( anything else involving -consuming /o). your handling code blocks, new quotes be received until code is finished. in order make sure receive incoming quotes, handle individual quotes a thread pool. listening individual security channels, recommend thread pool size 50. the $lobby channel, recommend 500 higher. you find the quotes are being processed quickly enough, increase pool size - is likely they are being backed in thread pool's backlog ( you check accessing pool.backlog).quote fields{ type: 'ask', timestamp: 1493409509.3932788, ticker: 'ge', size: 13750, price: 28.97 }type - quote typelast - represents last traded pricebid - represents top--book bid priceask - represents top--book ask pricetimestamp - unix timestamp ( microsecond precision)ticker - ticker the securitysize - size the last trade, total volume orders the top--book bid ask priceprice - price usdchannels receive price quotes the intrinio real- api, need instruct client \"join\" channel. channel be security ticker (aapl, msft, ge, etc) security lobby ($lobby) where price quotes all securities are posted security last price lobby ($lobby_last_price) where last price quotes all securities are postedspecial access is required both lobby channeles. contact for more information.api keys will receive intrinio api username password creating account. will need subscription the iex real- stock prices data feed well.documentationmethodsintrinio::realtime.connect(options, &block) - connects the intrinio realtime feed provides quotes the given block.parameter options.username: intrinio api usernameparameter options.password: intrinio api passwordparameter options.channels: (optional) array channels join connectingparameter options.logger: (optional) ruby logger use loggingparameter &block: block receives quote its parameter. note: block must execute a non-blocking fashion ( using thread pool, example). otherwise quotes be dropped until is done blocking.intrinio::realtime.connect(options) |quote| # handle quote a non-blocking fashionendintrinio::realtime::client.(options) - creates new instance the intrinio realtime client.parameter options.username: intrinio api usernameparameter options.password: intrinio api passwordparameter options.channels: (optional) array channels join connectingparameter options.logger: (optional) ruby logger use loggingoptions = { username: username, password: password, channels: [\"msft\",\"aapl\",\"ge\"]}client = intrinio::realtime::client.(options)client.on_quote |quote| # handle quote a non-blocking fashionendclient.connect()client.connect() - retrieves auth token, opens websocket connection, starts self-healing heartbeat intervals, joins requested channels.client.disconnect() - closes websocket, stops self-healing heartbeat intervals. must call to dispose the client.client.on_quote(&block) - invokes given block a quote has been received.parameter block - block invoke. quote be passed an argument the block.client.on_quote |quote| # handle quote a non-blocking mannerendclient.join(...channels) - joins given channels. can called any . the client automatically register joined channels establish proper subscriptions the websocket connection.parameter channels - argument list array channels join.client.join(\"aapl\", \"msft\", \"ge\")client.join([\"goog\", \"vg\"])client.join(\"$lobby\")client.leave(...channels) - leaves given channels.parameter channels - argument list array channels leave.client.leave(\"aapl\", \"msft\", \"ge\")client.leave([\"goog\", \"vg\"])client.leave(\"$lobby\")client.leave_all() - leaves channels."
}