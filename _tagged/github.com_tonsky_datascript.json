{
	"_id": "14416874",
	"site": "https://github.com/tonsky/datascript",
	"title": "Clojure DataScript",
	"author": "tosh",
	"date": "2017-06-13T13:56:32.802Z",
	"tags": {
		"categories": [
			"opensource",
			"clojure",
			"database",
			"memory-database",
			"clojurescript",
			"datascript"
		],
		"languages": [
			"clojure",
			"javascript",
			"other"
		]
	},
	"content": "readme.md if creating database be cheap creating hashmap? immutable -memory database datalog query engine clojure clojurescript.datascript is meant run inside browser. is cheap create, quick query ephemeral. create database page load, put data it, track changes, queries forget it the user closes page.datascript databases are immutable based persistent data structures. fact, re more data structures databases ( hashmap). unlike querying real sql db, you query datascript, all comes down a hashmap lookup. series lookups. array iteration. s particular overhead it. put little data it, s fast. put a lot data, , at least has indexes. should better you filtering array hand anyway. thing is really lightweight. intention datascript is be basic building block client-side applications needs track lot state during lifetime. s lot benefits:central, uniform approach manage application state. clients working state become decoupled independent: rendering, server sync, undo/redo not interfere each .immutability simplifies things in single-threaded browser environment. keep track app state evolution, rewind any point time, always render consistent state, sync background without locking anybody.datalog query engine answer non-trivial questions current app state.structured format track data coming and of db. datalog queries be run against too.resources books:learning clojurescript has chapter datascriptdocs:getting startedtutorialsdatascript 101tips & tricksposts: datascript fits the current webdev ecosystemdatascript internals explainedsketch client/server reactive architecturetalks:frontend joy talk (fpconf, august 2015): video russianprogramming web ui database a browser talk (polyconf, july 2015): slides, videodatascript web development talk (clojure exchange, dec 2014): slides, videobuilding todo list datascript webinar (clojurescript nyc, dec 2014): video, appdatascript hangout (may 2014, russian): videoprojects using datascript:precursor, collaborative prototyping toollightmesh, datacenter managementcognician, coaching platformbitfountain, ios coursespartsbox, electronic parts management am fy, accessories e-shopacha-acha, github achievements (sources, code walkthrough)radiant, datalog sketchpad (sources)showkr, flickr gallery viewer (sources)zetawar, turn-based tactical strategy gamelemmings, incubator focused art & artificial intelligencerelated projects:datascript-transit, transit serialization database datomsposh, lib lets use single datascript db store reagent app statedatascript-mori, datascript & mori wrapper use jsdatsync, datomic datascript syncing/replication utilitiesintension, lib convert associative structures in-memory databases querying datamaps, lib designed leverage datalog queries query arbitrary maps.demo applications:localisation demo om nexttodo, task manager demo app (persistence via localstorage transit, filtering, undo/redo): sources, livecatchat, chat demo app: sources, code walkthrough, liveclj-crud, demo crud app: sources, blog postomnext todomvcusage examples more examples, our acceptance test suite.:dependencies [ [org.clojure/clojure \"1.7.0\"] [org.clojure/clojurescript \"1.7.228\"] [datascript \"0.16.1\"]]note: since datascript 0.13 main namespace include is datascript.core, datascript. was done usage top-level namespaces is discouraged even generates warning cljs. old datascript.core, you were using , was renamed datascript.dbwarn: clojurescript versions 1.7.48, 1.7.58 1.7.107 break datascript. either 1.7.28, 1.7.122 newernote: datascript 0.11.3 later requires cljs 0.0-3291 laternote: datascript 0.11.2 later requires clojure 1.7.0-beta2 laternote: datascript 0.11.0 later only with cljs 0.0-3196 later(require '[datascript.core : d]);; implicit join, multi-valued attribute(let [schema {:aka {:db/cardinality :db.cardinality/many}} conn (d/create-conn schema)] (d/transact! conn [ { :db/id -1 :name \"maksim\" :age 45 :aka [\"max otto von stierlitz\", \"jack ryan\"] } ]) (d/q '[ :find ?n ? :where [?e :aka \"max otto von stierlitz\"] [?e :name ?n] [?e :age ?] ] @conn));; => #{ [\"maksim\" 45] };; destructuring, function call, predicate call, query collection(d/q '[ :find ?k ?x : [[?k [?min ?max]] ...] ?range :where [(?range ?min ?max) [?x ...]] [(? ?x)] ] { : [1 7], :b [2 4] } range);; => #{ [: 2] [: 4] [: 6] [:b 2] };; recursive rule(d/q '[ :find ?u1 ?u2 : $ % :where (follows ?u1 ?u2) ] [ [1 :follows 2] [2 :follows 3] [3 :follows 4] ] '[ [(follows ?e1 ?e2) [?e1 :follows ?e2]] [(follows ?e1 ?e2) [?e1 :follows ?t] (follows ?t ?e2)] ]);; => #{ [1 2] [1 3] [1 4];; [2 3] [2 4];; [3 4] };; aggregates(d/q '[ :find ?color (max ?amount ?x) (min ?amount ?x) : [[?color ?x]] ?amount ] [[:red 10] [:red 20] [:red 30] [:red 40] [:red 50] [:blue 7] [:blue 8]] 3);; => [[:red [30 40 50] [10 20 30]];; [:blue [7 8] [7 8]]]using vanilla jsdatascript be used any js engine without additional dependencies:<script src=\"https://github.com/tonsky/datascript/releases/download/0.16.1/datascript-0.16.1.min.js\"></script> as commonjs module (npm page):npm install datascriptvar ds = require('datascript'); as requirejs module:require(['datascript'], function(ds) { ... });queries:query rules should edn passed stringsresults q are returned regular js arraysentities:entities returned entity call are lazy in clojure e.(\"prop\"), e.(\":db/id\"), e.db access entity propertiesentities implement ecmascript 6 map interface (has//keys/...)transactions: strings such \":db/id\", \":db/add\", etc. instead db-namespaced keywords regular js arrays objects pass data transact db_withtransaction reports:report.tempids has string keys (\"-1\" entity tempid -1), resolve_tempid set a correspondencecheck test/js/tests.js usage examples.project statusbeta quality. of features done, expecting api polishing (breaking) performance optimizations. docs the moment, examples & datomic documentation. following features are supported:database a value: each db is immutable value. dbs are created top old ones, old ones stay perfectly valid tootriple store modeleavt, aevt avet indexesmulti-valued attributes via :db/cardinality :db.cardinality/manylazy entities :db/valuetype :db.type/ref auto-expansiondatabase mutations via transact!callback-based analogue txreportqueue via listen!direct index lookup iteration via datoms seek-datomsfiltered databases via filterlookup refsunique constraints, upsertpull api (thx david thomas hume)query engine features:implicit joinsquery db regular collectionsparameterized queries via : clausetuple, collection, relation binding forms :in clausequery multiple db/collectionspredicates user functions queryrules, recursive rulesaggregatesfind specificationsinterface differences:conn is an atom storing last db value, @conn instead (d/db conn)instead #db/id[:db.part/user -100] use -100 place :db/id entity idtransactor functions be called [:db.fn/call f args] where f is function reference will db first argument (thx @thegeez) clojurescript, custom query functions aggregates should passed source instead being referenced symbol (due lack resolve cljs)custom aggregate functions are called via aggregate keyword: :find (aggregate ?myfn ?e) : $ ?myfnadditional :db.fn/retractattribute shortcuttransactions are annotated default :db/txinstantexpected soon:better error reportingproper documentation, not-join, and -join datalog clausesdifferences datomicdatascript is built totally scratch is related any means the popular clojure database datomicruns a browser /or a jvmsimplified schema, queryableattributes not to declared advance. put to schema when need special behaviour them type be used values :db/ident attributes, keywords are literally attribute values, integer id behind no schema migrations cache segments management, laziness. entire db must reside memory facilities persist, transfer the wire sync db the server pluggable storage options, full-text search, partitions external dependenciesfreeaimed interactive, long-living browser applications, datascript dbs operate constant space. you not add entities, update existing ones, clean database time time, memory consumption be limited. is unlike datomic keeps history all changes, thus grows monotonically. datascript does track history default, you do via own code needed. of features are omitted intentionally. different apps different needs storing/transfering/keeping track db state. datascript is foundation build exactly right storage solution your needs without selling too much vision.licensecopyright Â© 20142015 nikita prokopovlicensed under eclipse public license ( license)."
}