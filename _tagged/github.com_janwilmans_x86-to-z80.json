{
	"_id": "14441321",
	"site": "https://github.com/janwilmans/x86-to-z80",
	"title": "X86-to-z80: x86-to-z80 re-assembler",
	"author": "ingve",
	"date": "2017-06-13T13:55:21.501Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c++",
			"other"
		]
	},
	"content": "readme.md attempt translate x86 assembly z80 assembly. idea is make c++ available z80 based computers the msx. process works using clang (llvm 3.9.1) compiler convert c++ x86 assembly then re-assembling output z80-assembly a pretty static 1:n translation project is forked lefticus/x86--6502 i intend keep support the 6502, even though named project x86--z80, could x86--multiplecpus later ( preferably better name).discuss follow twitter, you :https://twitter.com/janwilmansreferenceshttp://releases.llvm.org/download.htmlhttp://www.nowind.nlusing visual studio 2017 rc1 clang-supporthttps://www.visualstudio.com/vs/visual-studio-2017-rc/http://www.myquest.nl/z80undocumented/z80-documented-v0.91.pdfwhy? want use c++17 futher nowind development (www.nowind.nl) it is way me learn it takes create re-assembler a platform where modern compilers are available. think can very cool application modern, small, low-cost, embedded processesors where vendors not necessarily the effort maintain own toolchain.?cd %~dp0:: appearently clang needs visual studio headers compile windows, :: doesn't much sense me, it works.call \"c:\\program files (x86)\\microsoft visual studio 14.0\\common7\\tools\\vsvars32.bat\"c:\\project\\llvm\\bin\\clang++.exe %1 -o3 -s:: http://clang.llvm.org/get_started.html, consider using::: -fomit-frame-pointer:: -emit-llvm (maybe less optimized?)examplestruct z80{ volatile uint8_t& memory(const uint16_t address) { return *reinterpret_cast<uint8_t*>(address); }};int main(){ z80 z80; auto usefreelambda = [&]() { z80.memory(0xa000) = 0x10; }; usefreelambda(); return 0;}is re-assembled : ld ,16 ; movb $16, 40960 ld (40960), ; movb $16, 40960 xor ; xorl %eax, %eax ret ; retlprogress?'m currently exploring different options. thoughts:is i386 z80 assembly relatively easy conversion? is, let's a mips z80 conversion easier (suggested since mips cpus fewer registers appearently flag-registers sounds a plus translation). however, could mean the code get optimized memory-access operations instead using registers.going further along those lines, it be better just an llvm backend the z80 ? way code gets optimized the amount registers the z80 actually has :)'m currently reading on a llvm backend is constructed http://jonathan2251.github.io/lbd/llvmstructure.html conclusion far: i386 z80 path seems viable both assembly languages are somewhat familiar me, instead learning to code backends learning new assembly language , i continue this path now.maintaining i386 state the z80 i386 consists :registers: eax, ebx, ecx, edx, esi, edi, ebp esp (8x4=32 bytes)segment registers: cs, ss, ds, es, fs, gs (6x2=12 bytes) more registers: eflags 32bits (zero, carry, overflow, etc.) eip (instruction pointer) x86 instruction change of registers ( i refer collectively 'the i386 state'). i386 state have be maintained/available , the z80 target. is a subsequent instruction's exection/result be dependend this state.since z80 has :registers: af, bc, de, hl, ix, iymore register: sp (stack pointer), ip (instruction pointer) memory (48 bytes) have be used store i386 state. memory be allocated the stack, perhaps static allocation the start the 0x100 area offer better optimization opportunities. using stack most strait-forward to update values be:ld ,5 ; 2-byte operation, 7 t-statesld (ix+n), ; ix iy allow indexing, where n is offset bytes the register relative ix pointing the memory, 20 t-states total 6 bytes 27 t-states. downside this is ld (ix+n),r is relatively slow operation.alternatively:ld ,5 ; same 2 bytes, 7 t-states ld (nn), ; 3 bytes, where nn is absolute memory address, 13 t-state operation total 5 bytes 20 t-states. saves 1 byte 6 t-states every register load/save, moreover, does changes a-register.z80 process setup / memory layout z80 run msxdos 2.xx (developed microsoft spectravideo) is cp/m derivate.(msx actually stands microsoft extened, at least, like think :)msxdos uses fixed memory layout looks this (roughly):0-0xff = reserved area (zero page) msxdos (https://en.wikipedia.org/wiki/msx-dos)0x100-0xdffff (~56kb) = available program0xe000-0xefff = area stack growing down, actually defined area, i keep of area allow a 4kb stack now.0xf000-0xffff = reserved area msx bios msx basic (settings, screen modes, shadow memory vdp etc.) program is linked a .com file is exactly a ms-dos .com file that has header, relocation information code+data, in segment, limited , theoretically, 65kb-256 bytes. however, since need repect 'other stuff' mentioned above, filesize limit is somewhat smaller .does mean program only 56kb? initially: yes, once started, more data/code be loaded other files. generally 128kb memory is available least (switchable 16kb segments called 'banks') the test-machine my desk has 4mb ram available (256 banks 16kb). .com file is always completely loaded starting address 0x100. this is environment link ....awkwardbinding c++ methods bios functions is bit awkward, problem: method needs call fixed memory address so:ld de, \" text\"ld c,9 ; command '9' is 'output string console' / sortof std::cout call 0x5 ; call bdos ( fixed hook address invoke bios-function) option is create method assembly link it, hard-coding against x86 abi (https://en.wikipedia.org/wiki/x86_calling_conventions).second option is awkward, somewhat cleaner (maybe): void writestdout(const char* text) { register const char* textaddres asm(\"dx\") = text; // force into 'dx' asm(\" \\ movb 0x9, %%cl; # console output \\ calll 0x5; # bdos \\ \" :: \"r\"(textaddres) : \"%eax\"); }basically i'm doing here is hardcoding against own re-assembler, using knowlegde how cl map 'c' dx map 'de'. is writing z80 code i386 syntax :) second method has advantage giving compiler knowlegde what registers are affected, might offer better optimization opportunities."
}