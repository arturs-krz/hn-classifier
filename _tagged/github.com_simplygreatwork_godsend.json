{
	"_id": "14306066",
	"site": "https://github.com/simplygreatwork/godsend",
	"title": " Godsend, separation of concerns for streaming micro-services",
	"author": "simplygreatwork",
	"date": "2017-06-13T13:08:57.963Z",
	"tags": {
		"categories": [
			"opensource",
			"javascript",
			"messaging",
			"message-bus",
			"message-broker",
			"message-passing",
			"microservice",
			"microservices",
			"microservices-architecture",
			"broker",
			"filter",
			"bus",
			"stream",
			"stream-processing",
			"streaming-data",
			"streaming-api",
			"streams"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md godsendseparation concerns streaming micro-services. important goal godsend is ease software development workflow without tedium. example, quickly save data any undefined collection during development process. back later add validation a collection a message pattern processor the bus any order anywhere your application any . then, add data transformation processor some location your project. multiple message pattern processors are able manage filter same request stream yet decoupled. lets compose pipe streams dynamically runtime.set broker's exchange learning mode. continue develop application. , when 're ready publish, a quick authorization review, publish using secure broker exchange. since user authorization is based message patterns, access undefined collections becomes prohibited access resources unauthorized users gets locked down.versioning message pattern processors is based the exchange's configuration the user sending request the content that sent message pattern.key featuressend messages the bus a stream process messages a stream.inject message processors filter stream any location your project decouple concerns such validation transformation. (mutable composition separation concerns)multiple message processors are able process, filter, transform particular message request a controlled, composed order. secure messaging exchange learns authorization automatically ( exercise).message processors may versioned according the connected user. processor versions are dynamically substituted the processor list upon each user's request. broker exchange, the sender, determines processor version the sending user's configuration.property-based message patterns. clean, concise, yet expressive apifew assumptionsuniversal/isomorphic ( the browser in node.js) messaging scheme is totally open configurable per processor is necessary predetermined use wildcards regular expressions pattern matching. you . the default intended scheme is match multiple property/value pairs within object.quick startnpm install godsend-examplescd ./node_modules/godsend-examples/examples/storing-dataport=8082 node example.jsinitially, likely to install run godsend-examples not godsend itself. now, please run each example directly inside own directory.cd ./transforming-data/port=8082 node example.jsstarting server can start server run without configuring authorization. might this get started quickly to practice quickly.however, software applications are going require authorization. basic.server({ exchange : godsend.exchange.open()}).start(function() { console.log(' server has started.');}.bind());starting server authorization (preferred) method requires the server is provided basic initial users allow authorizer the broker communicate the bus. the examples, initial users \"broker\" \"authorizer\" are supplied the secure exchange godsend-basics/src/users.json. you also customize users pass into own instance the server manually. refer godsend-examples many more examples use authorization. basic.server({ address : 'http://127.0.0.1:8080/',}).start(function() { basic.authorizer({ address: 'http://127.0.0.1:8080/', users: .users }).connect(function() { console.log(' server has started.'); }.bind());}.bind());connecting the bus without authorizationinvoke godsend.connect supply broker address. subsequent calls connection.send queue until connection is fully established.var connection = godsend.connect({ address : 'http://127.0.0.1:8080/'});connecting the bus authorizationinvoke godsend.connect supply broker address credentials. subsequent calls connection.send queue until connection is fully established.var connection = godsend.connect({ address : 'http://127.0.0.1:8080/', credentials: { username: 'username', passphrase: 'passphrase', }});sending simple request (non-streaming)send message the bus calling connection.send(). pattern be number properties a json object. data is content wish send.\"receive\" is called the request has finished. result provides members an \"objects\" array an \"errors\" array.connection.send({ pattern: { action: 'message' }, data : [{ message : 'hello' }], receive: function(result) { console.log(' request has finished.'); console.log('result.objects: ' + json.stringify(result.objects, null, 2)); console.log('result.errors: ' + json.stringify(result.errors, null, 2)); }.bind()});sending streamed requestsend message the bus calling connection.send(). pattern be number properties a json object. function \"write\" is called the stream is ready writing. function \"read\" is called whenever request has responded an object. function \"error\" is called whenever request has responded an error.receive is called the request has finished. result provides members an \"objects\" array an \"errors\" array.connection.send({ pattern: { action: 'message' }, write: function(stream) { stream.write({ message: 'hello' }); stream.write({ message: 'world' }); stream.end(); }.bind(), read: function(object) { console.log('read response object: ' + json.stringify(object, null, 2)); }, error: function(error) { console.log('read response error: ' + json.stringify(error, null, 2)); }, receive : function(result) { console.log(' request has finished.'); console.log('result.objects: ' + json.stringify(result.objects, null, 2)); console.log('result.errors: ' + json.stringify(result.errors, null, 2)); }});processing requests typically process messages using connection node.js not the browser. ( exception is reacting messages sent the server)\"id\" be used name processor run separate processor \"before\" \"after\".\"id\" also used group multiple versions the same processor.\"\" is called to determine whether processor ought indeed process request.invoke request.accept({...}), request.skip, /or request.matches({...}) indicate match.\"run\" is invoked upon each object processed the stream.stream.object is current value.call stream.push proceed the same value, different values entirely, even omit call stream.push.call stream.next continue the next processor.connection.mount({ id: 'message', : function(request) { request.accept({ action: 'message' }); }.bind(), run: function(stream) { stream.push({ reply : ' said: ' + stream.object.message }); stream.next(); }.bind()});processing sent request before prior processor this example, processor \"store-put-validate-task\" be processed before \"store-put\". you multiple processors the same request, accepted patterns not to match exactly.connection.mount({ id: 'store-put-validate-task', before : 'store-put' : function(request) { request.accept({ topic : 'store', action: 'put', collection : 'task' }); }.bind(), run: function(stream) { (valid) { stream.push(stream.object); } else { stream.err(stream.object); } stream.next(); }.bind()});processing sent request between other processors (before, after). this example, processor \"message\" be processed \"prior-processor\" before \"next-processor\". you multiple processors the same request, accepted patterns not to match exactly.connection.mount({ id: 'message', : 'prior-processor' before : 'next-processor' : function(request) { request.accept({ action: 'message' }); }.bind(), run: function(stream) { console.log('logging message: ' + json.stringify(stream.object, null, 2)); stream.push(stream.object); stream.next(); }.bind()});processing sent request using processor weights can add processors order weight.negative weights are early.positive weights are late.connection.mount({ id: 'pre-process', weight : -100 : function(request) { request.accept(); }.bind(), run: function(stream) { console.log('pre-processing pattern: ' + json.stringify(stream.request.pattern, null, 2)); stream.push(stream.object); stream.next(); }.bind()});connection.mount({ id: 'post-process', weight : 100 : function(request) { request.accept(); }.bind(), run: function(stream) { console.log('post-processing pattern: ' + json.stringify(stream.request.pattern, null, 2)); stream.push(stream.object); stream.next(); }.bind()});advanced processor request matching can describe request matching explicitly:connection.mount({ id: 'message', : function(request) { (request.matches({ action : 'message' })) { request.accept(); } else { request.skip(); } }.bind(), run: function(stream) { stream.push(stream.object); stream.next(); }.bind()});or can implement request matching logic yourself you need :connection.mount({ id: 'message', : function(request) { (matches) { request.accept(); } else { request.skip(); } }.bind(), run: function(stream) { stream.push(stream.object); stream.next(); }.bind()});declaring different versions a processorprocessor versions are substituted based upon versions defined within user's profile.connection.mount({ id: '-processor', version: { name: 'version-', 'default': true }, : function(request) { request.accept({ topic: 'store', action: '' }); }.bind(), run: function(stream) { console.log('getting data the store. (v2 : default)'); stream.push(stream.object); stream.next(); }.bind()});processing outbound requestsoutbound requests are processed before sender's connection delivers data the exchange. could encrypt data strip data mounting outbound processor.connection.mount({ route : 'outbound' id: 'encypt', : function(request) { request.accept({ }); }.bind(), run: function(stream) { stream.push(stream.object); stream.next(); }.bind()});processing inbound requestsinbound requests are processed the exchange has returned data the sender's connection - before sender receives .you decrypt data update gui aspects mounting inbound processor.connection.mount({ route : 'inbound' id: 'decrypt', : function(request) { request.accept({ }); }.bind(), run: function(stream) { stream.push(stream.object); stream.next(); }.bind()});learning exchange authorization learning exchange learn patterns issued a sender, if receiver's processors modify least or more the objects returned that sender. a receiver's processors not modify transform of objects the sender, receivable pattern not learned.understand streaming godsendsuppose, , that you write objects the bus, these exact same objects returned the sender (echoed).next, imagine scenario these objects are transformed (modified) before get returned the sender.imagine, instead, scenario each object gets stored, is returned, a single aggregate response object is created returned. inverse this is possible: send object ( query, example) multiple objects returned a result. summary, use processors godsend transform request become response: many many, to , one many, many one. request godsend have many processors working together process same request data. fundamentally, is why transformation stream is used transform request a response.support project has been tested a production environment. security, error handling, fault tolerance need more evaluation. you encounter issues installing, starting, using godsend, please email simplygreatwork@gmail.com. will greatly appreciate efforts.godsend subprojectsgodsend examplesgodsend basicsgodsend extrasgodsend example diagrams"
}