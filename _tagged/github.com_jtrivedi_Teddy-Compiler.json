{
	"_id": "14326716",
	"site": "https://github.com/jtrivedi/Teddy-Compiler",
	"title": " Teddy, an educational compiler written in Swift",
	"author": "janum",
	"date": "2017-06-13T13:08:17.407Z",
	"tags": {
		"categories": [
			"opensource",
			"compiler",
			"language",
			"swift"
		],
		"languages": [
			"swift"
		]
	},
	"content": "readme.md teddy programming language compiler is teddy? made a small language called teddy. syntax is very similar swift, with more restrictions as make compiler more approachable. project is thus teddy compiler. is, s program written swift compiles teddy source code c.s currently half-baked, i hope continually refactor and add more documentation.check the demo here.why? built teddy an educational project learn compiler construction. project itself is small modular enough a beginner understand design, not so trivial it compiles simple expressions (2 + 2).teddy is a dependency-free project. means each step the compilation process (lexing, parsing, code-generation) is implemented swift, scratch.compilers overviewll assume re interested learning compilers ( thus languages) are built, that dont prior experience. s great! heres quick overview how compiler works. project is structured this as .a compiler is simply program accepts text a certain syntax (.e., programming languages syntax) translates into another language (.e., target language). s common target languages be assembly ( a similarly lower-level language), this is a requirement. teddy compiles down c simplicitys sake. are 5 major phases a compiler:lexical analysisbreaking source code into series tokens using regexes.parsingusing tokens built abstract syntax tree represent program.semantic analysisverifying program ast are correct (types match, variables are defined scope, etc.)code generationtranslating emitting each node the ast the target language.optimizationoptimizing generated code increase performance (ex. removing dead code, unrolling loops, strength reduction, etc.)project overviewteddy implements 3 stages: lexing, parsing, code generation. semantic analysis optimization be added later.each stage has own file:loader.swiftread text the teddy source code file.preprocessor.swiftstrips comments the source code.lexer.swiftbreaks the source code an array tokens using regular expressions returns .parser.swifttakes tokens creates abstract syntax tree. teddy parser is top-down recursive descent parser. parser is probably most intimidating part the project, is actually quite simple once have intuition how rdp works. more this later.codegen.swiftwalk through ast call emit() function each node, prints nodes equivalent c code.node.swiftdefines possible ast nodes (ex. integernode, assignmentexpression, printnode, etc.).getting startedopen the project navigate main.swift ( driver the compiler). may to replace path teddy.swift your own absolute path now. just hit run! will read the teddy code execute three compilation stages, logging progress along way., write own teddy code some simple expressions, step through execution the program. will help build intuition how compiler works.heres short list half-working features teddy:function declarations return simple types (void, int, string, bool, etc.)func main() -> int { return 0;}basic variable declarations// note required explicit type declarations semicolons differ swift.let message: string = \"hello, world!\";basic arithmetic expressionslet x: int = 2;let : int = (10 + 5) * x;function callsfunc squared(: int) -> int { return * 2;}// fix: will actually attempt print 25 a string (.e., `printf(%s)` instead `printf(%)`), which fail compile c.print(squared(5));// works, though!print(\"hello!\") conditionals should expect teddy not support something rather to expect does. all, s intended be educational compiler.faqwhy isnt more information the implementation itself? wanted open-source first its current, half-baked form, rather to never satisfied its documentation never actually ship .i wrote blog post lexing, i plan write accompanying posts parsing code generation soon. dont let hold back dipping toes the water! might write walkthrough post how add new feature the language this project.x is broken/ implemented.awesome! please file issue. if d to contribute fix yourself, feel free open a pull request! m more happy help teach how fix yourself, reach to :-)codegen.swift is super messy. know. ll refactor soon. is enum.swift? wanted implement swift- associated enums teddy. enum definitions declarations , but anything more yet. probably best stay away that now. is teddy?teddy is friends very handsome cat. heres photo.demo the following teddy code:func main() -> int { let message: string = \"hello, world!\"; (true) { print(message); } return 0;} compiler produce following output ( the lexing, parsing, code-generation stages):---------------------------------------------------------------------------------------------------- lexical analysis ----------------------------------------------------------------------------------------------------t_functiont_identifier(\"main\")t_parensopent_parenscloset_arrowt_integert_braceopent_lett_identifier(\"message\")t_colont_stringt_equalt_stringconstant(\"\\\"hello, world!\\\"\")t_semicolont_ift_parensopent_boolconstant(true)t_parenscloset_braceopent_printt_parensopent_identifier(\"message\")t_parenscloset_semicolont_bracecloset_returnt_integerconstant(0)t_semicolont_braceclose---------------------------------------------------------------------------------------------------- parsing & semantic analysis ---------------------------------------------------------------------------------------------------- 1 element compiler.functionnode prototype: compiler.prototypenode - name: \"main\" - arguments: 0 elements returntype: compiler.typenode - name: \"int\" body: 3 elements compiler.assignexpression variable: compiler.variablenode - mutability: compiler.mutability.immutable type: compiler.typenode - name: \"string\" - identifier: \"message\" value: compiler.stringnode - value: \"\\\"hello, world!\\\"\" compiler.ifstatementnode conditional: compiler.boolnode - value: true body: 1 element compiler.printnode printexpressions: 1 element compiler.fieldaccessnode - identifier: \"message\" compiler.returnnode returnexpression: compiler.integernode - value: 0---------------------------------------------------------------------------------------------------- code generation (target: c) ----------------------------------------------------------------------------------------------------/*---------------------------------------------------------------------------------------------------- compiled the teddy compiler. written janum trivedi. ----------------------------------------------------------------------------------------------------*/#include <stdio.h>int main() {char* message = \"hello, world!\"; (1) { printf(\"%s\", message); }return 0;}"
}