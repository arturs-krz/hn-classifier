{
	"_id": "14462574",
	"site": "https://github.com/nicolasdao/graphql-s2s",
	"title": "Hacking GraphQL schema: Adding type inheritance, generic types and custom metadata",
	"author": "mortimerwax",
	"date": "2017-06-13T13:55:02.694Z",
	"tags": {
		"categories": [
			"opensource",
			"graphql",
			"graphql-schema",
			"inheritance-styles",
			"generic-types",
			"parser",
			"metadata"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md graghql schema-2-schema transpiler installnpm install 'graphql-s2s' --saveusageconst { transpileschema } = require('graphql-s2s');const { makeexecutableschema } = require('graphql-tools');const schema = `type node {id: id!}type person inherits node {firstname: stringlastname: string}type student inherits person {nickname: string}type query { students: [student]}`const resolver = { query: { students(root, args, context) { // replace dummy code your own logic extract students. return [{ id: 1, firstname: \"carry\", lastname: \"connor\", nickname: \"cannie\" }]; } } };const executableschema = makeexecutableschema({ typedefs: [transpileschema(schema)], resolvers: resolver}); it doesgraphql s2s enriches standard graphql schema string used both graphql.js the apollo server. enriched schema supports:type inheritanceconst schema = `type node {id: id!}# inheriting the 'node' typetype person inherits node {firstname: stringlastname: string}# inheriting the 'person' typetype student inherits person {nickname: string}`generic typesconst schema = `# defining generic typetype paged<t> {data: [t]cursor: id}type question {name: string!text: string!}# using generic typetype student {name: stringquestions: paged<question>}# using generic typetype teacher {name: stringstudents: paged<student>}`metadata decorationconst schema = `# defining custom 'node' metadata attribute@nodetype node {id: id!}type student inherits node {name: string# defining another custom 'edge' metadata, supporting generic type@edge( other metadata using whatever syntax want)questions: [string]}` enriched schema provides richer more compact notation. transpiler converts enriched schema the standard expected graphql.js (using buildschema method) well the apollo server.metadata be added decorate schema types properties. add whatever want long it starts @ and start hacking schema. original intent that feature was decoration schema metadata @node @edge we coould add metadata the nature the relations between types.exampleswarning: following examples be based 'graphql-tools' the apollo team, the string schema also used the 'buildschema' method graphql.jstype inheritancenote: examples below use 'type', it also on 'input'before graphql-s2sconst schema = `type teacher {id: id!creationdate: stringfirstname: string!middlename: stringlastname: string!age: int!gender: string title: string!}type student {id: id!creationdate: stringfirstname: string!middlename: stringlastname: string!age: int!gender: string nickname: string!}` graphql-s2sconst schema = `type node {id: id!creationdate: string}type person inherits node {firstname: string!middlename: stringlastname: string!age: int!gender: string }type teacher inherits person {title: string!}type student inherits person {nickname: string!}`full code exampleconst { transpileschema } = require('graphql-s2s');const { makeexecutableschema } = require('graphql-tools');const { students, teachers } = require('./dummydata.json');const schema = `type node {id: id!creationdate: string}type person inherits node {firstname: string!middlename: stringlastname: string!age: int!gender: string }type teacher inherits person {title: string!}type student inherits person {nickname: string!questions: [question]}type question inherits node {name: string!text: string!}type query { # ### all users # students: [student] # ### all teachers # teachers: [teacher]}`const resolver = { query: { students(root, args, context) { return promise.resolve(students); }, teachers(root, args, context) { return promise.resolve(teachers); } } };const executableschema = makeexecutableschema({ typedefs: [transpileschema(schema)], resolvers: resolver});generic typesnote: examples below use 'type', it also on 'input'before graphql-s2sconst schema = `type teacher {id: id!creationdate: stringfirstname: string!middlename: stringlastname: string!age: int!gender: string title: string!}type student {id: id!creationdate: stringfirstname: string!middlename: stringlastname: string!age: int!gender: string nickname: string!questions: questions}type question {id: id!creationdate: stringname: string!text: string!}type teachers {data: [teacher]cursor: id}type students {data: [student]cursor: id}type questions {data: [question]cursor: id}type query { # ### all users # students: students # ### all teachers # teachers: teachers}` graphql-s2sconst schema = `type paged<t> {data: [t]cursor: id}type node {id: id!creationdate: string}type person inherits node {firstname: string!middlename: stringlastname: string!age: int!gender: string }type teacher inherits person {title: string!}type student inherits person {nickname: string!questions: paged<question>}type question inherits node {name: string!text: string!}type query { # ### all users # students: paged<student> # ### all teachers # teachers: paged<teacher>}` is very similar c# java generic classes. the transpiler do is simply recreate 3 types ( for paged<question>, paged<student> paged<teacher>). we the paged<question> example, transpiled type be:type pagedquestion {data: [question]cursor: id}full code exampleconst { transpileschema } = require('graphql-s2s');const { makeexecutableschema } = require('graphql-tools');const { students, teachers } = require('./dummydata.json');const schema = `type paged<t> {data: [t]cursor: id}type node {id: id!creationdate: string}type person inherits node {firstname: string!middlename: stringlastname: string!age: int!gender: string }type teacher inherits person {title: string!}type student inherits person {nickname: string!questions: paged<question>}type question inherits node {name: string!text: string!}type query { # ### all users # students: paged<student> # ### all teachers # teachers: paged<teacher>}`const resolver = { query: { students(root, args, context) { return promise.resolve({ data: students.map(s => ({ __proto__:s, questions: { data: s.questions, cursor: null }})), cursor: null }); }, teachers(root, args, context) { return promise.resolve({ data: teachers, cursor: null }); } } };const executableschema = makeexecutableschema({ typedefs: [transpileschema(schema)], resolvers: resolver});metadata decorationdefine own custom metadata decorate graphql schema new types data. let's imagine want explicitely add metadata the type relations between nodes, could write something this:const { getschemaast } = require('graphql-s2s');const schema = `@nodetype user {@edge('<-[createdby]-')posts: [post]}`const schemaobjects = getschemaast(schema);// -> schemaobjects//// [ { type: 'type',// name: 'user',// metadata:// { name: 'node',// body: '',// schematype: 'type',// schemaname: 'user',// parent: null },// generictype: null,// blockprops: [ { comments: '',// details: {//name: 'posts',// metadata: { //name: 'edge',//body: '(\\'<-[createdby]-\\')',//schematype: 'property',//schemaname: 'posts: [post]',//parent: { //type: 'type',//name: 'user',//metadata: { type: 'type', name: 'node' } } },// params: null,// result: { originname: '[post]', isgen: false, name: '[post]' } },// value: 'posts: [post]' } ],// inherits: null,// implements: null,// comments: undefined } ] is we re to are neap, australian technology consultancy powering startup ecosystem sydney. simply love building tech also meeting people, don't hesitate connect us https://neap.co."
}