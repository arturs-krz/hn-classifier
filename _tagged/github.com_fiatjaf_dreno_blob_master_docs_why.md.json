{
	"_id": "14481406",
	"site": "https://github.com/fiatjaf/dreno/blob/master/docs/why.md",
	"title": " Dreno, a React framework that inherits the best from Cycle and MobX",
	"author": "fiatjaf",
	"date": "2017-06-13T13:04:45.559Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": []
	},
	"content": "rationale behind dreno, an introduction, a long argument convince to itcycle.js does cycle.js ? there are multiple drivers can ( must) , everything has side-effects is a driver the drivers pass data the main app function, is pure. function returns data the drivers. driver renders dom emits dom events the main function is normally most important driver any cycle application. cycle, dealing data multiple sources ( the diagram didn't draw other sources, http responses browser api responses go through red arrow) is easy straightforward. everything is value every value be processed any you inside pure dataflow app function, the results that function are everything is needed render ui, any side-effect. reactive streams approach is solid flexible. can any kind data manipulation a clean with . the data flows a cycle app is beautiful. xstream makes even better, it is small easy understand, still very powerful.mobx, how does mobx ? basically 's lot magic fancy words, essentially, you're using with react, goes this: are react components are rendered the dom, each component is set mobx track of state's attributes access. dom events from other external event ( http responses) trigger actions update state, mobx does internal magic call .forceupdate the components were tracking of attributes changed. the computed stuff other runtime triggers when are sugar some may find useful, they're the core feature. core feature is having components update automatically. , more that, having the components were get values the state actually update.problems mobx cycle.js problem mobx is it get pretty messy. can set state directly your components event handlers, you define action the state itself then the event handlers call those actions. the approach 'll end with confusion state setters everywhere you 't reasonably visualize app; the second approach 'll end with lot predefined actions stupid small changes, everything look a bloated object-oriented architecture. real-world small apps 'll maybe end mixing two approaches, is worse. to mention you create anonymous actions the fly, to their transaction power.modifying state, the side, is core feature cycle. notice there's even state the cycle diagram. 's your state cycle is all streams their output values ( can surely combine the streams a single stream call state$, that's necessary). cycle.js don't need mobx's compute, can .map() streams; don't need reaction, can pass stream values a driver.however, notice the dom part is small the cycle diagram. 's in cycle dom is a driver. cycle puts much emphasis the pure logic part it kinda forgets the complexities dom rendering. every the \"state\" cycle changes dom must updated the driver -- if optimization the dom rendering be done, is somewhat alien the cycle app. crucial optimization is using virtual dom patches instead writing .innerhtml ('s assumed default this post-react world live ), other optimizations not rendering part the virtual dom tree some part the state not changed is left the driver the app function passing correct values the driver.mobx has better solution that. having tree nested components triggering automatic updates of those leafs actually to change, i said before, is strongest feature almost makes thunks usage shouldcomponentupdate unnecessary.drenodreno takes flexibility transparency the stream-based dataflow cycle.js, combines with ease view composing standard react powered mobx- state plus efficient nested component updates observer/observable pattern mobx introduced gives something this: a dreno app can put dataflow logic anywhere. like imagine floating around view the state. use select function ( @cycle/dom's select) get events streams dom events, you create own event streams other external interfaces, you map values using xstream reactive streams until pass final streams ( which want output) observable(), gives a state whose properties are updated every their respective streams emit new value. can access properties state if were normal object properties inside react components, every a component accesses property, dreno know must trigger forceupdate that component next this property changes. since is handled automatically the library, don't to worry it while writing pure dataflow logic.'s much more that. downsides lose fractal structure: apps are composable, cycle elm architecture apps are. can't embed app built dreno inside another app built dreno. are cases which want do , but are many cases you don't. can still embed external react components inside view, all own peculiar intra-react state management, 's the same thing, still get reuse those small components react wrote reusability mind, 's .you lose cycle pureness, since you a state effectively caches final results your streams, you have interface the external world without help cycle drivers ( you surely implement -- or reuse cycle drivers -- here)."
}