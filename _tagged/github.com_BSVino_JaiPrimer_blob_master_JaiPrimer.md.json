{
	"_id": "14409808",
	"site": "https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md",
	"title": "Jai Primer",
	"author": "hellofunk",
	"date": "2017-06-13T13:56:42.034Z",
	"tags": {
		"categories": [
			"opensource",
			"primer"
		],
		"languages": []
	},
	"content": "introductionjai is high-level programming language developed jonathan blow, creator indie games braid , most recently, witness. is imperative static/strongly typed c-style language, with variety modern language features c lacks. blow began on jai late september 2014. is still development as yet is unavailable the general public. blow developed with eye towards video games, in fact s general purpose programming language could used any task.disclaimer: have association jon blow. of writing are public compilers jai, all information this text is collated jon blows youtube videos. therefore nothing this post is official. may information more to date what is available this page. said, believe everything this post be to date of writing. ( you are jon blow want to correct anything this post, would happy ).everything this document, unless otherwise noted, is implemented currently working blows private prototype, as is yet released, everything is subject change.brief description short, jai be described a modern replacement c. of coolest features:arbitrary compile- code execution function the program be made run compile with #runsyntax-facilitated code refactoring language syntax facilitates code reuse making easy move code local block local function global functionintegrated build process build process parameters are specified the source code itself, consistencydata-oriented structures automatic conversion between structure arrays array structures, avoids classes inheritancereflection run- type information static type information every structure available runtime new approach polymorphic procedures polymorphism the function level, programmer control special procedureslow-level memory management tools better control how libraries allocate memory, automatic ownership management, garbage collectionexplicit control optimization performance characteristics explicit control things inlining, bounds checking, initialization philosophy jai joy programming some point programming many years, line between exciting programming adventure please another code refactoring start disappear. having update function declaration the header you change signature gets old fast. c was originally written 1973, was good reason all header stuff, today isnt. quality life improvements afforded the language have quantifiable benefits the productivity the programmer using language. ( you arent convinced that, try programming anything brainfuck.) compiling should fast not instantaneous, refactoring code should require minimum changes, error messages should helpful pleasant. blow believes an improvement the tools programmers can produce more a 20% increase productivity, this was primary motivation creating new language.machines fill memoryvideo games are, blow puts , machines fill memory. majority the , game programmers are thinking how fill memory huge reams data ways allow data be efficiently accessed processed. hundreds megabytes memory must moved the hard disk main memory, from into video card the processor cache be processed returned to main memory. video game players dont to wait, this must done fast is allowable laws our universe. primary purpose a programming language is allow specification algorithms manage data. language features garbage collection templated data streams dynamic string classes may help programmer write code faster, they dont help programmer write faster code.friction reductionanother major design goal jai is reduce blow calls friction programming. friction happens the syntax a language interferes the programmers workflow. java requires all objects classes, forcing programmers put global variables need global classes, s friction. haskell requires all procedures functions have side effects, s friction. c++s lambda function syntax is different its class method syntax is different its global function syntax, s friction. java, haskell c++ are examples what blow calls big agenda languages, where idealism ( in c++s case, lack a consistent vision) the language gets the programmers . blow has low tolerance friction his language, especially the friction is unnecessary.design good programmersblow wants language is designed good programmers, against bad programmers. languages java were marketed idiot-proof, that s much more difficult programmers write code can hurt . the jai philosophy is, you dont idiots writing bad code your project, dont hire idiots. jai allows programmers direct access the sharp tools can the job done. game programmers are afraid pointers manual memory management. programmers make mistakes cause crashes, perhaps serious ones, blow argues the increase productivity reduction friction memory-safe mechanisms are absent more make for time lost tracking down errors, especially good programmers tend produce relatively few errors.performance data-oriented programming as programmer care user experience ( you should), you should care the performance your program. should reason your codes behavior the range machines youre shipping , and design data control structures use hardwares capability efficiently. (here m describing mike actons data-oriented design methodology.) programmers care the performance their software their target hardware are inhibited programming languages sit between and hardware. mechanisms virtual machines automatic memory management interfere the programmers ability reason the programs performance the target hardware. abstractions raii, constructors destructors, polymorphism, exceptions were invented the intention solving problems game programmers dont , and the result interfering the solutions problems game programmers have. jai jettisons abstractions that programmers think more their actual problems data their algorithms.jai language featurestypes declarations syntax name: type = value; specifies a variable named name is the type type is receive value value. was proposed sean barrett. examples:counter: int = 0;name: string = \"jon\";average: float = 0.5 * (x+y); the type is omitted the compiler infers based the value:counter := 0; // intname := \"jon\"; // stringaverage := 0.5 * (x+y); // float the value is omitted you a declaration without initialization.counter: int;name: string;average: float; of is probably backwards what re used , but learning curve is shallow you used it quickly. function declarations like :// a function accepts 3 floats parameters returns floatsum := (x: float, y: float, z: float) -> float { return x + y + z;};print(\"sum: %\", sum(1, 2, 3)); structure declarations this:vector3 := struct { x: float; y: float; z: float;};arrays be created this:: [50] int; // array 50 integersb: [..] int; // dynamic array integersarrays not automatically cast pointers in c. rather, are wide pointers contain array size information. functions take array types query the size the array.print_int_array :: (: [] int) { n := .count; i : 0..n-1 { print(\"array[%] = %\", , a[]); }}retaining array size information help developers avoid pattern passing array lengths additional parameters assist automatic bounds checking ( walter bright cs biggest mistake).arbitrary compile- code executionsuppose want write function c converts linear color value srgb. involves pow() function, is the expensive side. can avoid pow() doing calculation ourselves instead distributing results part our program. we write table values return those.#define srgb_table_size 256float srgb_table[srgb_table_size] = { /* ... values here ... */ }float linear_to_srgb(float f){ // find index our table this srgb value, // assuming f is the range [0, 1] int table_index = (int)(f * srgb_table_size); return srgb_table[table_index];}(note: above is bad code, used example. better code, try stb_image_resizes srgb functions.) far good, except will get values the srgb_table? can write another small program outputs values. example:float real_linear_to_srgb(float f){ (f <= 0.0031308f) return f * 12.92f; else return 1.055f * (float)pow(f, 1 / 2.4f) - 0.055f;}#define srgb_table_size 256int main(int c, char* s) { printf(\"float srgb_table[srgb_table_size] = { \"); (int = 0; < srgb_table_size; ++) printf(\"%f, \", real_linear_to_srgb((float)/srgb_table_size)); printf(\"}\"); return 0;} can compile small program, will output table srgb values, then can copy output our actual program. is big bucket problems it. example, notice srgb_table_size is defined twice, once the actual program once the helper program. we have maintain separate source codes. can unwieldy large programs. jai, same task looks this:generate_linear_srgb := () -> [] float { srgb_table: float[srgb_table_size]; srgb_table { << = real_linear_to_srgb(cast(float)it_index / srgb_table_size) } return srgb_table;}srgb_table: [] float = #run generate_linear_srgb(); // #run invokes compile executionreal_linear_to_srgb := (f: float) -> float { table_index := cast(int)(f * srgb_table_size); return srgb_table[table_index];} #run directive instructs jai run function generate_linear_srgb() compile . jais compile function execution runs command compile and returns table values, is compiled directly the binary srgb_table. the program is run, generate_linear_srgb() function longer exists. the table generated exists, is used linear_to_srgb(). compile- function execution has very few limitations; fact, can run arbitrary code your code base part the compiler. blows demonstration shows to run entire game part the compiler, bake data the game the program binary. ( hope #run invaders(); is shipped the language.) compiler builds compile- executed functions a special bytecode language runs in interpreter, the results are funneled into source code. compiler continues normal.here are examples things a compile- function do:compile- assertsrun test cases code style checksdynamically generate code insert to compiledinsert build datadownload opengl spec build most recent gl.h header filecontact build server retrieve/send build datatalk your mars probe mars wait the packets come and a photo what mars looks code refactoring code begins life some kind code block this before moving to used more general cases. jai has special syntaxes can assist programmer moving code specific cases into general cases, facilitate code reuse. an example, lets youre writing code this:draw_particles := () { view_left: vector3 = get_view_left(); view_up: vector3 = get_view_up(); particles { // inside loops \"it\" object is iterator the current object. particle_left := view_left * .particle_size; particle_up := view_up * .particle_size; // m is global object helps build meshes send the graphics api m.position3fv(.origin - particle_left - particle_up); m.position3fv(.origin + particle_left - particle_up); m.position3fv(.origin + particle_left + particle_up); m.position3fv(.origin - particle_left + particle_up); }} mesh generation calls are actually special case some general quad rendering, they be factored into another function they be used other places. jai makes refactoring very straightforward. first step is enclose code a scope a special capture syntax.particle_left := view_left * .particle_size;particle_up := view_up * .particle_size;origin := .origin;[m, origin, particle_left, particle_up] { m.position3fv(origin - particle_left - particle_up); m.position3fv(origin + particle_left - particle_up); m.position3fv(origin + particle_left + particle_up); m.position3fv(origin - particle_left + particle_up);}(disclaimer: step hasnt been implemented blow yet. s of planned features.) [m, origin, particle_left, particle_up] notation is capture prevents object in capture being accessed inside inner scope the bracket. notice we had change .origin origin add origin the capture list is captured is unavailable inside inner scope.captures help refactoring code were seeing here they also help other ways. example, programmers are moving code being singlethreaded multithreaded, captures enforce only thread-local data is accessed. captures are insurance policy the code inside capture reads writes state specified the capture. weve identified of parts our code depend external things, weve improved codes hygiene made easy pull code into own function. we to continue that can the quad drawing code other places. we create function of block capture:particle_left := view_left * .particle_size;particle_up := view_up * .particle_size;origin := .origin;() [m, origin, particle_left, particle_up] { m.position3fv(origin - particle_left - particle_up); m.position3fv(origin + particle_left - particle_up); m.position3fv(origin + particle_left + particle_up); m.position3fv(origin - particle_left + particle_up);} (); // call functionnotice the change needed make was add function syntax (). capture remained intact. we went a blocked capture a function very little effort. if like can move vectors be function parameters:(origin: vector3, left: vector3, : vector3) [m] { m.position3fv(origin - left - ); m.position3fv(origin + left - ); m.position3fv(origin + left + ); m.position3fv(origin - left + );}with parameter names re able change names the variables inside functions scope match new function. we use function draw type quad, just particles. capture retains m it is global object doesnt need be passed a parameter. now have anonymous, locally scoped function can used our draw code:draw_particles := () { view_left: vector3 = get_view_left(); view_up: vector3 = get_view_up(); particles { particle_left := view_left * .particle_size; particle_up := view_up * .particle_size; (origin: vector3, left: vector3, : vector3) [m] { m.position3fv(origin - left - ); m.position3fv(origin + left - ); m.position3fv(origin + left + ); m.position3fv(origin - left + ); } (origin, particle_left, particle_up); // call function the specified parameters }}anonymous functions are useful passing arguments other functions, this syntax makes easy create manipulate. next step is give function name:draw_quad := (origin: vector3, left: vector3, : vector3) [m] { m.position3fv(origin - left - ); m.position3fv(origin + left - ); m.position3fv(origin + left + ); m.position3fv(origin - left + );}draw_quad(origin, particle_left, particle_up); we call multiple times the local scope, we . but want access quad drawing function the global scope. moving function of local scope requires zero changes the functions code:draw_quad := (origin: vector3, left: vector3, : vector3) [m] { m.position3fv(origin - left - ); m.position3fv(origin + left - ); m.position3fv(origin + left + ); m.position3fv(origin - left + );};draw_particles := () { view_left: vector3 = get_view_left(); view_up: vector3 = get_view_up(); particles { particle_left:= view_left * .particle_size; particle_up:= view_up * .particle_size; draw_quad(particle_left, particle_up, origin); }} strength jais function syntax is it doesnt change whether function is anonymous function, local function (.e. lives inside scope another function) member function a class a global function. is contrast in c++, where local function is called lambda, has completely different syntax a member function, must a class name :: etc, is slightly different syntax a global function has class name ::. the result is as code matures moves a local context a global context, work refactoring be done minimal edits.here is jais code maturation cycle full: { ... } // anonymous code block [capture] { ... } // captured code block (: int) -> float [capture] { ... } // anonymous functionf := (: int) -> float [capture] { ... } // named local functionf := (: int) -> float [capture] { ... } // named global functionintegrated build process information building program is contained within source code the program. thus is need a command project files build jai program. a simple example:build :: () { build_options.executable_name = \"my_program\"; print(\"building program '%'\", build_options.executable_name); build_options.optimization_level = optimization_level.debug; build_options.emit_line_directives = false; update_build_options(); // jai automatically build files included the #load directive, other files also manually added add_build_file(\"misc.jai\"); add_build_file(\"checks.jai\");}#run build(); the program is built, #run directive runs build() compile-. then build() establishes of build options this project. external build tools are required, build scripting is done within jai, in same environment the rest the code.data-oriented structuressoa aosmodern processors memory models are much faster spatial locality is adhered . this means grouping together data is modified the same is advantageous performance. changing struct an array structures (aos) style:struct entity { vector3 position; quaternion orientation; // ... many members here};entity all_entities[1024]; // array structures (int k = 0; k < 1024; k++) update_position(&all_entities[k].position); (int k = 0; k < 1024; k++) update_orientation(&all_entities[k].orientation); a structure arrays (soa) style:struct entity { vector3 positions[1024]; quaternion orientations[1024]; // ... many members here};entity all_entities; // structure arrays (int k = 0; k < 1024; k++) update_position(&all_entities.positions[k]); (int k = 0; k < 1024; k++) update_orientation(&all_entities.orientations[k]); improve performance great deal of fewer cache misses.however, programs larger, becomes much more difficult reorganize data. testing whether single, simple change has effect performance take developer long , because once data structures must change, of code acts that data structure breaks. jai provides mechanisms automatically transitioning between soa aos without breaking supporting code. example:vector3 :: struct { x: float = 1; y: float = 4; z: float = 9;}v1 : [4] vector3; // memory contain: 1 4 9 1 4 9 1 4 9 1 4 9vector3soa :: struct soa { x: float = 1; y: float = 4; z: float = 9;}v2 : [4] vector3soa; // memory contain: 1 1 1 1 4 4 4 4 9 9 9 9getting to previous example, jai:entity :: struct soa { position : vector3; orientation : quaternion // .. many members here}all_entities : [4] entity; k : 0..all_entities.count-1 update_position(&all_entities[k].position); k : 0..all_entities.count-1 update_orientation(&all_entities[k].orientation); the thing needs be changed convert between soa aos is insert remove soa keyword the struct definition site, jai work behind scenes make everything else as expected.reflection run- type informationjai stores table all type information the data segment each compiled program. can examined this: _type_table { // is iterator, is type being examined. it_index is iteration index, is integer print(\"%:\", it_index); print(\" name: %\", .name); print(\" type: %\", .type); // type is enum, integer, float, bool, struct, etc}full introspection data is available all structs, functions, enums. example, procedure may something this:print(\"% (\", info_procedure.name); info_procedure.argument_types { print_type(); if it_index != info_procedure.argument_types.count-1 print(\", \");}print(\") ->\");print_type(info_procedure.return_type); preceding code print something get_name(id : uint32) -> string. enum be examined this:hello :: enum u16 { , second, third = 80, fourth,} hello.names { print(\"name: % value: %\", hello.names[it_index], hello.values[it_index]);}reflection data such this be used write serialization procedures, commonly used e.g. network replication entities save game data. current c/c++ methods this involve heavy of operator overloading preprocessor directives.polymorphic proceduresfunction polymorphismjais primary polymorphism mechanism is the function level, is best described an example.sum(: $t, b: t) -> t { return + b;}f1: float = 1;f2: float = 2;f3 := sum(f1, f2);i1: int = 1;i2: int = 2;i3 := sum(i1, i2);x := sum(f1, i1);print(\"% % %\", f3, i3, x); // output is \"3.000000 3 2.000000\" sum() is called, type is determined the t is preceded the $ symbol. this case, $ precedes a variable, so type t is determined the parameter. , the call sum() is float + float, the second call is int + int. the third call, since first parameter is float, both parameters the return value become float. second parameter is converted int float, the variable x is deduced be float well. any typejai has type called , which other type be implicitly casted . example:print_any(: any) { a.type.type == type_info_tag.float print(\" is float\"); else a.type.type == type_info_tag.int print(\" is int\");}baking section is written yet! sorry. ( #bake directive emits function a combination arguments baked . for example, #bake sum(, 1) becomes equivalent a += 1.)memory managementjai does and never feature garbage collection any kind automatic memory management.struct pointer ownershipmarking pointer member a struct ! indicates the object pointed is owned the struct should deleted the struct is deallocated. example:node := struct { owned_a : node *! = null; owned_b : node *! = null;};example: node = node;example.owned_a = node;example.owned_b = node;delete example; // owned_a owned_b are deleted.here, owned_a owned_b are marked being owned node, will automatically deleted the node is deleted. c++ is accomplished through unique_ptr<t>, blow thinks this is wrong to it the template approach masks true type the object. unique_ptr<node> is longer nodes unique_ptr masquerading a node. s preferable retain type node*, retain properties node*-ness go along it, we dont really actually care unique_ptr its own sake.library allocators section is written yet! sorry. (jai provides mechanisms managing allocations an imported library without requiring from library writers.)initializationmember variables a class are automatically initialized.vector3 :: struct { x: float; y: float; z: float;}v : vector3;print(\"% % %\", v.x, v.y, v.z); // always prints \"0 0 0\" can replace with default initializations:vector3 :: struct { x: float = 1; y: float = 4; z: float = 9;}v : vector3;print(\"% % %\", v.x, v.y, v.z); // always prints \"1 4 9\"va : [100] vector3; // array 100 vector3print(\"% % %\", va[50].x, va[50].y, va[50].z); // always prints \"1 4 9\" you block default initialization:vector3 :: struct { x: float = ---; y: float = ---; z: float = ---;}v : vector3;print(\"% % %\", v.x, v.y, v.z); // undefined behavior, print anything can block default initialization the variable declaration site:vector3 :: struct { x: float = 1; y: float = 4; z: float = 9;}v : vector3 = ---;print(\"% % %\", v.x, v.y, v.z); // undefined behavior, print anythingva : [100] vector3 = ---;print(\"% % %\", va[50].x, va[50].y, va[50].z); // undefined behavior, print anything explicitly uninitializing variables rather explicitly initializing variables, jai hopes reduce cognitive load while retaining potential optimization.inliningtest_a :: () { /* ... */ }test_b :: () inline { /* ... */ }test_c :: () no_inline { /* ... */ }test_a(); // compiler decides whether inline test_b(); // always inlined due \"inline\" abovetest_c(); // never inlined due \"no_inline\" aboveinline test_a(); // always inlinedinline test_b(); // always inlinedinline test_c(); // always inlinedno_inline test_a(); // never inlinedno_inline test_b(); // never inlinedno_inline test_c(); // never inlinedadditionally, exist directives always never inline certain procedures, make easier inline avoid inline conditionally depending the platform.test_d :: () { /* ... */ }test_e :: () { /* ... */ }#inline test_d // directive always inline test_d#no_inline test_e // directive never inline test_e cool stuffthings c/c++ should had long ago:multi-line block commentsnested block commentsspecific data types 8, 16, 32 bit integers implicit type conversions header files. operator both struct membership pointer dereference access more -> defer statement, similar that goplannedheres short list features blow has expressed interest for jai.automatic build management program specifies to build capturesllvm integrationautomatic versioning ( below) better concurrency modelnamed argument passing permissive license plannedjai not :smart pointersgarbage collectionautomatic memory management any kindtemplates template metaprogrammingraiiconstructors destructorssubtype polymorphismexceptionsreferences virtual machine ( least, usually below) preprocessor ( least, one resembling cs below)header files it sounds odd you jai is modern high-level language does have of above features, consider jai is trying be high-level java c#. is better described trying be better c. wants allow programmers get low-level they desire. features garbage collection exceptions stand obstacles low-level programming.further notesadoption compelling argument not writing entirely language games is the momentum volume c c++ code current game engines is too high, switching a language is too much for amount benefit. blow argues engines periodically rewrite codebase anyway, since jai c are closely related, c code jai code live side side while rewrites would normally happen anyway place. since c jai interoperate seamlessly, jai code be built top existing c libraries. fact, blow uses c interfaces the opengl stb_image libraries his jai test code. , replacing c c++ be done no added cost development. meanwhile, benefits replacing c a language has of cs benefits fewer drawbacks means programmers be happier, thus more productive.why use c++/rust//d/swift/haskell/lisp/etc?those are strong languages, none them contain right combination features ( lack features) game programmers need. automatic memory management is non-starter game programmers need direct control their memory layouts. interpreted language be too slow. functional- languages are pointlessly restricting. object-oriented- languages are overly complex. blow preferred develop new language the qualities game programmers need, without qualities dont.proposed features are few features blow has proposed not yet implemented. my knowledge re yet the language. syntax is preliminary likely change. first is joint allocations:mesh :: struct { name: string; filename: string; flags: uint; positions: [] vector3; indices: [] int; @joint positions uvs: [] vector2; @joint positions};example_mesh: mesh;example_mesh.positions.reserve(positions: num_positions, indices: num_indices, uvs: num_uvs);here want avoid multiple memory allocations, we the compiler a joint allocation between positions, indices, uvs, divide memory accordingly. currently is done manually c, is prone errors.next is optional types:do_something := (: entity?) { .x = 0; // error! (a) { .x = 0; // ok }}; idea here is prevent of most common causes crashes, null pointer dereferencing. ? in above code means we dont whether not pointer is null. trying dereference variable without testing see it is null result a compile error.lastly, automatic versioning:entity_substance :: struct { @version 37 flags: int; scale_color: vector4; @15 spike_flags: int; @[10, 36]};here blow is providing markup his data structures indicates the compiler version the struct each member was present . these versioning schemes be used part an automatic serialization/introspection interface, hes gone details that than the language should some capability introspection."
}