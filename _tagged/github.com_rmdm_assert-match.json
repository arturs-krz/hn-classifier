{
	"_id": "14203007",
	"site": "https://github.com/rmdm/assert-match",
	"title": " Assert-match: Node.js assert enhanced with matchers",
	"author": "rmdm",
	"date": "2017-06-13T13:33:07.108Z",
	"tags": {
		"categories": [
			"opensource",
			"assert",
			"matchers",
			"match",
			"assertions",
			"ismatch"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md assert-matchassert-match is enhancement the standard assert module matchers.short exampleimport assert 'assert-match'import { loose, arrayof, type } 'assert-match/matchers'// const { loose, arrayof, type } = assert.matchersconst actual = { str: 'abc', obj: { b: 1, c: 2 }, nums: [ 1, 2, 'x' ], }, expected = { str: 'abc', obj: loose({ b: 1 }), nums: arrayof(type('number')), }assert.deepequal(actual, expected)// assertionerror: { str: 'abc', obj: { b: 1 }, nums: [ 1, 2, 'x' ] } deepequal// { str: 'abc', obj: { b: 1 }, nums: [ 1, 2, { '[typeof]': 'number' } ] }// + expected - actual//// {// \"nums\": [// 1// 2// - \"x\"// + {// + \"[typeof]\": \"number\"// + }// ]installation npm install assert-matchusage assert-match all same places where would built- assert:const assert = require('assert-match')// ...assert.deepequal(actual, expected)assertionsassert-match enhances standard assert's deep-family assertions:assert.deepequal (actual, expected, [message])assert.deepstrictequal (actual, expected, [message])assert.notdeepequal (actual, expected, [message])assert.notdeepstrictequal (actual, expected, [message])assert-match allows to check actual value ( its property) against specific expected value standard deep assertions , butagainst matcher a combination them.without using matchers assertions behave exactly their standardcounterparts has been tested against same set tests the standard ones. assertions assert are exported assert-match notenhanced matchers support.matchers matcher is objects used check a value satisfies requirementsdefined the matcher.matchers be placed the top level expected value on of properties. awesome point matchers is ability combine ! it gives a to create powerful matching structures using small set matchers.matchers combinations them be reused recombined across multipleassertions. cases assertion errors matchers participate providing test runner error details.assert-match defines following matchers:strict (expected)loose (expected) (expected) (expected)every (expected) (expected)arrayof (expected)contains (expected)type (expected)primitive (expected)regex (expected)gt (expected)gte (expected)lt (expected)lte (expected)custom (expectedfn) all the following matchers descriptions actual refers actualvalue its property, corresponding the matcher expected, both passed an assertion.strict (expected)returns instance the root matchers class. other matchers inherit that class. checks whether values are equal depth. actual comparisonoperator (== ===) for primitives depends assertion which matcheris used ( example, == is used deepequal whereas === is used deepstrictequal). expected contains matcher somewhere it, check corresponding actual value is passed that matcher. applied another matcher produces equivalent , meaning forexample strict(amatcher(expected)) returns matcher equivalent amatcher(expected). actually, deepequal deepstrictequal assertionswrap expected argument strict matcher implicitly.assert.deepequal({ : 1, b: 2 }, strict({ : 1, b: 2 })) // passesassert.deepequal({ : 1, b: 2 }, strict({ : 1 })) // throwsassert.deepequal({ : 1 }, strict({ : 1, b: 2 })) // throwsloose (expected)similar strict matcher requires subset actual properties be equal depth those expected.assert.deepequal({ : 1, b: 2 }, loose({ : 1, b: 2 })) // passesassert.deepequal({ : 1, b: 2 }, loose({ : 1 })) // passesassert.deepequal({ : 1 }, loose({ : 1, b: 2 })) // throws (expected)matches anything. be used value existence a specific actualproperty does matter. is supposed be used context strictmatcher, context loose matcher makes little sense.assert.deepequal(undefined, ()) // passesassert.deepequal({ : 1, b: 2, c: 3 }, { : 1, b: 2, c: () }) // passesassert.deepequal({ : 1, b: 2, c: 3 }, { : 1, b: 5, c: () }) // throws (expected) implicitly wraps expected strict matcher, matches actual valueagainst and inverts result. notdeepequal notdeepstrictequalassertions wrap expected argument not matcher implicitly.assert.deepequal({ : 1, b: 2 }, ({ a: 1, b: 2 })) // throwsassert.deepequal({ : 1, b: 2 }, ({ a: 1 })) // passesassert.deepequal({ : 1 }, ({ a: 1, b: 2 })) // passesevery (expected)expected should an array. it is , than is treated one-elementarray. each element expected array is wrapped implicitly strictmatcher. every matcher checks whether actual value matches matchers expected.assert.deepequal({ : 1, b: 2 }, every([ loose({ : 1 }), loose({ b: 2 }) ])) // passesassert.deepequal({ : 1, b: 2 }, every([ loose({ : 1 }), loose({ c: 3 }) ])) // throwsassert.deepequal({ : 1, b: 2 }, every([ { c: 3 } ])) // throwsassert.deepequal({ : 1, b: 2 }, every(loose({ : 1 }))) // passes (expected)expected should an array. it is , than is treated one-elementarray. each element expected array is wrapped implicitly strictmatcher. matcher checks whether actual value matches least matcher expected.assert.deepequal({ : 1, b: 2 }, ([ loose({ : 1 }), loose({ b: 2 }) ])) // passesassert.deepequal({ : 1, b: 2 }, ([ loose({ : 1 }), loose({ c: 3 }) ])) // passesassert.deepequal({ : 1, b: 2 }, ([ { c: 3 } ])) // throwsassert.deepequal({ : 1, b: 2 }, (loose({ : 1 }))) // passesarrayof (expected)expects actual value be non-empty array, check fails it is .implicitly wraps expected strict matcher. checks all elements the array match expected.assert.deepequal([ 1, 1, 1 ], arrayof(1)) // passesassert.deepequal([ 1, 1, '' ], arrayof(1)) // throwsassert.deepequal(1, arrayof(1)) // throwscontains (expected1 [, expected2, ...])expects actual value be non-empty array, check fails it is .accepts list expected. checks each element the expectedlist matches least element the actual array.assert.deepequal([ 1, 1, 1 ], contains(1)) // passesassert.deepequal([ 1, '', 'a' ], contains(1)) // passesassert.deepequal([ '', 'a', '' ], contains(1)) // throwsassert.deepequal(1, contains(1)) // throwsassert.deepequal([ 1, 2, 3 ], contains(1, 2)) // passesassert.deepequal([ 1, 2, 3 ], contains(1, 10)) // throwstype (expected) expected is string actual is checked be primitive thattype. expected is constructor actual is checked be instance that type.assert.deepequal(5, type('number')) // passesassert.deepequal([ 1, 2, 3 ], type(array)) // passesassert.deepequal(5, type('string')) // throwsassert.deepequal({ : 1 }, type({ : 1 })) // throwsprimitive (expected) expected is matcher actual is converted primitive matched against expected. otherwise, actual expected bothconverted primitive compared (actual operator == === depends assertion used).assert.deepequal({}, primitive('[object object]')) // passesassert.deepequal( string('abc'), primitive('abc')) // passesassert.deepequal({ tostring: () => 'abc' }, primitive('abc')) // passesassert.deepequal(1, primitive(1)) // passesassert.deepequal(10, primitive(1)) // throwsassert.deepequal(1, primitive('1')) // passesassert.deepstrictequal(1, primitive('1')) // throwsassert.deepequal({}, primitive(regex('obj'))) // passesassert.deepequal({}, primitive(regex('abc'))) // throwsregex (expected)expected is converted a regexp actual is tested against .assert.deepequal('abc', regex('^')) // passesassert.deepequal('[object object]', regex({})) // passesassert.deepequal('123', regex(/^\\d+$/)) // passesassert.deepequal('123', regex('^\\d+$')) // throwsgt (expected)checks actual is greater expected.assert.deepequal('b', gt('')) // passesassert.deepequal('', gt('b')) // throwsassert.deepequal(1, gt(0)) // passesassert.deepequal(0, gt(0)) // throwsassert.deepequal([ 1, 2, 3 ], loose({ length: gt(1) })) // passesassert.deepequal([ 1 ], loose({ length: gt(1) })) // throwsgte (expected)checks actual is greater or equal expected.assert.deepequal('b', gte('')) // passesassert.deepequal('', gte('b')) // throwsassert.deepequal(1, gte(0)) // passesassert.deepequal(0, gte(0)) // passesassert.deepequal([ 1, 2, 3 ], loose({ length: gte(1) })) // passesassert.deepequal([ 1 ], loose({ length: gte(1) })) // passeslt (expected)checks actual is less expected.assert.deepequal('', lt('b')) // passesassert.deepequal('b', lt('')) // throwsassert.deepequal(0, lt(1)) // passesassert.deepequal(0, lt(0)) // throwsassert.deepequal([ 1, 2, 3 ], loose({ length: lt(1) })) // throwsassert.deepequal([ 1 ], loose({ length: lt(1) })) // throwslte (expected)checks actual is less or equal expected.assert.deepequal('', lte('b')) // passesassert.deepequal('b', lte('')) // throwsassert.deepequal(0, lte(1)) // passesassert.deepequal(0, lte(0)) // passesassert.deepequal([ 1, 2, 3 ], loose({ length: lte(1) })) // throwsassert.deepequal([ 1 ], loose({ length: lte(1) })) // passescustom (expectedfn) expectedfn is a function this matcher falls to strictmatcher. actual value is passed expectedfn check.expectedfn should return either boolean result an object the match expected fields. boolean match property says whether checkpassed expected is used error reporting. is possible return custom expectedfn results another matcher.assert.deepequal({ : 1 }, custom( actual => actual. === 1) ) // passesassert.deepequal({ : 1 }, custom( actual => actual. !== 1) ) // throwsassert.deepequal({ : 1 }, custom( actual => ({ // passes match: actual. === 1, expected: 1,}) ))assert.deepequal({ : 1 }, custom( actual => ({ // throws match: actual. !== 1, expected: '[\"\" should be equal 1]',}) ))// return results another matcherassert.deepequal([1, 1, 1], custom( // passes (actual, comparator) => arrayof(gt(0)).match(actual, comparator)))assert.deepequal([1, 1, ''], custom( // throws (actual, comparator) => arrayof(1).match(actual, comparator)))faqwhy enhancing assert matchers? are cases you care more about specific values rather their shapes features. assert-match provides with way achieve through matchers.why yet another matchers?existing assertion libraries provide with tons crazy named matchers each use case requires (or ) to introduce completely matcher. the hand assert-match provides with succinct set combinablematchers, sufficient reproduce the matchers that libs a clear .why does matchers are strict default? more strict tests less probability introduce bugs yoursystem the more probability detect . however, noted above, are cases you care more about specific values rather theirshapes features. assert-match tries consistently address twopoints. about power-assert?yes, have >:3.why extension api? matchers be combinable means not many them not expressed existing ones, this feature not in great demand. additionally,custom matcher may used this purpose some extent. however, arealways welcome issues provide points why or other feature isrequired.related projectspower-assert-match"
}