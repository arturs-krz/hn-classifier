{
	"_id": "14398594",
	"site": "https://github.com/mgechev/angular-performance-checklist",
	"title": "Angular Performance Checklist",
	"author": "mgechev",
	"date": "2017-06-13T13:56:42.111Z",
	"tags": {
		"categories": [
			"opensource",
			"angular",
			"performance",
			"practice",
			"pwa",
			"service-worker",
			"application-shell"
		],
		"languages": []
	},
	"content": "readme.md angular performance checklistintroduction document contains list practices will help boost performance our angular applications. \"angular performance checklist\" covers different topics - server-side pre-rendering bundling our applications, runtime performance optimization the change detection performed the framework. document is divided two main sections:network performance - lists practices are going improve mostly load of application. include methods latency bandwidth reduction.runtime performance - practices improve runtime performance our application. include mostly change detection rendering related optimizations. practices impact both categories there be slight intersection, however, differences the cases the implications be explicitly mentioned. subsections list tools, related the specific practice, can us more efficient automating development flow.note most practices are valid both http/1.1 http/2. practices make exception be mentioned specifying which version the protocol could applied.table contentangular performance checklistintroductiontable contentnetwork performancebundlingminification dead code eliminationtree-shakingahead--time (aot) compilationcompressionpre-fetching resourceslazy-loading resourcesdon't lazy-load default routecaching application shell service workersruntime optimizations enableprodmodeahead--time compilationweb workersserver-side renderingchange detectionchangedetectionstrategy.onpushdetaching change detectorrun outside angular pure pipes trackby option *ngfor directiveconclusioncontributingnetwork performance of tools this section are still development are subject change. angular core team is working automating build process our applications much possible a lot things happen transparently.bundlingbundling is standard practice aiming reduce number requests the browser needs perform order deliver application requested the user. essence, bundler receives an input list entry points produces or more bundles. way, browser get entire application performing a few requests, instead requesting each individual resource separately. your application grows bundling everything a single large bundle again counter productive. explore code splitting techniques using webpack.additional http requests not a concern http/2 of server push feature.toolingtools allows to bundle applications efficiently are:webpack - provides efficient bundling performing tree-shaking.webpack code splitting - techniques split code.webpack & http2 - need splitting http2.rollup - provides bundling performing efficient tree-shaking, taking advantage the static nature the es2015 modules.google closure compiler - performs plenty optimizations provides bundling support. originally written java, since recently also has javascript version can found here.systemjs builder - provides single-file build systemjs mixed-dependency module trees.browserify.resources\"building angular application production\"\"2.5x smaller angular applications google closure compiler\"minification dead code elimination practices allow to minimize bandwidth consumption reducing payload our application.toolinguglify - performs minification such mangling variables, removal comments & whitespace, dead code elimination, etc. written completely javascript, has plugins all popular task runners.google closure compiler - performs similar uglify type minification. advanced mode transforms ast our program aggressively order be able perform more sophisticated optimizations. has a javascript version can found here. gcc supports of es2015 modules syntax it perform tree-shaking.resources\"building angular application production\"\"2.5x smaller angular applications google closure compiler\"tree-shaking the final version our applications usually don't the entire code is provided angular /or third-party library, the that 've written. thanks the static nature the es2015 modules, 're able get rid the code is referenced our apps.example// foo.jsexport foo = () => 'foo';export bar = () => 'bar';// app.jsimport { foo } './foo';console.log(foo());once tree-shake bundle app.js 'll :let foo = () => 'foo';console.log(foo()); means the unused export bar not included the final bundle.toolingwebpack - provides efficient bundling performing tree-shaking. once application has been bundled, does export unused code it be safely considered dead code removed uglify.rollup - provides bundling performing efficient tree-shaking, taking advantage the static nature the es2015 modules.google closure compiler - performs plenty optimizations provides bundling support. originally written java, since recently has a javascript version can found here.note: gcc does support export * yet, is essential building angular applications of heavy usage the \"barrel\" pattern.resources\"building angular application production\"\"2.5x smaller angular applications google closure compiler\"ahead--time (aot) compilation challenge the available the wild tools (such gcc, rollup, etc.) are html- templates the angular components, cannot analyzed their capabilities. makes tree-shaking support less efficient they're sure directives are referenced within templates. aot compiler transpiles angular html- templates javascript typescript es2015 module imports. way are able efficiently tree-shake during bundling remove the unused directives defined angular, third-party libraries by ourselves.tooling@angular/compiler-cli - drop- replacement tsc statically analyzes application emits typescript/javascript the component's templates.resources\"ahead--time compilation angular\"compressioncompression the responses' payload is standard practice bandwidth usage reduction. specifying value the header accept-encoding, browser hints server compression algorithms are available the client's machine. the hand, server sets value the content-encoding header the response order tell browser algorithm has been chosen compressing response.tooling tooling here is angular-specific entirely depends the web/application server we're using. typical compression algorithms are:deflate - data compression algorithm associated file format uses combination the lz77 algorithm huffman coding.brotli - generic-purpose lossless compression algorithm compresses data using combination a modern variant the lz77 algorithm, huffman coding 2nd order context modeling, a compression ratio comparable the best currently available general-purpose compression methods. is similar speed deflate offers more dense compression.note: brotli is widely supported yet.resources\"better gzip compression brotli\"\"2.5x smaller angular applications google closure compiler\"pre-fetching resourcesresource pre-fetching is great to improve user experience. can either pre-fetch assets (images, styles, modules intended be loaded lazily, etc.) data. are different pre-fetching strategies most them depend specifics the application.lazy-loading resources case target application has huge code base hundreds dependencies, practices listed above may help reduce bundle a reasonable size (reasonable might 100k 2m, again, completely depends the business goals). such cases good solution might to load of application's modules lazily. instance, lets suppose 're building e-commerce system. this case might to load admin panel independently the user-facing ui. once administrator has add new product 'd to provide ui required that. could either the \"add product page\" the entire admin panel, depending our case/business requirements.toolingwebpack - allows asynchronous module loading.don't lazy-load default routelets suppose have following routing configuration:// bad practiceconst routes: routes = [ { path: '', redirectto: '/dashboard', pathmatch: 'full' }, { path: 'dashboard', loadchildren: './dashboard.module#dashboardmodule' }, { path: 'heroes', loadchildren: './heroes.module#heroesmodule' }]; first the user opens application using url: https://example.com/ will redirected /dashboard will trigger lazy-route path dashboard. order angular render bootstrap component the module, will has download file dashboard.module all its dependencies. later, file needs be parsed the javascript vm evaluated.triggering extra http requests performing unnecessary computations during initial page load is bad practice since slows down initial page rendering. consider declaring default page route non-lazy.cachingcaching is another common practice intending speed- our application taking advantage the heuristic if resource was recently been requested, might requested again near future. caching data usually a custom caching mechanism. caching static assets can either the standard browser caching service workers the cachestorage api. application shell make perceived performance your application faster, an application shell. application shell is minimum user interface we show the users order indicate that application be delivered soon. generating application shell dynamically can angular universal custom directives conditionally show elements depending the used rendering platform (.e. hide everything except app shell using platform-server).toolingangular mobile toolkit - aims automate process managing service workers. also contains service worker caching static assets, one generating application shell.angular universal - universal (isomorphic) javascript support angular.resources\"instant loading web apps an application shell architecture\" service workers can of service worker an http proxy is located the browser. requests sent the client are intercepted the service worker can either handle or pass through network.toolingangular mobile toolkit - aims automate process managing service workers. also contains service worker caching static assets, one generating application shell.offline plugin webpack - webpack plugin adds support service worker a fall- to appcache.resources\" offline cookbook\"runtime optimizations section includes practices can applied order provide smoother user experience 60 frames per second (fps). enableprodmode development mode angular performs extra checks order verify performing change detection does result any additional changes any the bindings. way frameworks assures the unidirectional data flow has been followed. order disable changes production not forget invoke enableprodmode:import { enableprodmode } '@angular/core'; (env === 'production') { enableprodmode();}ahead--time compilationaot be helpful only achieving more efficient bundling performing tree-shaking, also improving runtime performance our applications. alternative aot is -in- compilation (jit) is performed runtime, therefore can reduce amount computations required rendering our application performing compilation part our build process.tooling@angular/compiler-cli - drop- replacement tsc statically analyzes application emits typescript/javascript the component's templates.angular2-seed - starter project includes support aot compilation.angular-cli using ng serve --prodresources\"ahead--time compilation angular\"web workersusual problem the typical single-page application (spa) is our code is usually run a single thread. means if want achieve smooth user experience 60fps have most 16ms execution between individual frames are being rendered, otherwise 'll drop half. complex application huge component tree, where change detection needs perform millions check each second will be hard start dropping frames. thanks the platform agnosticism angular it being decoupled dom architecture 's possible run entire application (including change detection) a web worker leave main ui thread responsible for rendering.tooling module allows to run application a web worker is supported the core team. examples it be used, be found here.webpack web worker loader - web worker loader webpack.resources\"using web workers more responsive apps\"server-side rendering big issue the traditional spa is they cannot rendered until entire javascript required their initial rendering is available. leads two big problems: all search engines are running javascript associated the page they are able index content dynamic apps properly.poor user experience, since user see nothing more a blank/loading screen until javascript associated the page is downloaded, parsed executed.server-side rendering solves issue pre-rendering requested page the server providing markup the rendered page during initial page load.toolingangular universal - universal (isomorphic) javascript support angular.preboot - library help manage transition state (.e. events, focus, data) a server-generated web view a client-generated web view.resources\"angular server rendering\"\"angular universal patterns\"change detection each asynchronous event angular performs change detection the entire component tree. although code detects changes is optimized inline-caching, still be heavy computation complex applications. way improve performance the change detection is not perform for subtrees are supposed be changed based the recent actions.changedetectionstrategy.onpush onpush change detection strategy allows to disable change detection mechanism subtrees the component tree. setting change detection strategy any component the value changedetectionstrategy.onpush, make change detection perform when component received different inputs. angular consider inputs different it compares with previous inputs reference, the result the reference check is false. combination immutable data structures onpush bring great performance implications such \"pure\" components.resources\"change detection angular\"detaching change detectoranother of implementing custom change detection mechanism is detaching reattaching change detector (cd) given component. once detach cd angular not perform check the entire component subtree. practice is typically used user actions interactions an external services trigger change detection more often required. such cases may to consider detaching change detector reattaching only performing change detection is required.run outside angular angular's change detection mechanism is being triggered thanks zone.js. zone.js monkey patches asynchronous apis the browser triggers change detection the end the execution any async callback. rare cases may given code be executed outside context the angular zone thus, without running change detection mechanism. such cases can the method runoutsideangular the ngzone instance.example the snippet below, can an example a component uses practice. the _incrementpoints method is called component start incrementing _points property every 10ms ( default). incrementation make illusion an animation. since this case don't to trigger change detection mechanism the entire component tree, every 10ms, can run _incrementpoints outside context the angular's zone update dom manually ( the points setter).@component({ template: '<span #label></span>'})class pointanimationcomponent { @input() duration = 1000; @input() stepduration = 10; @viewchild('label') label: elementref; @input() set points(val: number) { ._points = val; (this.label) { .label.nativeelement.innertext = ._pipe.transform(.points, '1.0-0'); } } points() { return ._points; } private _incrementinterval: ; private _points: number = 0; constructor(private _zone: ngzone, private _pipe: decimalpipe) {} ngonchanges(changes: ) { const change = changes.points; (!change) { return; } (typeof change.previousvalue !== 'number') { .points = change.currentvalue; } else { .points = change.previousvalue; ._ngzone.runoutsideangular(() => { ._incrementbrowniepoints(change.currentvalue); }); } } private _incrementpoints(newval: number) { const diff = newval - .points; const step = .stepduration * (diff / .duration); const initialpoints = .points; ._incrementinterval = setinterval(() => { let nextpoints = math.ceil(initialpoints + diff); (this.points >= nextpoints) { .points = initialpoints + diff; clearinterval(._incrementinterval); } else { .points += step; } }, .stepduration); }}warning: this practice very carefully when 're sure you are doing if used properly can lead an inconsistent state the dom. note the code above is going run webworkers. order make webworker-compatible, need set label's value using angular's renderer. pure pipes argument @pipe decorator accepts object literal the following format:interface pipemetadata { name: string; pure: boolean;} pure flag indicates the pipe is dependent any global state does produce side-effects. means the pipe return same output invoked the same input. way angular cache outputs all input parameters pipe has been invoked , and reuse in order not to recompute on each evaluation. default value the pure property is true. trackby option *ngfor directive *ngfor directive is used rendering collection. default *ngfor doesn't how identify each item the given collection. the collection is changed some then whole dom tree is destroyed recreated again. is acceptable the collection is totally different. most times have a slightly modified collection (e.g. collection is sorted one item is added/removed/changed). anyway dom tree is destroyed recreated the scratch again. is unnecessary , what more important, may lead poor performance the whole app, particularly a big collection data. modify behavior is to developer provide custom tracking function trackby option the *ngfor directive. tracking function takes arguments: index item. angular uses value returned tracking function track items identity.example@component({ selector: 'yt-feed', template: ` <h1> video feed</h1> <yt-player *ngfor=\"let video feed; trackby: trackbyid\" [video]=\"video\"></yt-player>`})export class ytfeedcomponent { feed = [ { id: 3849, // note \"id\" field, refer it \"trackbyid\" function title: \"angular 60 minutes\", url: \"http://youtube.com/ng2--60-min\", likes: \"29345\" }, // ... ]; trackbyid(index, item) { return item.id; }}resources\"ngfor directive\" - official documentation *ngfor\"angularimprove performance trackby\" - shows gif demonstration the approachconclusion list practices dynamically evolve time new/updated practices. case notice something missing you that of practices be improved not hesitate fire issue /or pr. more information please a at \"contributing\" section below.contributing case notice something missing, incomplete incorrect, pull request be greatly appreciated. discussion practices are included the document please open issue.licensemit"
}