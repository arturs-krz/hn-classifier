{
	"_id": "14337773",
	"site": "https://github.com/toish/chromatism",
	"title": "Chromatism-A color function module that I'm using to learn the math behind color",
	"author": "toish",
	"date": "2017-06-13T13:58:18.305Z",
	"tags": {
		"categories": [
			"opensource",
			"hsl",
			"tetrad",
			"hue",
			"rgb",
			"ciexyz",
			"chromatic-adaptation",
			"triad",
			"illuminants",
			"color",
			"color-modes",
			"hue-shift",
			"cielab",
			"colour"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md chromatism simple set utility functions colours.awesome resources colour stuff.bruce lindbloomcolormineeasyrgbtable contentschromatismtable contentscontributinginstallationcommonjsbrowser without bundlingfunctionscolour transformationsconvert colour typesgenerate complementary colourgenerate array triad coloursgenerate array tetrad coloursfind mid point between coloursinvert colourinvert grey colourblend colours (multiply)generate array adjacent hue-shifted colours (rainbow effect)generate array the fade between coloursgenerate new shade a colourgenerate new saturation a colourchange colour's brightnessshift hue a colourshift contrast a colourgreyscale version the coloursepia version the colourdetermine accessible colour foreground textchromatic adaptation (white point)colour metering functionscolour differencecolour temperatureconstantsscales + colour spacescolour modescontributing off, thanks much helping ! colour modes + functions contributing info be added soon.note: type definitions file (/index.d.ts) must updated part your pull request. ( you're familiar typescript, can update for ya.) contains definitions colour modes colour functions. (special thanks @bdoss github adding inital ts definitions!)installation$ npm install --save chromatismcommonjsvar chromatism = require('chromatism');es modulesimport chromatism 'chromatism';browser without bundling<script type=\"text/javascript\" src=\"path--files/dist/chromatism.js\"></script>functions functions take colour type. can mix colour types a function takes more one. list colour types are available here. return values are not bound the function. functions return colours, return colour object, contains getters each colour type. you the return value one these functions get returnvalue.hex example, will the hexadecimal equivalent value. can chain functions. last parameter be piped from output the parent function. note: following examples return different types values, (hex, rgb, hsl, etc) you use of available colour modes seen the colour modes table the bottom this readme. colour transformations following functions return colour object, contains getters get return value any colour mode. [colour mode](#colour modes) table a list all available colour modes.convert colour typesvar newcolour = chromatism.convert( colour ).hex;value be colour any the supported colour modes. ( chart bottom readme) is identity operation, it returns object containing of available colour modes the result. colour modes supported be converted any . this does however mean some conversions have intermediate values, can cause small inconsistencies, especially changing colour spaces. path each conversion is optimised much possible avoid loss colour information.generate complementary colourvar newcolour = chromatism.complementary( colour ).rgb; is a uniform version this function. using uniform version, output colours have same apparent lightness the source colour, normally means 'll nicer together. ( is performance trade-off however.)var newcolour = chromatism.uniformcomplementary( colour ).rgb;generate array triad coloursvar newcolour = chromatism.triad( colour ).hsl; is a uniform version this function. using uniform version, output colours have same apparent lightness the source colour, normally means 'll nicer together. ( is performance trade-off however.)var newcolour = chromatism.uniformtriad( colour ).rgb;generate array tetrad coloursvar newcolour = chromatism.tetrad( colour ).cmyk; is a uniform version this function. using uniform version, output colours have same apparent lightness the source colour, normally means 'll nicer together. ( is performance trade-off however.)var newcolour = chromatism.uniformtetrad( colour ).rgb;find mid point between coloursvar newcolour = chromatism.mid( colourone, colourtwo ).cssrgb;invert colourvar newcolour = chromatism.invert( colour ).hex;invert grey colourvar newcolour = chromatism.invertlightness( colour ).hsl;blend colours (multiply)var newcolour = chromatism.multiply( colourone, colourtwo ).hsv;generate array adjacent hue-shifted colours (rainbow effect)var newcolour = chromatism.adjacent( degrees, sections, colour ).cmyk;shift should in degrees. can either positive negative.generate array the fade between coloursvar newcolour = chromatism.fade( amount, colourfrom, colourto ).hsl;generate new shade a colourvar newcolour = chromatism.shade( percent, colour ).csshsl;percent should a number between -100 100.generate new saturation a colourvar newcolour = chromatism.saturation( percent, colour ).hex;percent should a number between -100 100.change colour's brightnessvar newcolour = chromatism.brightness( percent, colour ).hsl; essentially acts a sum saturation shade, thus does adjust luminosity. brightness works 99% most scenarios though.percent should a number between -100 100.shift hue a colourvar newcolour = chromatism.hue( degrees, colour ).hex;hue shift is measured degrees, using hsl colour model.shift contrast a colourvar newcolour = chromatism.contrast( contrastcoeff, colour ).hsl;contrast coefficient is supplied decimal form! 'll normally a value between 0 4.imagine increasing contrast (shift > 1) making lighter colours lighter, darker colours darker. decreasing (shift < 1) makes colours more similar.greyscale version the colourvar newcolour = chromatism.greyscale( colour ).cmyk;sepia version the colourvar newcolour = chromatism.sepia( colour ).hsv;determine accessible colour foreground textvar newcolour = chromatism.contrastratio( colour ).rgb; this function determine colour text needed create high contrast between text a solid background the supplied colour. made according the w3c standard web accessibilitychromatic adaptation (white point)var newcolour = chromatism.adapt( colour, illuminantcolour, [source illuminant] ).xyz;shifts illuminant (white-point) the supplied colour. supply value the illuminants constant use standard white-point. ( colours chromatism are assumed be illuminated d65, you leave off source illuminant property normally, defaults cie 2° d65 xyz format.) colour metering functions functions not return colour, instead return aspect measure the colour(s).colour differencevar diff = chromatism.difference( colourone, colourtwo, [luminance weight], [chroma weight] );returns measure how different two supplied colours are. luminance chroma weight are equal l c the cmc l:c delta-e equation. default are both set 1. (thus testing imperceptibility)colour temperaturevar diff = chromatism.temperature( colour );returns correlated colour temperature the supplied colour kelvin. ( higher number indicates blue-er colour; lower number indicates red-er colour.) should be used working colours could actually emitted a black-body radiator ( glowing stuff, such tungsten incandescent lightbulbs), colour temperature is an approximation the colour a narrow strip the xyz gamut. (note thin line the middle this chart.)colour temperature is calculated via mccamy's cct fomula. (doi: 10.1002/col.5080170211) may mean colours temperatures beyond 6500k (cie illuminant d65) are entirely accurateconstantschromatism has useful constants built , you access using imported chromatism object.referencevaluesdescriptionchromatism.illuminants., .b, .c, .d50, .d55, .d65, .d75, .e, .f2, .f7, .f11standard cie illuminants xyz formatchromatism.transforms.bradford, .inverse_bradford, .srgb_xyz, .inverse_srgb_xyztransformation matricesscales + colour spacesmodescalecolour space.hex#000000 - #ffffffsrgb.rgb(r, g, b) 0 - 255srgb.cssrgb(r, g, b) 0 - 255srgb.hsl(h) 0 - 359, (s, l) 0 - 100srgb.csshsl(h) 0 - 359, (s, l) 0 - 100srgb.hsv(h) 0 - 359, (s, v) 0 - 100srgb.cmyk(c, m, y, k) 0 - 1cmyk.yiq(y, , q) 0 - 1yuv.xyz(y) 0 - 100, (x, z) derivedxyz.xyy(y) 0 - 100, (x, y) 0 - 1xyz.lms(, , ) 0 - 1xyz.cielab (l**b*)(l) 0 - 100, (, b) -128 - 128cielab.cieluv (l*u*v*)(l) 0 - 100, (u, v) -128 - 128cieluv.cielch (l*c*h*)(l) 0 - 100, (c, h) -128 - 128cielch.hsluv(hu) 0 - 359, (s, l) 0 - 10cielchcolour modesmodeexample syntax.hex\"#ffc837\".rgb{ r:255, g: 200, b: 55 }.cssrgb\"rgb(255,200,55)\".hsl{ h: 44, s: 100, l: 61 }.csshsl\"hsl(44,100,61)\".hsv{h: 44, s: 78, v: 100}.cmyk{c: 0.5, m: 1, y: 0.2, k: 0.45}.yiq{ y: 0.132, : 0.0222, q: 0.195 }.xyz{ x: 41.24, y: 21.26, z: 1.93 }.xyy{ x: 0.64, y: 0.33, y: 21.26 }.lms{ rho: 42.266, gamma: 5.561, beta: 2.135 }.cielab (l**b*){ l: 53.23, : 80.11, b: 67.22 }.cieluv (l*u*v*){ l: 53.23, u: 175.05, v: 37.75 }.cielch (l*c*h*){ l: 53.23, c: 179.08, h: 12.17 }.hsluv{ hu: 12.17, s: 99.99, l: 53.23 } note cieluv + cielch: conversion cieluv ( by extension, cielch) requires defining illuminant, can skew results slightly. default, chromatism assumes colours are illuminated cie d65, means you may differing chrominance values (±~10) you are comparing against cieluv/cielch colour illuminated anything than d65. functions return object containing modes the result. ( getters, don't worry, chromatism doesn't calculate the versions the result you a function!) example, you need string containing hex code the colour result, simply .hex:var newcolour = chromatism.invert(\"#5300ff\").hex"
}