{
	"_id": "14444061",
	"site": "https://github.com/emilwallner/Core-War",
	"title": "A Reproduction of the Core War Game. Assembly Compiler, Virtual Machine and GUI",
	"author": "etrevino",
	"date": "2017-06-13T13:55:21.475Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c",
			"c++",
			"makefile",
			"assembly"
		]
	},
	"content": "readme.md core war was inspired a malicious virus written the 80s. deal the self-replicating virus, white hat hacker invented reaper. was virus designed spread eliminate malware. fought fire fire. inspired . k. dewdney coin idea core war. idea was simple. compete designing viruses overtake computer. win protecting own program overwriting opponent's programs. is happening a virtual computer. , a simple computer within computer. is is looks in action:lets focus the high-level game dynamics: game board, memory our virtual computer. s represented a 64 x 64 grid bytes. players, small programs represented different colors. white parts blank memory.cursors, moving parts inverted color. read the game board. cursors a couple features. can jump the game board, store write values, clone themselves. cursors belong no-, they read the game board. the game starts, players one cursor the beginning their program. game advances the cursors read commands stored their programs. they end on faulty command a blank memory, moves the next byte.below, see the pink player starts cloning cursors. then starts attacking blue player.lets into little bit more depth.every byte see, pairs numbers letters, are represented hexadecimal. each hexadecimal has value a digit, 0 - 255. are 16 operations the game. operations decide the cursor should jump a different address, clone itself so . the 16 hexadecimal are coding bytes, all store different operation. remaining digits, 17 - 255, are regular numbers. coding byte decides operation execute how many bytes read. the image above, pink player goes the hexadecimal 0c. 's 12 decimal, telling cursor clone itself. two bytes decide where cloned cursor starts. are three main components determine wins:game rounds, every game round is measured cycles. determines much each cursor read the game board.lives, a cursor reads player life the game board, are given life that round. are visualized the colorful progress bars.cycle die, every game round, number bytes cursor read the game board is reduced. win your program is last to receive life. are more nuances the game i dont cover. best to learn them is run with below code.executing core waropen terminal make full-screen, copy paste below, hit enter.git clone https://github.com/emilwallner/core-war.git ; cd core-war ; ; ./corewar -visual ./players/compiled/bigzork.cor ./players/compiled/fluttershy.cor ./players/compiled/turtle.cor ./players/compiled/helltrain.coronce cycle die reaches 0, will announce winner. you press key leave program. usage the core war game:usage: example: ./corewar -visual -n -1 filename.cor gui: ./corewar -visual [players] default player numbers: 1, 2, 3, 4... change player number: -n -1 filename.cor dump: ./corewar -dump 300 [players](prints memory 300 cycles) game ! if want create then compile players, the asm:./asm [filename.s]technical implementation overview did core war three friends: @mhza, @natansab, @tlenglin. core war consists players are written assembly, compiler turn into binary, the virtual computer run programs .i focussed the main architecture the virtual machine (vm), game dynamics, implementing three operations, handling cursors implementing graphical user interface (gui). program is written using read, open, write, malloc, free exit stdlib.h. used ncurses library create gui. is example a simple player, normal player has around 150 lines assembly code: .name \"zork\" .comment \"'m aliiiive\" l2: sti r1,%:live,%1 r1,%0,r1 live: live %1 zjmp %:live complies binary is later represented hexadecimal. above program looks this its compiled: 0000000 00 ea 83 f3 7a 6f 72 6b 00 00 00 00 00 00 00 00 0000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 * 0000080 00 00 00 00 00 00 00 00 00 00 00 17 49 27 4d 20 0000090 41 4c 49 49 49 49 56 45 00 00 00 00 00 00 00 00 00000a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 * 0000890 0b 68 01 00 0f 00 01 06 64 01 00 00 00 00 01 01 00008a0 00 00 00 01 09 ff fb first part includes identification code the name, followed the comment, ending the program will stored the memory the virtual machine. technical implementation i mentioned earlier, focussed the main architecture the virtual machine, game dynamics, implementing three hexadecimal operations, handling cursors the gui. is main created the vm: int main(int ac, char **av) { t_env e; (ac == 1) ft_error_usage(); init_e(&e, av); ft_parse_flags(&e, ac, av); ft_files_to_string(&e); init_players(&e); ft_parsing(&e); ft_build_arena(&e); ft_init_cursor(&e); ft_move_cursors(&e); ft_declare_winner(&e); ft_exit(&e, 0); return (0); } should you rough understanding the main logic. parse flags entered the terminal, turn files strings, initiate players; parse player data, set the memory the vm, initiate cursors, run game, declare winners, free data.below is main struct it gives a rough idea s going . typedef struct s_env { t_player player[max_players + 1]; t_cursor *head; t_arena [mem_size]; int cursors; int dump; int dump_value; int cycle; int tot_cycle; int lives; int check; int bonus; int winner; int last_alive; int cycles_to_die; char arena[mem_size]; int player_amount; char **files; t_op p_tab[17]; } t_env; game board, memory the virtual machine, is stored a static struct array, t_arena. could been int array, this enabled more flexibility manage gui. cursors are stored a doubly linked list, s circular, has extra node keep track the beginning the list. every a cursor reads coding byte clone itself, adds new cursor the end the list. core structure performed up 10m cursors. choose function pointer handle 16 operations mentioned the section. allowed to easily on different functions access when necessary. static void (*g_func_ptr[17])(t_env *e, t_cursor *cursor) = { ft_live, ft_live, ft_ld, ft_st, ft_add, ft_sub, ft_and, ft_or, ft_xor, ft_zjmp, ft_ldi, ft_sti, ft_fork, ft_lld, ft_lldi, ft_lfork, ft_aff };s for . if have questions find issues the game, ping an email."
}