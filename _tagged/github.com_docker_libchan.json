{
	"_id": "14400549",
	"site": "https://github.com/docker/libchan",
	"title": "Libchan: Like Go channels over the network",
	"author": "loppers92",
	"date": "2017-06-13T13:56:41.363Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"go"
		]
	},
	"content": "readme.md libchan: go channels the networklibchan is ultra-lightweight networking library lets network services communicate the same that goroutines communicate using channels:simple message passingsynchronization concurrent programmingnesting: channels send channelslibchan supports following transports of box:-memory channelunix socketraw tcptlshttp2/spdywebsocket provides great flexibility scaling application breaking down loosely coupled concurrent services. same application be composed goroutines communicating in-memory channels; transition separateunix processes, each assigned a processor core, communicating high-performance ipc; to cluster machines communicating authenticated tls sessions. along benefits the concurrency model has made so popular. all transports the same semantics. -memory channels guaranteeexactly-once delivery; tcp, tls, the various http socket families notguarantee delivery. messages arrive order may arbitrarily delayed lost. are ordering invariants across channels. explicit goal libchan is simplicity implementation clarity spec. porting to language should as effortless humanly possible.focused not reinventing wheel remote libchan sessions are regular http2 tls sessions, can used combination any standard proxy authenticationmiddleware. means libchan, configured properly, be safely exposed the public internet. can be embedded an existing rest apiusing http1 websocket fallback. is different rpc rest?modern micro-services are a great fit classical rpc restprotocols they often rely heavily events, bi-directionalcommunication, stream multiplexing, some form data synchronization.sometimes services a component requires raw socket access,either performance (file transfer, event firehose, database access) simply they their own protocol (dns, smtp, sql, ssh,zeromq, etc). components typically need separate set tools they are outside scope the rest rpc tools. there is a websocket serverevents transport, those require yet another layer tools.instead a clunky patchwork tools, libchan implements a singleminimalistic library the primitives needed modern micro-services:request/response arbitrary structured dataasynchronous events flowing real- in both directionsrequests responses flow any direction, can arbitrarilynested, example implement self-registering worker model message serialization format be plugged : json, msgpack, xml,protobuf.raw file descriptors be \"attached\" any message, passed under hood using best method available each transport. go channeltransport passes os.file pointers around. unix socket transportuses fd passing makes suitable high-performance ipc. tcp transport uses dedicated http2 streams. as bonus extension, built- tcp gateway be used proxy raw network sockets withoutextra overhead. means libchan services be used smart gateways asql database, ssh file transfer service, unified auth, discovery tooling without performance penalty.example usagehere's example implementing basic rpc-style request/response. gloss error handling tersely demonstrate core concepts. the client:var ch libchan.sender// send message, indicate we a return channel be automatically createdret1, err := ch.send(&libchan.message{data: []byte(\"request 1!\"), ret: libchan.retpipe})// send another message the same channelret2, err := ch.send(&libchan.message{data: []byte(\"request 2!\"), ret: libchan.retpipe})// wait an answer the request. set flags zero// indicate don't a nested return channel.msg, err := ret1.receive(0) the server:var ch libchan.receiver// wait messages a loop// set return channel flag indicate we// to receive nested channels ( any).// note: don't send nested return channel, we .for {msg, err := ch.receive(libchan.ret)msg.ret.send(&libchan.message{data: []byte(\" is extremely useful response\")});}creatorssolomon hykeshttp://twitter.com/solomonstrehttp://github.com/shykesadditional implementationsjavahttps://github.com/ndeloof/jchanjavascript / node.jshttps://github.com/graftjs/jschancopyright licensecode documentation copyright 2013-2014 docker, inc. code released under apache 2.0 license.docs released under creative commons."
}