{
	"_id": "14457740",
	"site": "https://github.com/peter-woyzbun/querygraph",
	"title": " Query Graph Lang – Join Across Database Types (e.g. Postgres – MongoDb)",
	"author": "petewoyz",
	"date": "2017-06-13T13:05:03.685Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"python"
		]
	},
	"content": "readme.md note: currently ready initial release.query graph is framework/language, written python, joining data different database management systems - .e. joins can'ttypically accomplished a single query. example, joiningpostgres data mongo db data. also provides tools easilyconverting non-tabular data (e.g. json) tabular form. following databases are currently supported:sqlitemysqlpostgresmongo dbelastic searchapache cassandra (untested)maria db (untested)influxdb (untested)ms sql (untested)neo4j (untested)main featuresjoin data any number different database types a single query.manipulate data using \"manipulation sets\", are chained togetherstatements very similar those used the dplyr package r.easily transform json- data relational form.threading optionally used run queries different databasessimultaneously, based the structure the query graph.getting started install query graph, below. a brief introduction query graph, below installationinstructions.installation install query graph, clone repository locally, run:python setup.py installquery graph language - brief introductionquery graph language (qgl) is simple, domain specific declarative\"language\". best to an idea how works is through example. the example, 'll joining data two databases: mongo db database, a postgres database. mongo db database mongo db database contains collection, albums, data thefollowing form:{ \"album\": \"jagged little pill\", \"tags\": [ \"canada\", \"pop rock\", \"post-grunge\", \"female\" ], \"data\": {\"record_label\": \"maverick\", \"\": 1995}} postgres database postgres database contains table, albums, is structured the following manner:albumidtitleartistid.........6jagged little pill4......... qgl query qgl query used join both sets data is below ( the equivalentpython code the bottom the page).connect postgres_conn <- postgres(db_name='', user='', password='', host='', port='') mongodb_conn <- mongodb(host='', port='', db_name='', collection='')retrieve query | {'tags': {'$': {% album_tags -> list:str %}}}; fields album, tags, data using mongodb_conn | unpack(record_label=data['record_label']) >> unpack(=data['']) >> remove(data) >> flatten(tags) >> rename(tags=tag); mongo_node --- query | select * \"album\" where \"title\" {{ mongo_node.album -> list:str }}; using postgres_conn | rename(title=album); postgres_nodejoin left (pg_node[album] ==> mongo_node[album]) execute query python, code isquery_str = \"...\" # string defined above.# create graph instance.query_graph = querygraph(qgl_str=query_str)# execute graph get dataframe return.df = query_graph.execute(album_tags=['canada', 'rock']) output is pandas dataframe:albumtagrecord_labelalbumidartistidjagged little pillcanadamaverick199564jagged little pillpop rockmaverick199564jagged little pillpost-grungemaverick199564.................. we'll walk through query each step its execution.walkthrough basic structure our example query is broken down the diagrambelow. connect block establishes connections the databases will queried upon execution. retrieve block is where\"query nodes\" are defined, each query node represents query a single database. join block describes the data results each query node are joined.mongo_node execution our example query is executed, first thing happen is rendering the \"query template\" belonging the mongo_node querynode. query template is simply query written the form appropriate whatever database type will executed , augmented \"template parameters\". mongo_node query template has single\"independent\" parameter: parameter is \"independent\" its value is defined before query graph is executed ( opposed \"dependent\" parameters, arecovered below). parameter \"value expression\" defines valueassigned the parameter. our case, definedalbum_tags=['canada', 'rock'] \"container type\" \"render type\" indicate the value definedabove should rendered a list strings. rendered query mongo_node is:{'tags': {'$': ['canada', 'rock']}} is an ordinary mongo db query (using python api). query is executed using mongo_conn connector, only fields \"album\", \"tags\", \"data\" selected. dataframe returnedlooks something this:albumtagsdatajagged little pill[\"canada\",\"pop rock\",\"post-grunge\",\"female\"]{\"record_label\": \"maverick\",\"\": 1995}.................. mongo_node's \"manipulation set\", shown below, is executed the dataframeshown above. manipulation set is chained set statements verysimilar those the dplyr r package - replace %>% >>.unpack(record_label=data['record_label']) >>unpack(=data['']) >>remove(data) >>flatten(tags) >>rename(tags=tag) mongo_node's manipulation set does following:\"unpacks\" record_label value the dictionary contained the data column stores in new column called record_label.does same year.removes data column.\"flattens\" tags column - creates new row each item every list contained the column.renames tags tag. dataframe belonging mongo_node node looks this:albumtagrecord_labeljagged little pillcanadamaverick1995jagged little pillpop rockmaverick1995jagged little pillpost-grungemaverick1995............pg_node execution the mongo_node's query having been executed results retrieved, query template belonging the pg_node query node is rendered. whereas mongo_node's query template had single \"independent\" parameter, pg_node's query template has single \"dependent\" parameter: difference is the value expression a dependent parameterdraws the result its query node's \"parent\" - this casemongo_node - opposed variables defined prior execution. morespecifically, references unique values the columns thedataframe belonging the parent node. rendered query templatebelonging pg_node is:select * \"album\"where \"title\" ('jagged little pill') the parameter used unique values the album column mongo_node render list strings the form appropriate a postgres sql query. note a \"list\" container is rendereddifferently a postgres query for mongo db query - query graphknows to represent types based the database type query be run . this is especially handy working dates/times, etc. rendered query is executed using postgres_conn databaseconnector. resulting dataframe is shown below:albumidtitleartistid6jagged little pill4 pg_node has manipulation set, contains singlemanipulation renaming title column album. final stepis join results both query nodes.joining dataframes pg_node mongo_node are joined according thestatement provided the join block:left (pg_node[album] ==> mongo_node[album]) statement says left join should performed using albumcolumn pg_node's dataframe, the album column mongo_node's dataframe. more one column was required joining would listed the brackets beside each node name. final output our example query's execution is below.albumtagrecord_labelalbumidartistidjagged little pillcanadamaverick199564jagged little pillpop rockmaverick199564jagged little pillpost-grungemaverick199564..................equivalent python codeimport pymongoimport psycopg2import pandas pdmongo_conn = pymongo.mongoclient(host='', port='')def execute_mongo_query(query, fields, conn, collection, db_name): client = conn db = client[db_name] collection = db[collection] projection_fields = {k: 1 k fields} results = collection.find(query, projection_fields) df = pd.dataframe(list(results)) return dfmongo_query = {'tags': {'$': ['canada', 'rock']}}mongo_df = execute_mongo_query(query=mongo_query, fields=['album', 'tags', 'data'], conn=mongo_conn, collection='albums', db_name='some_db')def unpack_dict(row_dict, key_list): return reduce(dict.__getitem__, key_list, row_dict)mongo_df['record_label'] = mongo_df['data'].apply(lambda x: unpack_dict(row_dict=x, key_list=['record_label']))mongo_df[''] = mongo_df['data'].apply(lambda x: unpack_dict(row_dict=x, key_list=['']))mongo_df.drop('data', inplace=true, axis=1)def flatten_column(df, target_col): col_flat = pd.dataframe([[, x] i, y df[target_col].apply(list).iteritems() x y], columns=['', target_col]) col_flat = col_flat.set_index('') df = df.drop(target_col, 1) df = df.merge(col_flat, left_index=true, right_index=true) df = df.reset_index(drop=true) return dfmongo_df = flatten_column(df=mongo_df, target_col='tags')mongo_df = mongo_df.rename(columns={'tags': 'tag'})postgres_conn = psycopg2.connect(\"dbname='%s' user='%s' host='%s' password='%s' port='%s'\" % ('', '', '', '', ''))album_names = mongo_df.album.unique()album_names = '(%s)' % \", \".join(str(y) y album_names)postgres_query = \"\"\"select * \"album\"where \"title\" %s\"\"\" % album_namespostgres_df = pd.read_sql_query(postgres_query, postgres_conn)postgres_df = postgres_df.rename(columns={'title': 'album'})final_df = mongo_df.merge(postgres_df, left_on='album', right_on='album', ='left')"
}