{
	"_id": "14349897",
	"site": "https://github.com/Microsoft/react-native-code-push",
	"title": "React-native-code-push",
	"author": "onderkalaci",
	"date": "2017-06-13T13:57:47.757Z",
	"tags": {
		"categories": [
			"opensource",
			"react-native",
			"codepush"
		],
		"languages": [
			"c",
			"objective-c",
			"javascript",
			"java",
			"typescript",
			"c#",
			"other"
		]
	},
	"content": "readme.md react native module codepushnote: readme is relevant the latest version our plugin. you are using older version, please switch the relevant tag our github repo view docs that particular version. plugin provides client-side integration the codepush service, allowing to easily add dynamic update experience your react native app(s). does work?supported react native platformssupported componentsgetting startedios setupandroid setupwindows setupplugin usagereleasing updatesmulti-deployment testingdynamic deployment assignmentapi referencejavascript apiobjective-c api reference (ios)java api reference (android)debugging / troubleshootingexample apps / starterscontinuous integration / deliverytypescript consumption does work? react native app is composed javascript files any accompanying images, are bundled together the packager distributed part a platform-specific binary (.e. .ipa .apk file). once app is released, updating either javascript code (e.g. making bug fixes, adding features) image assets, requires to recompile redistribute entire binary, of course, includes review associated the store(s) are publishing .the codepush plugin helps product improvements front your end users instantly, keeping javascript images synchronized updates release the codepush server. way, app gets benefits an offline mobile experience, well the \"web-\" agility side-loading updates soon they are available. 's win-win! order ensure your end users always a functioning version your app, codepush plugin maintains copy the previous update, that the event you accidentally push update includes crash, can automatically roll . this , you rest assured your newfound release agility won't result users becoming blocked before have chance roll on server. 's win-win-win!note: product changes touch native code (e.g. modifying appdelegate.m/mainactivity.java file, adding new plugin) cannot distributed via codepush, therefore, must updated via appropriate store(s).supported react native platformsios (7+)android (4.1+)windows (uwp) try best maintain backwards compatability our plugin previous versions react native, due the nature the platform, the existence breaking changes between releases, is possible you need use specific version the codepush plugin order support exact version react native are using. following table outlines codepush plugin versions officially support respective react native versions:react native version(s)supporting codepush version(s)<0.14unsupportedv0.14v1.3 (introduced android support)v0.15-v0.18v1.4-v1.6 (introduced ios asset support)v0.19-v0.28v1.7-v1.17 (introduced android asset support)v0.29-v0.30v1.13-v1.17 (rn refactored native hosting code)v0.31-v0.33v1.14.6-v1.17 (rn refactored native hosting code)v0.34-v0.35v1.15-v1.17 (rn refactored native hosting code)v0.36-v0.39v1.16-v1.17 (rn refactored resume handler)v0.40-v0.42v1.17 (rn refactored ios header files)v0.43-v0.44v2.0+ (rn refactored uimanager dependencies)v0.45+tbd :) work hard respond new rn releases, they occasionally break . we update chart each rn release, that users check see our \"official\" support is.supported components using react native assets system (.e. using require(\"./foo.png\") syntax), following list represents set core components ( props) support having referenced images updated via codepush:componentprop(s)imagesourcemapview.marker (requires react-native-maps >=o.3.2)imageprogressviewiosprogressimage, trackimagetabbarios.itemicon, selectedicontoolbarandroid (react native 0.21.0+)actions[].icon, logo, overflowicon following list represents set components ( props) don't currently support assets being updated via codepush, due their dependency static images (.e. using { uri: \"foo\" } syntax):componentprop(s)slideriosmaximumtrackimage, minimumtrackimage, thumbimage, trackimagevideosource new core components are released, support referencing assets, 'll update list ensure users what exactly can expect update using codepush.getting startedonce 've followed general-purpose \"getting started\" instructions setting your codepush account, can start codepush-ifying react native app running following command within app's root directory:npm install --save react-native-code-push@latest with other react native plugins, integration experience is different ios android, perform following setup steps depending which platform(s) are targeting. note, you are targeting both platforms is recommended create separate codepush applications each platform. you to how projects integrated codepush, can check the excellent example apps provided the community. additionally, you'd to quickly familiarize yourself codepush + react native, can check the awesome getting started videos produced bilal budhani /or deepak sisodiya . continue installing native moduleios setupandroid setupwindows setupplugin usage the codepush plugin downloaded linked, your app asking codepush where get right js bundle , the thing left is add necessary code your app control following policies: (and often) check an update? (e.g. app start, response clicking button a settings page, periodically some fixed interval) an update is available, to present to end user? simplest to this is \"codepush-ify\" app's root component. do , you choose of following options:option 1: wrap root component the codepush higher-order component:import codepush \"react-native-code-push\";class myapp extends component {}myapp = codepush(myapp);option 2: the es7 decorator syntax:note: decorators are yet supported babel 6.x pending proposal update. may need enable by installing using babel-preset-react-native-stage-0.import codepush \"react-native-code-push\";@codepushclass myapp extends component {} default, codepush check updates every app start. an update is available, will silently downloaded, installed next the app is restarted (either explicitly the end user by os), ensures least invasive experience your end users. an available update is mandatory, it be installed immediately, ensuring the end user gets as soon possible. you like app discover updates more quickly, can choose sync with codepush server every the app resumes the background.let codepushoptions = { checkfrequency: codepush.checkfrequency.on_app_resume };class myapp extends component {}myapp = codepush(codepushoptions)(myapp);alternatively, you fine-grained control when check happens (e.g. button press timer interval), can call codepush.sync() any with desired syncoptions, optionally turn off codepush's automatic checking specifying manual checkfrequency:let codepushoptions = { checkfrequency: codepush.checkfrequency.manual };class myapp extends component { onbuttonpress() { codepush.sync({ updatedialog: true, installmode: codepush.installmode.immediate }); } render() { <view> <touchableopacity onpress={.onbuttonpress}> <text>check updates</text> </touchableopacity> </view> }}myapp = codepush(codepushoptions)(myapp); you like display update confirmation dialog ( \"active install\"), configure an available update is installed (e.g. force immediate restart) customize update experience any way, refer the codepush() api reference information how tweak default behavior.note: you are using redux redux saga, can alternatively the react-native-code-push-saga module, allows to customize sync is called a perhaps simpler/more idiomatic .note: while apple's developer agreement fully allows performing -the-air updates javascript assets ( is enables codepush!), is against policy an app display update prompt. of , we recommend app store-distributed apps don't enable updatedialog option calling sync, whereas google play internally distributed apps (e.g. enterprise, fabric, hockeyapp) choose enable/customize .releasing updatesonce app has been configured distributed your users, you've made js /or asset changes, 's to instantly release ! the simplest ( recommended) to this is use release-react command the codepush cli, will handle bundling javascript asset files releasing update the codepush server. it's basic form, command requires parameters: app name the platform are bundling update (either ios android).code-push release-react <appname> <platform>code-push release-react myapp-ios ioscode-push release-react myapp-android android release-react command enables such simple workflow it provides many sensible defaults (e.g. generating release bundle, assuming app's entry file ios is either index.ios.js index.js). however, of defaults be customized allow incremental flexibility necessary, makes a fit most scenarios.# release mandatory update a changelogcode-push release-react myapp-ios ios -m --description \"modified header color\"# release update an app uses non-standard entry file name, also capture# sourcemap file generated react-native bundlecode-push release-react myapp-ios ios --entryfile myapp.js --sourcemapoutput ../maps/myapp.map# release dev android build just 1/4 your end userscode-push release-react myapp-android android --rollout 25% --dev true# release update targets users running 1.1.* binary, opposed # limiting update exact version name the build.gradle filecode-push release-react myapp-android android --targetbinaryversion \"~1.1.0\" codepush client supports differential updates, even though are releasing js bundle assets every update, end users only actually download files need. service handles automatically that can focus creating awesome apps we worry optimizing end user downloads. more details how release-react command works, well the various parameters exposes, refer the cli docs. additionally, you prefer handle running react-native bundle command yourself, therefore, an more flexible solution release-react, refer the release command more details. you run any issues, have questions/comments/feedback, can ping within #code-push channel reactiflux, e-mail and/ check the troubleshooting details below.note: codepush updates should tested modes than debug mode. debug mode, react native app always downloads js bundle generated packager, js bundle downloaded codepush does apply.multi-deployment testing our getting started docs, illustrated to configure codepush plugin using specific deployment key. however, order effectively test releases, is critical you leverage staging production deployments are auto-generated you created codepush app ( any custom deployments may created). way, never release update your end users you haven't been able validate yourself.note: client-side rollback feature help unblock users installing release resulted a crash, server-side rollbacks (.e. code-push rollback) allow to prevent additional users installing bad release once 's been identified. however, 's obviously better you prevent erroneous update being broadly released the place.taking advantage the staging production deployments allows to achieve workflow the following (feel free customize!):release codepush update your staging deployment using code-push release-react command ( code-push release you need more control)run staging/beta build your app, sync update the server, verify works expectedpromote tested release staging production using code-push promote commandrun production/release build your app, sync update the server verify works expectednote: you to really fancy, can choose perform \"staged rollout\" part #3, allows to mitigate additional potential risk the update (e.g. did testing #2 touch possible devices/conditions?) only making production update available a percentage your users (e.g. code-push promote <app_name> staging production -r 20%). , after waiting a reasonable amount time see any crash reports customer feedback comes , you expand to entire audience running code-push patch <app_name> production -r 100%.'ll notice the above steps refer a \"staging build\" \"production build\" your app. your build process already generates distinct binaries per \"environment\", you don't need read further, since swapping codepush deployment keys is like handling environment-specific config any service app uses (e.g. facebook). however, you're looking examples how setup build process accommodate , then refer the following sections, depending the platform(s) app is targeting.android android gradle plugin allows to define custom config settings each \"build type\" (e.g. debug, release), in turn are generated properties the buildconfig class you reference your java code. mechanism allows to easily configure debug builds use codepush staging deployment key your release builds use codepush production deployment key. set up, perform following steps:open app's build.gradle file (e.g. android/app/build.gradle standard react native projects)find android { buildtypes {} } section define buildconfigfield entries both debug release build types, reference staging production deployment keys respectively. you prefer, can define key literals your gradle.properties file, then reference here. either will , and 's a matter personal preference.android { ... buildtypes { debug { ... // note: codepush updates should be tested debug mode they are overriden the rn packager. however, codepush checks updates all modes, must supply key. buildconfigfield \"string\", \"codepush_key\", '\"\"' ... } releasestaging { ... buildconfigfield \"string\", \"codepush_key\", '\"<insert_staging_key>\"' ... } release { ... buildconfigfield \"string\", \"codepush_key\", '\"<insert_production_key>\"' ... } } ...}note: a reminder, can retrieve keys running code-push deployment ls <app_name> -k your terminal.note: naming convention releasestaging is significant due this line.pass deployment key the codepush constructor via build config just defined, opposed a string literal. react native >= v0.29open your mainapplication.java file make following changes:@overrideprotected list<reactpackage> getpackages() { return arrays.<reactpackage>aslist( ... codepush(buildconfig.codepush_key, mainapplication., buildconfig.debug), // add/change line. ... );} react native v0.19 - v0.28open your mainactivity.java file make following changes:@overrideprotected list<reactpackage> getpackages() { return arrays.<reactpackage>aslist( ... codepush(buildconfig.codepush_key, , buildconfig.debug), // add/change line. ... );}note: you gave build setting different name your gradle file, simply sure reflect in java code. that's ! now you run build app, debug builds automatically configured sync your staging deployment, your release builds be configured sync your production deployment.note: default, react-native run-android command builds deploys debug version your app, if want test a release/production build, simply run `react-native run-android --variant release. refer the react native docs details how configure create release builds your android apps. you to able install both debug release builds simultaneously the same device (highly recommended!), you need ensure your debug build has unique identity icon your release build. otherwise, neither os nor will able differentiate between two. can achieve by performing following steps: your build.gradle file, specify applicationidsuffix field your debug build type, gives debug build unique identity the os (e.g. com.foo vs. com.foo.debug).buildtypes { debug { applicationidsuffix \".debug\" }}create app/src/debug/res directory structure your app, allows overriding resources (e.g. strings, icons, layouts) your debug buildscreate values directory underneath debug res directory created #2, copy existing strings.xml file the app/src/main/res/values directoryopen the debug strings.xml file change <string name=\"app_name\"> element's value something else (e.g. foo-debug). ensures your debug build has distinct display name, that can differentiate from release build.optionally, create \"mirrored\" directories the app/src/debug/res directory all your app's icons you to change your debug build. part isn't technically critical, it make easier quickly spot debug builds a device its icon is noticeable different. that's ! view here more details how resource merging works android.iosxcode allows to define custom build settings each \"configuration\" (e.g. debug, release), can be referenced the value keys within info.plist file (e.g. codepushdeploymentkey setting). mechanism allows to easily configure builds produce binaries, are configured synchronize different codepush deployments. set up, perform following steps:open your xcode project select project the project navigator windowensure project node is selected, opposed one your targetsselect info tabclick + button within configurations section select duplicate \"release\" configurationname new configuration staging ( whatever prefer)select build settings tab to build location -> per-configuration build products path -> staging change staging value $(build_dir)/$(configuration)$(effective_platform_name) $(build_dir)/release$(effective_platform_name)note: due https://github.com/facebook/react-native/issues/11813, have do step make possible use configurations debug release rn 0.40.0 higher.click + button the toolbar select add user-defined settingname new setting something codepush_key, expand , and specify staging deployment key the staging config your production deployment key the release config.note: a reminder, can retrieve keys running code-push deployment ls <app_name> -k your terminal.open project's info.plist file change value your codepushdeploymentkey entry $(codepush_key) that's ! now you run build app, staging builds automatically configured sync your staging deployment, your release builds be configured sync your production deployment.note: you encounter error message ld: library found ..., please consult issue a possible solution.additionally, you to them seperate names /or icons, can modify product bundle identifier, product name asset catalog app icon set name build settings, will allow staging builds be distinguishable release builds installed the same device.dynamic deployment assignment above section illustrated you leverage multiple codepush deployments order effectively test updates before broadly releasing to end users. however, since workflow statically embeds deployment assignment the actual binary, staging production build only ever sync updates that deployment. many cases, is sufficient, since only your team, customers, stakeholders, etc. sync your pre-production releases, therefore, they need build knows to sync staging. however, you to able perform /b tests, provide early access your app certain users, can prove very useful be able dynamically place specific users ( audiences) specific deployments runtime. order achieve kind workflow, you need do is specify deployment key want current user syncronize when calling codepush method. specified, key override \"default\" that was provided your app's info.plist (ios) mainactivity.java (android) files. allows to produce build staging production, is capable being dynamically \"redirected\" needed.// imagine \"userprofile\" is prop this component received// includes deployment key the current user should .codepush.sync({ deploymentkey: userprofile.codepush_key }); that change place, it's a matter choosing your app determines right deployment key the current user. practice, are typically solutions this:expose user-visible mechanism changing deployments any . for example, settings page have toggle enabling \"beta\" access. model works if 're concerned the privacy your pre-production updates, you power users may to opt- to earlier ( potentially buggy) updates their own (kind like chrome channels). however, solution puts decision the hands your users, doesn't help perform /b tests transparently.annotate server-side profile your users an additional piece metadata indicates deployment should sync . by default, app just the binary-embedded key, after user has authenticated, server choose \"redirect\" to different deployment, allows to incrementally place certain users groups different deployments needed. could choose store server-response local storage that becomes new default. you store key alongside user's profiles is entirely to authentication solution (e.g. auth0, firebase, custom db + rest api), is generally pretty trivial do.note: needed, could implement hybrid solution allowed end-users toggle between different deployments, while allowing server override decision. way, have hierarchy \"deployment resolution\" ensures app has ability update itself -of--box, end users feel rewarded getting early access bits, you have ability run /b tests your users needed.since recommend using staging deployment pre-release testing your updates ( explained the previous section), doesn't neccessarily sense use for performing /b tests your users, opposed allowing early-access ( explained option #1 above). therefore, recommend making full of custom app deployments, that can segment users however makes sense your needs. example, could create long-term even -off deployments, release variant your app it, then place certain users it order see they engage.// #1) create new deployment hold releases a specific app variantcode-push deployment add [app_name] test-variant-// #2) target new releases that custom deploymentcode-push release-react [app_name] ios -d test-variant-note: total user count is reported your deployment's \"install metrics\" take account users have \"switched\" one deployment another. example, your production deployment currently reports having 1 total user, you dynamically switch user staging, the production deployment report 0 total users, while staging report 1 ( user just switched). behavior allows to accurately track release adoption, in event using runtime-based deployment redirection solution.api referencejavascript apiobjective-c api reference (ios)java api reference (android)example apps / starters react native community has graciously created awesome open source apps can serve examples developers are getting started. following is list oss react native apps are using codepush, can therefore used see others are using service:f8 app - official conference app f8 2016.feline product hunt - android client product hunt.geoencoding - app lynx digital demonstrates to numerous react native components modules.math facts - app khan academy help memorize math facts more easily.additionally, you're looking get started react native + codepush, are looking an awesome starter kit, should check the following:native starter propepperoninote: you've developed react native app using codepush, is open-source, please let know. would love add to list!debugging / troubleshooting sync method includes lot diagnostic logging -of--box, if 're encountering issue using , the best thing try is examining output logs your app. will tell whether app is configured correctly (e.g. the plugin find deployment key?), the app is able reach server, an available update is being discovered, the update is being successfully downloaded/installed, etc. want continue improving logging be intuitive/comprehensive possible, please let know you find to confusing missing anything. simplest to view logs is run code-push debug command the specific platform are currently working (e.g. code-push debug ios). will output log stream is filtered just codepush messages, the specified platform. makes easy identify issues, without needing use platform-specific tool, wade through potentially high volume logs.additionally, can use of platform-specific tools view codepush logs, you are more comfortable them. simple start the chrome devtools console, xcode console (ios), os x console (ios) /or adb logcat (android), look messages are prefixed [codepush].note by default, react native logs are disabled ios release builds, if want view in release build, need make following changes your appdelegate.m file:add #import \"rctlog.h\" statementadd following statement the top your application:didfinishlaunchingwithoptions method:rctsetlogthreshold(rctloglevelinfo); you'll able see codepush logs either debug release mode, both ios android. examining logs don't provide indication the issue, please refer the following common issues additional resolution ideas:issue / symptompossible solutioncompilation errordouble-check your version react native is compatible the codepush version are using.network timeout / hang calling sync checkforupdate the ios simulatortry resetting simulator selecting simulator -> reset content settings.. menu item, then re-running app.server responds a 404 calling sync checkforupdatedouble-check the deployment key added your info.plist (ios), build.gradle (android) that 're passing sync/checkforupdate, is fact correct. can run code-push deployment ls [app_name] -k view correct keys your app deployments.update being discovereddouble-check the version your running app (e.g. 1.0.0) matches version specified releasing update codepush. additionally, sure you are releasing the same deployment your app is configured sync .update being displayed restart you're calling sync app start (e.g. within componentdidmount your root component), you need explicitly call notifyapplicationready app start, otherwise, plugin think update failed roll back.'ve released update ios my android app shows update it breaks be sure have different deployment keys each platform order receive updates correctlyimages dissappear installing codepush update your app is using react native assets system load images (.e. require(./foo.png) syntax), you must release assets along your js bundle codepush. follow instructions see to this. js bundle is being found running app against ios simulator default, react native doesn't generate js bundle running against simulator. therefore, you're using [codepush bundleurl], targetting ios simulator, may getting nil result. issue be fixed rn 0.22.0, only release builds. can unblock scenario right by making change locally.continuous integration / delivery addition being able use codepush cli \"manually\" release updates, believe it's important create repeatable sustainable solution contiously delivering updates your app. way, 's simple enough you /or team create maintain rhythm performing agile deployments. order assist seting a codepush-based cd pipeline, refer the following integrations various ci servers:visual studio team services - note: vsts has extensions publishing hockeyapp the google play store, it provides pretty great mobile cd solution general.travis ciadditionally, you'd more details what complete mobile ci/cd workflow look , which includes codepush, check this excellent article the zeemee engineering team.typescript consumption module ships *.d.ts file part its npm package, allows to simply import , and receive intellisense supporting editors (e.g. visual studio code), well compile- type checking you're using typescript. the part, behavior should work of box, however, you've specified es6 the value either target module compiler option your tsconfig.json file, just sure you set moduleresolution option node. ensures the typescript compiler look within node_modules the type definitions imported modules. otherwise, 'll an error the following trying import react-native-code-push module: error ts2307: cannot find module 'react-native-code-push'. project has adopted microsoft open source code conduct. more information the code conduct faq contact opencode@microsoft.com any additional questions comments."
}