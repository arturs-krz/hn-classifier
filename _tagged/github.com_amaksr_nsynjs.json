{
	"_id": "14406696",
	"site": "https://github.com/amaksr/nsynjs",
	"title": " Nsynjs â€“ JS engine with stoppable threads and without callback hell",
	"author": "kidstrack",
	"date": "2017-06-13T13:06:45.286Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript",
			"html"
		]
	},
	"content": "readme.md nsynjsnsynjs is javascript execution engine + state machine allows write javascript code without callbacks, execute in synchronous manner.nsynjs has following unique features:pseudo-threads are executed synchronously that be gracefully stopped,asynchronous operator, compilation transpilation required, need mark functions '*', async await keywords, dependant promises.compatible nodejs all browsers, including internet explorer.nsynjs is written es2015 does require dependencies. supports of features es2015, with limitations ( below). it works accepts function pointer an input parameter, performs following: parses code input function, builds few internal structures, such :an internal tree structure operators expressions, represents code input function,hash array local variables names, were defined input function using var statement, \"compiles\" each operator expression modifying source operator changing references local variablescreating internal function contain modified code creates execution context contains local variables, execution stack program counters, other information, is necessary order represent latest state, to stop resume execution. executes structure operators (code) against execution context (data). nsynjs can write code this: var =0; while(<5) { wait(1000); // <<-- long-running function callback console.log(, new date()); ++; }or this: function getstats(userid) { var res; try { res = { // <<-- expression few long-running functions, evaluated after another friends: dbquery(\"select * firends where user_id = \"+userid).data, comments: dbquery(\"select * comments where user_id = \"+userid).data, likes: dbquery(\"select * likes where user_id = \"+userid).data, } } catch(e) { res = { error: e } } return res; } to startstep 1. nsynjs node.js:npm install nsynjsvar nsynjs = require('nsynjs');note: latest version examples documantation files are available this github repository.npm package is updated when changes are made core library files. browser:<script src=\"nsynjs.js\"></script>step 2. wrap functions callbacks nsynjs-aware wrappers promises all asynchronous functions return promises, can skip step. some functions are returning results via callbacks, can either promisify , or wrap nsynjs-aware wrapper.here is example wrapper settimeout function: var wait = function (ctx, ms) { settimeout(function () { ctx.resume(); // <<-- resume execution nsynjs pseudo-thread, referred ctx }, ms); }; wait.nsynjshascallback = true; // <<-- indicates nsynjs should stop wait calling functionanother example - wrapper jquery's getjson(), can return data throw exception to nsynjs-executed code: var ajaxgetjson = function (ctx,url) { var res = {}; // <<-- results be posted to nsynjs via method this object var ex; // <<-- possible exception $.getjson(url, function (data) { res.data = data; // <<-- capture data callback, }) .fail(function(e) { ex = e; // <<-- capture exception }) .always(function() { ctx.resume(ex); // <<-- resume pseudo-thread }); return res; }; ajaxgetjson.nsynjshascallback = true; // <<-- indicates nsynjs should stop wait evaluating functionq: promises nsynjs-aware wrappers?many async functions already promisified versions, you just them your synchronous code.however, you to able stop pseudo-threads gracefully with proper cleaning, should nsynjs-aware wrappers, they provide mechanism terminate active underlying functions (e.g. terminate settimeout timer cleartimeout).more wrapperswrappers included nsynjsstep 3. write synchronous codeput synchronous code function: function mytestfunction1() { var =0; while(<5) { wait(nsynjsctx,1000); // <<-- reserved variable nsynjsctx is reference current pseudo-thread console.log(res, date()); ++; } return \"mytestfunction1 finished\"; } you functions return promises, can use like : var req = window.fetch(url).data; this example window.fetch() return pending promise. nsynjs check returned object is promise, if yes, will wait until promise is resolved rejected. once promise resolves, 's value is assigned 'data' propery an object, is returned the caller. promise rejects, will trigger exception thecaller.promises also chained: var text = window.fetch(url).data.text().data;step 4. execute execute function via nsynjs engine:nsynjs.run(mytestfunction1,null, function (ret) { console.log('done :', ret);}); result look this:=0 sun dec 25 2016 12:25:41 gmt-0700 (mountain standard )i=1 sun dec 25 2016 12:25:42 gmt-0700 (mountain standard )i=2 sun dec 25 2016 12:25:43 gmt-0700 (mountain standard )i=3 sun dec 25 2016 12:25:44 gmt-0700 (mountain standard )i=4 sun dec 25 2016 12:25:45 gmt-0700 (mountain standard )done : mytestfunction1 finishednsynjs referencevar ctx = nsynjs.run(mytestfunction1,obj, param1, param2 [, param3 etc], callback) (function, be called execute function synchronously)parameters:mytestfunction1: pointer a function needs be executed synchronouslyobj: object will accessed via \"\" in mytestfunction1 ( be null)param1, param2, etc - number parameterscallback: function call once mytestfunction1 is finished.returns:pseudo-thread execution contextpseudo-thread execution context referencepseudo-thread execution context is available inside nsynjs-executed code via predefined variable nsynjsctx. use inside nsynjs-aware wrapper functionsctx.resume ([exception])wrapper function should always call to indicate all callbacks are done, that pseudo-thread may continue.exception: optional exception be thrown to nsynjs-executed codectx.setdestructor (func)set destructor function, will called pseudo-therad is terminated.func: function will the cleanup (e.g. abort pending xhr request, call cleantimeout)ctx.setdonotwait(true) notifies nsynjs engine, wrapper is going call slow function callback, thatexecution the caller may continued.supported js featuresvar ... then ... [else...]while ... while(;;)for(var ;;)(.. in ..)(var .. ..)switchbreak [label]continue [label]returnexpr1 ? expr2 : expr3try ... catchthrowtypeofclosures supportedconstlet ... ofarrow functions limitationsoperators are executed via nsynjs should be separated semicolon.nsynjs is able execute native functions callbacks, such array.map, array.foreach(). in many cases can done running polyfills via nsynjs. please 'browser-array-map-polyfill.html' an example.under hood some function is executed via nsynjs.run(somefunc,...), nsynjs check somefunc.synjsbin property exists. property holds tree- structure represents code somefunc, is required nsynjs run. parsing/compiling is done once per function pointer.whe nsynjs parses code function, also parses nested function definitions. nested functions have stub body valid somefunc.synjsbin property, they intended fail called directly.instead, should be called nsynjs-executed code. nsynjs executes code encounters function call, checks type function is called. could 3 types:function someotherfunc.synjsbin property defined: functions executed synchronous manner nsynjs.function without someotherfunc.synjsbin property defined someotherfunc.nsynjshascallback property defined: means someotherfunc is nsynjs-aware wrapper, nsynjs should stop wait untill ctx.resume() is called wrapper.without someotherfunc.nsynjshascallback property defined: functions are executed immediately.performance considerationsnsynjs tries optimize internal structure packing many elements possible each internal function. example, consider following code: (i=0; <arr.length; ++) { res += arr[]; }since does have function calls it, will packed one internal function: .execute = function(state) { (state.localvars.=0; state.localvars.<arr.length; state.localvars.++) { state.localvars.res += state.localvars.arr[state.localvars.]; } }this function be executed almost fast native code.however, some function is called inside code, is generally way find type that function compile , therefore nsynjs evaluate such expressions piece a .for example, following code not optimized:var n = math.random() will split following internal functions:.execute = function(state) { return math}...execute = function(state,prev) { return prev.random}...execute = function(state,prev) { return prev()}...execute = function(state,prev, v) { return state.localvars.n = v}"
}