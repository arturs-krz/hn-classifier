{
	"_id": "14451504",
	"site": "https://github.com/fvgs/commandir",
	"title": " Commandir 1.0.0 Released â€“ Effortless mkdir and rmdir for Node.js",
	"author": "fvargas",
	"date": "2017-06-13T13:05:04.319Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md commandir mkdir rmdir just the functions are idempotent, you won't an error trying create directory already exists trying remove that doesn't.mkdir creates intermediate directories you don't to!mkdir rmdir always tell exactly directories were created deleted your program clean after itself it aborts later its execution. is made especially easy the fact both functions share consistent api allowing to pass output one the input the !installyarnyarn add commandirnpmnpm install --save commandirmkdir (dirs)takes single argument argument is either single path given a string an array such strings.returns promise success, promise resolves an array strings holds paths all directories were created. no directories were created, resolves an empty array. error, rejects an object the form {err, dirs}, where err is error dirs is array (possibly empty) all directories were created before error occurred. following example makes of async/await, then() catch() be used preferred:const {mkdir} = require ('commandir')async function makesomedirs () { try { /** * dirs be array the directories were created. * means value be of following, depending * which directories already existed * (note: ordering within array is guaranteed) * * ['', 'just/', 'just//dir'], ['/one', '/one/dir'], ['/one/dir'], [] */ const dirs = await mkdir ('/one/dir') // same above, takes account three strings const dirs2 = await mkdir (['/is/', 'this/is/second', 'something/else']) } catch ({err, dirs}) { /** * dirs is like dirs above, contains directories * were created before error occurred */ }}rmdir (dirs)takes single argument argument is either single path given a string an array such strings.returns promise success, promise resolves an array strings holds paths all directories were deleted. no directories were deleted, resolves an empty array. error, rejects an object the form {err, dirs}, where err is error dirs is array (possibly empty) all directories were deleted before error occurred.note: rmdir does delete intermediate directories following example makes of async/await, then() catch() be used preferred:const {rmdir} = require ('commandir')async function deletesomedirs () { try { /** * dirs either the singleton array ['/one/dir'] the * directory was deleted, an empty array the directory * did exist */ const dirs = await rmdir ('/one/dir') /** * same above, takes account three strings. * thus, dirs2 may from 0 3 elements * (note: ordering within array is guaranteed) */ const dirs2 = await rmdir (['/is/', 'this/is/second', 'something/else']) } catch ({err, dirs}) { /** * dirs is like dirs above, contains directories * were deleted before error occurred */ }}cleanup example's nice litter user's filesystem unnecessary directories your program crashes, fails complete, is aborted. fortunately, commandir makes super easy your program clean after itself! clarity, error catching this example has been omitted. in almost use cases (including one), should catching errors.const {mkdir, rmdir} = require ('commandir')async function cleanupexample () { const dirs = await mkdir ('lets//some/dirs') try { throw error ('oops... is unrecoverable error') } catch (err) { // 'd better clean those dirs instead leaving // on user's filesystem eternity! rmdir (dirs) }}"
}