{
	"_id": "14457808",
	"site": "https://github.com/ncthis/saul",
	"title": " Dynamic unit test generation for pure JavaScript functions",
	"author": "lunarcave",
	"date": "2017-06-13T13:05:03.981Z",
	"tags": {
		"categories": [
			"opensource",
			"javascript",
			"unit-testing",
			"pure-function"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md sauldynamic unit test generation pure javascript functions. is ?saul likes generate tests your pure functions you don't feel writing yourself.suppose you a simple function this.function shouldcallsaul(threatlevel) { (threatlevel === 'imminent') { return true; } return false;} now, got problem. needs be tested. writing test describe it is fine - your test file be longer the function itself. a problem? 'm happy you. 're better most us. the rest us - better call saul.imagine you just leave comment in file ...// @t \"should call saul the threat is imminent\" shouldcallsaul('imminent') equals true// @t \"should call saul threat is imminent\" shouldcallsaul('nodanger') equals false... it'll dynamically generate tests you you run test framework? (ex: mocha). , in shell, 's it does. fully tested pure function now like:// @t \"should call saul the threat is imminent\" shouldcallsaul('imminent') equals true// @t \"should call saul threat is imminent\" shouldcallsaul('nodanger') equals falsefunction shouldcallsaul(threatlevel) { (threatlevel === 'imminent') { return true; } return false;} more it ?calls-spychecks whether test spy is called// @t \"reads file\" getfilecontent('fakefilepath', 'spyfoo') calls-spy truecalls-spy-checks whether test spy is called the expected value// @t \"reads file\" getfilecontent('fakefilepath', 'spyfoo') calls-spy- fakefilepathcontains-domchecks whether given emmet expression exists within generated dom// @t \"has div\" list({items: [1, 2]}) contains-dom li.item{1}containschecks whether output contains expected value// @t \" concat\" concatanate('string1', 'something els') contains 'string1'deep-equalchecks whether expected value is deep equal actual value// @t \"assigns correctly\" myassign({ foo: 1 }, { foo: 2}) deep-equals { foo: 2 }equalschecks whether expected value is equal the actual value// @t \" sum\" sum(1, 2) equals 3is-checks whether expected value is equal the actual value. (opposite equals)// @t \" sum\" sum(1, 2) is- 4matches-domchecks whether given emmet expression matches generated dom// @t \"has div\" foospan({children: 'bar'}) matches-dom span#foo{bar}throwschecks whether invokation throw.// @t \"throws null engine\" executetest({engine: null}) throws error more! : extending saul.extending saul engines are \"comparator\" the tests.// @t \"has pill\" thumbnail({isnew: true}) contains-dom div#foo{} ===> contains-dom// @t \"reads file\" getfilecontent('fakefilepath', 'spyfoo') calls-spy- fakefilepath ===> calls-spy-// @t \"throws null engine\" executetest({engine: null}) throws error ===> throws are handled the file that name src/engines. (example: src/engines/contains-dom.js) \"engines\", are responsible generating tests. , as long you build custom engine - can pretty much test anything. default engines do few cool things of box. (check src/engines/ directory). can always write own engines put in customenginesdir defined .saulrc.installation1. install saul a dev dependency: yarn add --dev saul2. create .saulrc the root.example:{ \"fileglob\": \"src/**/*.js\", // files contain saul comments \"customenginesdir\": \"./src/custom-saul-engines\" // optional: dir where will put custom engine .js files}3. invoke saul your test.mocha/jasmine you some mocha tests already, npm test look : mocha src/**/.js. simple add saul's bin (node_modules/.bin/saul) right the end:mocha lib/*.test.js\" node_modules/.bin/sauljestsince jest requires regex pattern test files, will to create file a single file a require, will matched your jest regexpattern.example:// saul-runner.test.jsrequire('saul');note: you your tests file inside __tests__ directory, sure put file .usage babel transformation you apply your tests be inherited saul you run tests. you're running babel, will include anything you define your local .babelrc. an instance, you to feed babel-transformed files mocha, will invoke mocha mocha --compilers js:babel-register. can simply add saul the end the command. (mocha --compilers js:babel-register node_modules/.bin/saul) - things just .examples give read through repo. saul is tested saul! contributionsplease! here are som todos need being done. more engines! ( you like contribute engine, please a at engine files src/engines) documentation writing engines. extending parsers fixtures better error handling engines tests existing engines"
}