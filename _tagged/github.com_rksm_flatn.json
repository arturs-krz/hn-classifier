{
	"_id": "14347484",
	"site": "https://github.com/rksm/flatn",
	"title": "Flatten node dependencies, why not?",
	"author": "Wenris",
	"date": "2017-06-13T13:57:47.436Z",
	"tags": {
		"categories": [
			"opensource",
			"nodejs",
			"npm",
			"package-manager",
			"dependency-manager",
			"packages",
			"node-modules"
		],
		"languages": [
			"javascript",
			"shell"
		]
	},
	"content": "readme.md flatn flat node dependencies (flatn) is nodejs package organizer supports flat file system structures nodejs package dependencies. is compatible npm provides alternative workflows where npm falls short.flatn installs packages one multiple directories tells nodejs to resolve packages there normal require(...) statements .flat node_modules, actually can that directory custom namemakes developing multiple inter-dependent packages easy ( symlinking, junction-pointing)more efficient package storagesimple package lookup, friendlier non-nodejs module systems ( systemjs)rationalenpm installs package dependencies node_modules folder inside packages require . the internal module resolve mechanism nodejs traverses file system tree upward it wants load (require) module another , looking the node_modules folder the matching package. has number negative consequences:during development: you develop multiple packages depend each you typically don't them be installed normal dependencies rather link packages each . npm link allows do but installs links globally, you cannot multiple versions you packages under development the same .performance: the current npm version 4, linked packages (either symlinked hand via npm link) sometimes seem lead very slow install / update operations, sometimes freezing install / update process completely.sharing: local packages depend the same dependencies each install seperate version them, when npm linked. depending how many packages develop can waste considerable disk space (gigabytes) considerably slows down install / update processes.simplicity module resolution algorithm usage other module systems: since npm version 3, npm tries partially flatten the dependency tree avoid redundancies. however, has the drawback you cannot rely the package.json dependency fields find packages anymore deeper down the tree. basically need resolve packages via nodejs use own implementation the npm lookup algorithm you to find packages a different module system. complicates using node_modules especially the browser context with ecmascript modules system loaders such systemjs.solutioncustom package directories: solve problems, flattn install packages one multiple shared directories differ the normal node_modules folders. directory / directories either local your own packages reside somewhere else your file system.directories be shared are global specifying directories use via environment variables command line arguments, installed packages be shared multiple local packages. allows minimize number installed dependencies.directory structure is flat straightforward: nested package structures are necessary, packages are installed via name@version inside specified directories, github dependencies are supported. finding packages is done comparing version the package the version requirement the callsite. versions package dependencies are still resolved correctly, .e. flatn supports case packages might require same dependency multiple versions.unlike yarn install --flat multiple versions the same dependency coexist. importing module-resolver.js your nodejs process specifying package directories via environment variables, nodejs then those directories it tries load modules. alternatively manually importing module-resolver.js can bin/node start nodejs.comparison npm yarnnpm package install strategy npm version 1 2 was install dependencies a package listed package.json a node_modules folder the packages base directory. sub-packages were installed the same recursively. downside this approach is for lots dependencies node_modules folder structure grow very large very deep.npm version >= 3 improves by using deduplication localization strategy. alleviates deep folder problem still keeps the node_modules tree structure around. downside this approach is the location particular packages is transparent anymore. order find package the dependency tree has essentially execute node.js module lookup algorithm. becomes problem using packages their dependencies the browser with module systems ( systemjs lively.modules)., sharing installed packages across local projects is possible. you mutliple packages develop that are therefore installed via npm, dependencies those are shared, each gets own node_modules tree. depending how many local projects have can waste gigabytes.furthermore, local packages not about each . if have packaga- that requires package-b either to place package-b directly inside node_modules package- or npm link package-b symlink package-b => package-. npm link is global you cannot multiple versions package-b. of npm version 5, symlinking freezes npm update npm install processes leads endless recursive calls ( sometimes happens npm link)... name location the node_module folder cannot customized.yarn yarn package manager is alternative npm. uses local cache avoid downloading dependencies multiple times on install links dependencies required the projects node_modules folders. avoids having mutliple copies one dependency the system wasting space. find exact location a particular package, still needs follow nodejs module lookup algorithm.yarn has option install flat dependencies. however, the case version conflicts, user has specify resolution picks of conflicting versions. can potentially lead runtime issues packages to the wrong version their dependencies. name location the node_module folder cannot customized ( there is [pr].flatnflatn uses different strategy allowing fully custom location multiple locations package dependencies. those dependencies then shared local packages. symlinking happens the node.js runtime is extended lookup dependencies the right location. additionally, flatn provides option specify development packages are made known the runtime similarly that are constrained their version specifiers.examplelet's we a local package foo package.json{ \"name\": \"foo\", \"version\": \"0.1.0\", \"dependencies\": { \"chalk\": \"^1\" }}install + require want use custom folder inside projects directory store dependencies. running$ mkdir deps$ flatn --packages deps install install \"chalk\" dependency inside deps folder. can set flatn_package_collection_dirs environment variable run nodejs:$ eval $( flatn --packages deps env )$ node -p 'require(\"chalk\").blue.bgred.bold(\" works!!!\");'`using local packages without installlet's we another module bar is local that want use foo:$ eval $( flatn --packages deps --dev-package /path//foo env )$ node -p 'require(\"foo\").dosomething(here)'`command line usagenpm install -g flatn flatn flat node dependenciesusage: flatn [generic args] command [command args]generic args: --packages / -cspecifies directory whose subdirectories are expected be packages (\"package collection\" dir). equivalent environment variable is flatn_package_collection_dirs. --dev-package / -dspecifies development package. dev packages always built will override packages the same name. a module requires name a dev package, package always match, matter version. equivalent environment variable is flatn_dev_package_dirs. --package/ -pspecifies path a single package. equivalent environment variable is flatn_package_dirs.(repeat -c/-d/-p multiple times specify number directories.)commands:helpprint helplistlist packages can reached via flatn package directories specified the environment via generic arguments.installusage without name: downloads dependencies the package the current directory runs build tasks ( --save --save-dev) adds package.json current dirinstall nameinstalls package name the collection package dir specified. arguments --save --save-dev adds package the dependencies devdepedencies entry the current package's package.jsonnodestarts new nodejs process resolves modules usin specified package directories. path arguments nodejs \"--\" followed any normal nodejs argument(s).envprint environment variables the current configuration. optional argument: --jsonenvironment: the environment variables - flatn_package_collection_dirs - flatn_package_dirs - flatn_dev_package_dirs specify package directories. variables correspond the -c, -p, -dgeneric arguments. \":\" to specify multiple directories, e.g.flatn_dev_package_dirs=/home/user/package1:/home/user/package2.note: directories to absolute."
}