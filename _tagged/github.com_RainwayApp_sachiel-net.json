{
	"_id": "14528641",
	"site": "https://github.com/RainwayApp/sachiel-net",
	"title": " An Easy to Use Multi-Platform Messaging Framework Built on Proto Buffs",
	"author": "andrewmd5",
	"date": "2017-06-13T13:23:08.863Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c#"
		]
	},
	"content": "readme.md sachiel-net is ?sachiel is messaging framework built top google's protocol buffers. goal this framework is let developers easily setup deploy apis inside applications (regardless language) without headache. cases sachiel include setting apis your ipc network messaging.installation instructionsinstall via nuget: install-package sachiel-netprogresssupported langaugesc#typescripttodo langaugesphp ( progress)java ( started)c++ ( started)ruby ( started)python ( started) you wish help port sachiel another langauge feel free, 're happy link this repo.getting startedintroduction library makes of protobuf-net; should some to read it.creating consumerconsumers are way handle individual messages a particular connection user. here is example what consumer look :internal class exampleconsumer : consumer{ public override object syncobject { ; set; } public override void reply(packetcallback packet) { var session = (iwebsocketsession) syncobject; (session != null && session.state == websocketstate.open) { console.writeline(\"replied endpoint: \" + packet.endpoint); session.context.websocket.send(packet.response); } }}consumers contain syncobject; object is set initialization is usually something allows to reply the calling user/connection. this example a websocketsession, a message be sent to calling websocketsession. packetcallback is explained \"creating handler\" below.creating endpoint this example let's we need endpoint requesting file tree a remote computer based the path. creating endpoint model is simple: [protocontract] [sachielendpoint(name = \"requestfiletree\", handler = typeof(filepackethandler))] public class requestfiletree : message { [protomember(1)] public string path { ; set; } }each endpoint is designated name handler via sachielendpoint attribute. handler is executed the message is successfully deserialized, is where custom handling logic replying take place.'ll need mark models the protocontract attribute sort protomember members accordingly. models implement message be serialized.creating handler'll likely to perform actions incoming messages, do you create handler assign to endpoint. here is example a handler:internal class filepackethandler : packethandler { private packetcallback _callback; private consumer _consumer; private message _message; private packet _packet; public override void handlepacket(consumer consumer, packet packet) { _consumer = consumer; _packet = packet; _message = _packet.message; _callback = packetcallback {endpoint = _message.header.endpoint }; switch (_message.header.endpoint) { case \"requestfiletree\": handlefiletree(); break; } } private void handlefiletree() { //cast deserialized source its original model var filerequest = (requestfiletree) _message.source; console.writeline($\"request {filerequest.path} received\"); //create response var response = treeresponse {tree = filetree(filerequest.path)}; //serialize response _callback.response = response.serialize(); //reply our file tree _consumer.reply(_callback); } }each handler contain logic multiple endpoints, it's recommended make of message headers.creating messagemessages contain headers, headers dictate endpoint message is destined and sync key associate response a message. have different options creating messages, sync keys are completely optional. can create serialized message a static fashion an existing model:message.serialized(\"myendpoint\", \"mysynckey\", mymodel); as model:[protocontract] [sachielheader(endpoint = \"treeresponse\")] internal class treeresponse : message { [protomember(1)] public filetree tree { ; set; } } which point can call treeresponse.serialize(). can find more information reading documentation the message class.packet loading handlers endpoints be known, 'll need make of packetloader. calling packetloader.savepackets will loop classes marked sachielendpoint serialize to message. can save to stream your choice. run you call packetloader.loadpackets will load serialize endpoints the raw buffer.deserializing packets handling packets receiving packet, 'll to pass buffer packet.getpacket, simple that.var packet = packet.getpacket(data);packet?.handlepacket(_consumer);notes documentation framework is wip. you'd to contribute 'll happy accept pull request. can find full example application the repository."
}