{
	"_id": "14489866",
	"site": "https://github.com/danielshaya/rxjournal",
	"title": "If you use RxJava use must see this",
	"author": "danielshaya",
	"date": "2017-06-13T14:10:08.041Z",
	"tags": {
		"categories": [
			"opensource",
			"rxjava",
			"chronicle",
			"java",
			"journal",
			"memory-mapped"
		],
		"languages": [
			"java"
		]
	},
	"content": "readme.md rxjournalnote readme needs be updated latest version code will done shortly.rxjounal supports reactive implementations just rxjavarxjournal augments popular rxjava library addingfunctionality record replay reactive streams.downloading projectmavenrxjournal is maven project you clone project build the usual .the intention is this project make way maven central ( in progress).download jar to releases section the project. each release will an uber jar you download the rxjournal classes all dependencies.once downloaded can test it works running:java -cp ./rxjournal-x.x.x.jar org.reactivejournal.examples.helloworld.helloworld primary motivations behind rxjournal1. testingtesting is primary motivation rxjournal. rxjournal allows developers black box test code recording inputs outputs and of programs. obvious case are unit tests where rxjournal recordings be used createcomprehensive tests ( helloworldtest an example). example makes ofrxvalidator allows unit tests compare results against previouslyrecorded results the journal.another powerful case is enable users replay production data test systems. simply copying the journal file a production system replaying or part the file a test system exact conditions the primary system be reproduced.2. remote connectionsrxjournal be recorded one jvm can replayed ( real- if required) one morejvms provided have access the journal file location. remote connection either read the beginning the recording just start liveupdates the recorder. remote connection ( 'listener') optionally write to journal effecting two conversation rpc. can multiple readers writers thejournal.rxjournal uses chronicle-queue ( memory mapped file solution) serialisation meaning the process moving data one jvm another is exceedingly efficient can achieved single digit micro seconds. you need pass data between jvms the same machine is only most efficient to so you also provide with full recording the data istransferred between jvms.3. slow consumers (handling pressure) you a fast producer you 't slow down your consumer 't keep there are few options available your system. often end implementing strategies hold buffers data memory allowing consumer catch eventually. problem those sort strategies are , if processcrashes lose the data your buffer. therefore you need consume fast data atransactional manner will be option. , you may run of memory thebuffers really big. the very least will probably need run jvm a largememory setting many inefficient. latency sensitive applications willput pressure the gc will be acceptable. more this topic below the examples sectiondesign goalsrecording the journal is transactional .e. data be lost theprogram crashesrecording playback is fast it won't slow down host program.recording playback be achieved without gc overheadrxrecorder be easily added ( even retro-fitted) any rxjava projectquick startcreating journal rxjournal is created follows:rxjournal reactivejournal = rxjournal(string dir); directory is location where serialised file be createdrecording reactive streamrxrecorder allows rxjava observable/flowable be journaled disk using record function:rxrecorder reactiverecorder = reactivejournal.createrxrecorder();rxrexcorder.record(observable) notes threading faq below.playing a reactive streamrxplayer is used playback journal recording:rxplayer reactiveplayer = reactivejournal.createrxplayer();reactiveplayer.play( playoptions()); are number options can configured using playoptions. include filtering stream time stream. playback speed also controlled using configuration.viewing contents a journalrxjournal is created stored disk using low latency chronicle-queue library. data be examined plain ascii using writetodisk function:reactivejournal.writetodisk(string filename, boolean printtosdout)putting together helloworldfull code example code helloworldapp. package org.reactivejournal.examples.helloworld; import io.reactivex.flowable; import io.reactivex.observable; import org.reactivejournal.impl.playoptions; import org.reactivejournal.impl.reactivejournal; import org.reactivejournal.impl.reactiveplayer; import org.reactivejournal.impl.reactiverecorder; import java.io.ioexception; /** * simple demo program */ public class helloworld { public static void main(string[] args) throws ioexception { //create reactiverecorder delete previous content clearing cache rxjournal reactivejournal = rxjournal(\"/tmp/demo\"); reactivejournal.clearcache(); flowable<string> helloworldflowable = flowable.(\"hello world!!\"); //pass flowable the reactiverecorder will subscribe it record events. rxrecorder reactiverecorder = reactivejournal.createrxrecorder(); reactiverecorder.record(helloworldflowable); rxplayer reactiveplayer = reactivejournal.createrxplayer(); observable recordedobservable = reactiveplayer.play( playoptions()); recordedobservable.subscribe(system.::println); //sometimes useful see recording written a file reactivejournal.writetofile(\"/tmp/demo/demo.txt\",true); } } results running program be seen below:[main] info org.reactivejournal.impl.reactivejournal - deleting existing recording [/tmp/demo]hello world!![main] info org.reactivejournal.impl.reactivejournal - writing recording dir [/tmp/demo/demo.txt][main] info org.reactivejournal.impl.reactivejournal - valid12017-05-19t08:52:27.156hello world!![main] info org.reactivejournal.impl.reactivejournal - complete22017-05-19t08:52:27.157endofstream{}[main] info org.reactivejournal.impl.reactivejournal - writing dir completefaq types data be serialised rxjournalitems can serialised rxjournal are those can serialised chronicle-queue. are:autoboxed primitives, strings byte[]classes implementing serialisableclasses implementing externalizableclasses implementing marshallable chronicle queue docs full documentationflowable observable?rxjava2 is divided 2 types streams flowable support pressure observable do support pressure. terms recording, rxrecorder supports both flowable observable. subscriptionis made either the data recorded is serialised rxjournal. the hand, rxplayer returns observable by definition will no pressure worry .the consumer this observable process events their own speed backed the guarantee every item has been recorded the journal. you only latest event ( events are replaceable) can play observable a flowable gives the latest item. will a fullrecord the complete stream events whether were dropped not. can record processed event the rxjournal again under different filter. you arecord the events were actually processed.rxjournal the critical path as another subscriber are 2 ways might to set your rxjournal.record observable/flowable input rxjournal then your processor subscribe rxjournal its stream events. effectively inserts rxjournal the critical path your program. will certainly the setup you are using rxjava handle pressure. is demonstrated the example program helloworldapp_journalplaythrough rxjournal a second subscriber your observable input data. has benefit keeping functions the same thread. might the setup you are using rxjournal record data testing purposes. might to the connectableobservable paradigm cold observables you probably don't rxrecorder kicking off connection until the connections been setup. is demonstrated the example program helloworldapp_jounalasobserverplay stream actual or fast rxplayer play two modes:actual_time plays the stream preserving time gaps between events. isimportant back testing reproducing exact conditions unit tests.fast plays events soon they are recieved. this you are usingrxjournal remote connections when using rxjounal deal back pressure. rxjournal used a low latency environment intention is rxjournal support low latency programs. two main features allow this are:dedicating cpu core rxplayer using fast setting described above that don't any context switching.setting playoptions.using() that is allocation new events. should enableprograms be written have minimal gc impact, critical reliable low latency.examples are few core example applications the code work through typical cases are worth considering more detail.helloworldapp_journalplaythrough program demonstrates to set a simple 'play through' example. have input flowable a stream bytes. are recorded the journal rxrecorder. then subscribe rxjournal rxplayer giving an observable bytes are processed the bytestowordsprocessor. output the processor is recorded rxjournal we a full record all input outputs the program.note we recordasync rather record otherwise wouldblock main thread until the event stream had completed recording only would proceed process items. although this trivial example's hard see effect has encourage to play the interval_mssetting see happens you increase delay something noticeable. try change recordasync async you see effect the threading. then display results the program stdout well writing a file. recording be valuable it comes writing unit test bytestowordsprocessor we'll in another example.helloworldapp_journalasobserver is very similar the last example except we processes everything the same thread. can this rather the bytestowordsprocessorsubscribing rxjournal subscribes directly the observable<byte> input. is less intrusive to insert rxrecorder your project ofcourse not handle back pressure problem.helloworldtest example demonstrates to rxrecorder a unit test. journal file created the previous examples is used input test bytestowordsprocessor. results bytestowordsprocessor are fed rxvalidator compares output the output was recorded the journal reporting differences. have effectively black boxed inputs outputs bytestowordsprocessor can confident any changes make the processor not break existingbehaviour.helloworldremote example is designed show rxjournal be used tranfer data between jvms.start helloworldapp_journalplaythrough increase interval_ms 1000. run helloworldremote.helloworldremote has been configured this option: playoptions().filter(helloworldapp_jounalasobserver.input_filter).playfromnow(true); playfromnow means it only consume current events depending how long gap have between starting 2 programs will output looks something this:fast producer slow consumer these example programs deal the situation where find ourselves afast producer slow consumer. all example setup scenario fastproducerslowconsumer where producer emits long values every millisecond. also create consumer processes long values a variable delay is significantly slower the rate they are being produced. other words have classic fast producer slow consumer scenario needs be handled applying pressure. following example programs all been written 'solve' back pressureproblem have created.rxjavabackpressurefirstly let's consider rxjava handles pressure of box. quick reminder, rxjava2 code was split 2 sections:observable - back pressure. when pressure is an issue thecode is more efficient having deal this complication.flowable - handles pressure. when have address back pressure issue.clearly will be looking the flowable part rxjava2 this example. example program demonstrates the 5 backpressurestrategy modes handle pressure.buffer will, its name implies, hold items an -memory buffer waiting availablility the consumer process . this is choice handling spikes event traffic where consumer eventually able catch with producer. problems using strategy are: the program crashes events the buffer be lost. if program terminates normally careful attention has o paid draining buffer. the queue builds too much jvm run of memory crash. forces program run a large memory setting hold buffer can a problem programs where latency is issue especially coupled the next point. program not able be designed an allocation-free manner. everyitem have be created a '' object will put pressure the gc.latest drop deal back pressure making slow consumer keep with fast producer. is done dropping events the stream. is good choicewhere events the stream are replaceable you don't need process every item. problems this straegy are: you to test program against the values the stream see you might better results processing more events. with buffer can't write gc friendly code.error missing deal back pressure putting program an error state soon back pressure is encountered. is useful you don't expect back pressure you the program error encountering pressure.rxjournalbackpressurebuffer this program set rxjournal handle pressure the buffer mode solving the problems we saw the standard rxjava buffer mode. fastproducer be created the backpressurestrategy.missing we don't expect the producer ever slowed down the consumer, in case is rxrecorder. consumer, rather subscribing directly the fastproducer, subscribes rxplayer. note rxplayer.play returns obserable there is need it handle pressure bakc pressure has already been applied using rxjournal thebuffer.lets at problems backpressurestrategy.missing see they are solved. if program crashes everything written rxjournal is safe. events be stored disk you just restart program carry consuming queue the point crashed. there is os/machine level issue is possible a few messages might lost are waiting be written disk. that is problem should sure replication is setup your system. is in-memory buffer there is need run extra heap memory the programcertainly won't run memory of rxjournal. you call rxplayer.play of the options is using. allows to pass theobject will used every event. means no objects be allocated if have millions items your stream. ( course you to hole reference theevent will need clone). addition those benefits will the ususal benefits using 'rxjornal' that will a full record the stream use testing you be able use remotejvms.rxjournalbackpressurelatest its name implies demo program shows how handle pressure using rxjournal rather buffer just the latest item the queue. you to is set the program exactly we did the previous examplerxjournalbackpressurebuffer rather the slow subscriber subscribing the observable comes rxplayer.play insert flowable inbetween. flowable is created backpressurestrategy.latest. code snippet the example below: //1. the stream events the rxplayer connectableobservable journalinput = reactivejournal.createrxplayer().play(options).publish(); //2. create flowable latest pressure strategy the rxjournal stream flowable flowable = journalinput.toflowable(backpressurestrategy.latest); //3. record output the flowable the journal (note different filter name) recorder.record(flowable, \"consumed\"); long starttime = system.currenttimemillis(); //4. slow consumer subscribes the flowable flowable.observeon(schedulers.io()).subscribe(onnextslowconsumer::accept, e -> system..println(\"rxrecorder \" + \" \" + e), () -> system..println(\"rxrecorder complete [\" + (system.currenttimemillis()-starttime) + \"]\") ); might noticed as as slow consumer subscribing the flowable makesure uses latest strategy also record values actaully consumer rxjournal. with plain rxjava implementation latest (without rxjournal) slow consumer sees latest updates the fast producer. however you rxrecorder ( in example) have: full record all events were emitted the fast producer. full record all events were actaully consumed the slow producer.both streams be played with rxplayer specifying appropriate filter the playoptions calling play. leads being ablse try following...rxjournalbackpressuretestingfasterconsumer this example experiment replaying event stream recorded rxjournal observing effects lowering latency the slowconsumer. have recording the fastproducer created whilst running rxjournalbackpressurebuffer. slowconsumer subscribes this using flowable backpressurestrategy.latest in provious example. we run the slowconsumer a latency 5ms get result:received [100] items. published item[100]received [200] items. published item[391]received [300] items. published item[791]received [400] items. published item[1175]received [500] items. published item[1560]received [600] items. published item[1946]received [700] items. published item[2340]rxrecorder complete [3909ms] slow consumer has managed consume 700 events. we reduce latency slowconsumer 3ms get result:received [100] items. published item[100]received [200] items. published item[265]received [300] items. published item[491]received [400] items. published item[719]received [500] items. published item[958]received [600] items. published item[1192]received [700] items. published item[1428]received [800] items. published item[1664]received [900] items. published item[2046]received [1000] items. published item[2288]rxrecorder complete [3666ms] slow consumer has managed consume 1000 events.whilst is trivial example 'll let imagination extend scenarios real world situations where sort ability replay data against realload be invaluable.acknowlegmentsspecial thanks my friend ex-collegue peter lawrey inspiring with chronicle libraries underpin rxjournal. those behind rxjava particular tomasz nurkiewicz his talks book opened eyes rxjava."
}