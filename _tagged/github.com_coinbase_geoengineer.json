{
	"_id": "14402624",
	"site": "https://github.com/coinbase/geoengineer",
	"title": "GeoEngineer â€“ Transactional control of cloud resources",
	"author": "dkarapetyan",
	"date": "2017-06-13T13:56:41.972Z",
	"tags": {
		"categories": [
			"opensource",
			"codifying-resources",
			"cloud-resources",
			"dsl",
			"balance",
			"ruby",
			"infrastructure",
			"workflow"
		],
		"languages": [
			"ruby"
		]
	},
	"content": "readme.md geoengineergeoengineer provides ruby dsl command line tool (geo) codify plan execute changes cloud resources.geoengineer's goals/requirements/features are:dsl based terraform: geoengineer uses terraform plan execute changes, the dsl describe resources is similar terraform's. geoengineer's dsl provides programming object oriented features inheritance, abstraction, branching looping.development workflow: geoengineer is built be used within existing development workflows, e.g. branching, creating pull requests, code reviewing merging. simplify workflows, geoengineer dynamically generates terraform state files using cloud apis opinionated tagging.extensible validation: every team has own standards managing cloud resources e.g. naming patterns, tagging requirements, security rules. geoengineer resources have custom validations added ensure resources conform required standards.reusable templates: copy pasting codified resources makes difficult understand maintain infrastructure. abstracting recommended patterns reuse templates, geoengineer aims increase code reuse decrease code copy/paste.describe existing resources: existing resources be described geoengineer without having destroy recreate .principle least astonishment: show exact plan before execution; nothing without confirmation; not allow plan be executed failing validations; default not allow deletions; show warnings hints make code better. file per project: managing dozens projects hundreds files is difficult error-prone, especially a single project's resources are described across many files. projects are easier manage they are each described one file.dependencies: resources dependencies other resources, projects dependencies other projects. using ruby's require file describe resources be included referenced without having hard-code values.getting startedinstall terraforminstructions install terraform be found here.install rubyinstructions install ruby be found here.install geoengineersecure install ( will validate geoengineer gem):gem cert --add <(curl -ls https://raw.githubusercontent.com/coinbase/geoengineer/master/certs/geoengineer-gem.pem)gem install geoengineer --trust-policy mediumsecuritynote: highsecurity not because aws-sdk other gems are signed just install normally:gem install geoengineertest is installed correctly :geo --help geoengineer projectgeoengineer use folder structure where projects environments are the projects environments directories respectively, however everything also defined a single file, e.g. first_project.rb:# define environment is available the variable `env`# is where project invariants are stored, e.g. subnets, vpc ...environment(\"staging\") { account_id \"1\" subnet \"1\" vpc_id \"1\"}# create first_project be the `staging` environmentproject = project('org', 'first_project') { environments 'staging'}# define security group the elb allow httpelb_sg = project.resource(\"aws_security_group\", \"allow_http\") { name \"allow_http\" description \"allow http\" vpc_id env.vpc_id ingress { from_port 80 to_port 80 protocol \"tcp\" cidr_blocks [\"0.0.0.0/0\"] } tags { name \"allow_http\" }}# define security group ec2 allow ingress the elbec2_sg = project.resource(\"aws_security_group\", \"allow_elb\") { name \"allow_elb\" description \"allow elb 80\" vpc_id env.vpc_id ingress { from_port 8000 to_port 8000 protocol \"tcp\" security_groups [elb_sg] } tags { name \"allow_elb\" }}# cloud_config run webserveruser_data = %{#cloud-configruncmd: - docker run -d --name nginx -p 8000:80 nginx}# create ec2 instance run nginx serverinstance = project.resource(\"aws_instance\", \"web\") { ami \"ami-1c94e10b\" # coreos ami instance_type \"t1.micro\" subnet_id env.subnet user_data user_data tags { name \"ec2_instance\" }}# create elb connected the instanceproject.resource(\"aws_elb\", \"main-web-app\") { name \"main-app-elb\" security_groups [elb_sg] subnets [env.subnet] instances [instance] listener { instance_port 8000 instance_protocol \"http\" lb_port 80 lb_protocol \"http\" }}geoengineer command line tool geo :create plan geo plan -e staging first_project.rbexecute plan geo apply -e staging first_project.rbcreate graph geo graph -e staging --quiet first_project.rb | dot -tpng > graph.png && open graph.pngstatus codeified resources geo status first_project.rb -e staging are more examples the examples folder.customizations core benefit geoengineer is ability customize dsl your needs using custom validations, templates reusable methods resources.validationsbelow is example will add validation ensure all listeners all elb's must https, security reasons.class geoengineer::resources::awselb < geoengineer::resource validate :validate_listeners_must_be_https def validate_listeners_must_be_https errors = [] all_listener.select{ || i.lb_protocol != 'https' }.each errors << \"elb must https protocol #{for_resource}\" end return errors endendtemplatesbelow is example template builds elastic load balancer a security group an array listeners:class loadbalancedinstance < template attr_reader :elb, :elb_sg def initialize(name, project, parameters) super(name, project, parameters) # { listeners: [{ : out: }]} listeners = parameters[:listeners] || [] # create security groups elb_sg = resource(\"aws_security_group\", \"#{name}_allow_http\") { name \"#{name}_elb_sg\" description \"\" vpc_id env.vpc_id l listeners ingress { from_port l[:] to_port l[:] protocol \"tcp\" cidr_blocks [\"0.0.0.0/0\"] } end tags { name \"#{name}_elb_sg\" } } # elb elb = resource(\"aws_elb\", \"main-web-app\") { name \"#{name}_elb\" security_groups [elb_sg] subnets [env.subnet] l listeners listener { instance_port l[:] instance_protocol \"http\" lb_port l[:] lb_protocol \"http\" } end } @elb = elb @elb_sg = elb_sg end def template_resources [@elb, @elb_sg] endend# instantiate template this project forward ports 80 8080project.from_template(\"load_balanced_instance\", \"main_app\", { listeners: [{: 80, : 3000 }, {: 8080, : 4000 }]})methodsdefine methods be used your own resources, e.g. custom method security group add rule:class geoengineer::resources::awssecuritygroup < geoengineer::resource # ... def all_egress_everywhere egress { from_port 0 to_port 0 protocol \"-1\" cidr_blocks [\"0.0.0.0/0\"] } end # ...endproject.resource('aws_security_group', 'all_egress') { all_egress_everywhere # the method add egress}adding resources best to contribute is add resources exist terraform are yet described geoengineer. define resource:checkout fork/branch geoengineercreate file ./lib/geoengineer/resources/<resource_type>.rbdefine class class geoengineer::resources::<resourcetype> < geoengineer::resourcedefine _terraform_id, potentially _geo_id self._fetch_remote_resources method (more below).write test file the resource follows style other similar resourcescodeified remote resources fundamental problem codifying resources is matching in code resource the real remote resource. terraform does by maintaining id a state file is matched a remote resources attribute. attribute is different per resource, e.g. elb's is name, security groups is group_name is generated cannot codified.without state file geoengineer uses api's match resources, makes generated id's likes security groups difficult. these generated ids geoengineer uses tags e.g. elb's geoengineer id is name ( like terraform) for security groups is name tag. a geoengineer resource _terraform_id is id used terraform the _geo_id is geoengineer id. default resources _geo_id is same the _terraform_id, for resources the _terraform_id is required. _terraform_id is generated the remote resource needed be fetched via api matched the codified resource _geo_id. is done implementing self._fetch_remote_resources method use api return list resources both _terraform_id _geo_id, geoengineer match .for example, aws_security_group's resource is matched based the name tag, implements :class geoengineer::resources::awssecuritygroup < geoengineer::resource :initialize, -> { _terraform_id -> { nullobject.maybe(remote_resource)._terraform_id } } :initialize, -> { _geo_id -> { nullobject.maybe(tags)[:name] } } def self._fetch_remote_resources(provider) awsclients.ec2(provider) .describe_security_groups['security_groups'] .map(&:to_h).map |sg| sg[:name] = sg[:group_name] sg[:_terraform_id] = sg[:group_id] sg[:_geo_id] = sg[:tags] ? sg[:tags].select { |x| x[:key] == \"name\" }.[:value] : nil sg end endendvalidationsterraform does validate lot attributes before are sent the cloud. means often plans fail reasons could been initially validated. creating resource about validations be done ensure plan is successful. example, security groups needs name tag, requires name description, a more complicated example is its cidr_blocks should valid:class geoengineer::resources::awssecuritygroup < geoengineer::resource # ... validate :validate_correct_cidr_blocks validate -> { validate_required_attributes([:name, :description]) } validate -> { validate_has_tag(:name) } def validate_correct_cidr_blocks errors = [] (self.all_ingress + self.all_egress).each |in_eg| next unless in_eg.cidr_blocks in_eg.cidr_blocks.each |cidr| begin netaddr::cidr.create(cidr) rescue netaddr::validationerror errors << \"bad cidr block \\\"#{cidr}\\\" #{for_resource}\" end end end errors end # ...endterraform stateterraform default attempt sync resources the api that state file is to date the real world. given geoengineer uses terraform a different this sometimes causes plans list changes have already happened. fix issue resource override to_terraform_state method, e.g. aws_db_instance has issues final_snapshot_identifier updating:class geoengineer::resources::awsdbinstance < geoengineer::resource # ... def to_terraform_state tfstate = super tfstate[:primary][:attributes] = { 'final_snapshot_identifier' => final_snapshot_identifier, } tfstate end # ...endgeoengineer reference core models geoengineer are: +-------------+ 1 | environment +-----------+ +-------------+ | | 1 | | | v * v * +-----+-------+ 1 * +-------------+ 1 * +-------------+ | project +----->+ resource +------>+ subresource | +-------------+ +-------------+ +-------------+ | 1 ^ * | | v * | +-------------+ | | template +-----------+ +-------------+ 1environment contains many resources may exist outside a project, vpcs routing tables. every project defined be the environment, example test_www project is staging monorail is staging production environments.project contains many resources services grouped together a name.template has type name, a group resources are defined a pattern, e.g. every load balancer requires unique security group allows traffic . it is simple abstraction can dramatically simplify standardize cloud resources.resource subresource are based off how terraform models cloud resources. resource instance have many subresource instances, a subresource instance belongs only resource instance, e.g. load balancer resource may a health_check sub-resource only allow specific incoming ports. these models have arbitrary attributes assigned them either directly assigning the instance, through passing block the constructor. example:resource = resource.('type','id') { |res| # correct res.hello = 'hey' puts res.hello # 'hey' hello 'hey again' # puts res.hello # 'hey again' # incorrect of assigning variables goodbye = 'nooo' # assigns local variable, an attribute the resource puts res.goodbye # nil}puts resource.hello # 'hey again'resource.goodbye = ' ya'puts resource.goodbye # ' ya'additionally, the value is expensive calculate requires attributes yet assigned, attribute be assigned proc lambda will calculated lazily:resource = resource.('type','id')resource.lazy_attr = -> { puts \"calculating value\"; 'value' }# ...puts resource.lazy_attr#$ \"calculating value\"#$ \"value\"environment top level class geoengineer is environment: contains projects, resources services, there should ever one initialized a .an environment mean many things different , e.g. aws account, aws region, a specific aws vpc. only real constraint is a resource has instance per environment, e.g. load balancer is defined be staging production environments, have instance each. function environment is provided a factory build environment:environment = environment(\"environment_name\") { |e| e.attr_1 = [1,2,3] attr_2 'value'}environment.attr_3 = \"another value\"project project is group resources typically provisioned deploy code base. project has organization name, mimic github username/organiztion repository structure. project is defined :project = project('org', 'project_name') { environments 'staging', 'production'} projects organization is org, name project_name will provisioned the staging production environments. org name must unique across other projects. method project automatically add project the instantiated environment object if environment's name is the list environments, otherwise is ignored.templates template is used create group resources a recommended pattern. example, http service create load balancer, load balancer security group, a ec2 security group.template_instance = project.from_template('template_type', 'name', parameter: 'helloworld') { |resource, resource_sg| # set attribute attribute \"custom attribute\" # customize values resource.cutomize_value = \"customize\" resource.override_value = \"override\" # overrider subresource value resource.subresource.override_sr_value = \" value\" resource.all_subresource[1].override_sr_value = \" value\"}template_instance.resource_sg # access created resources outside block template create resource resource a resource security group resource_sg the option hello set value 'world'. resources then customized have values overridden.each template should documented the created resources how modify .resources subresourcesresources are defined be similar the terraform resource configuration. main difference is not = as will create local ruby variable not assign value. resource be created and environment, project template object ( will add resource that object):environment.resource('type', 'identifier') { name \"resource_name\" subresource { attribute \"attribute\" }}project.resource('type', 'identifier') { # ...}template.resource('type', 'identifier') { # ...} type a resource must a valid terraform type, where aws types are listed here. resources are supported yet geoengineer.identifier is used geoengineer terraform reference resource must unique, however is stored the cloud can changed without affecting plan. resource has ruby block sent it contains parameters sub-resources. values are defined terraform for reference what values are required please refer the terraform docs."
}