{
	"_id": "14508872",
	"site": "https://github.com/selfrefactor/rambda",
	"title": " Rambda â€“ Faster alternative to Ramda in just 10kB",
	"author": "self_refactor",
	"date": "2017-06-13T13:04:20.020Z",
	"tags": {
		"categories": [
			"opensource",
			"fp",
			"ramda",
			"lodash",
			"utils"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md rambdafaster alternative ramda just 10kb - documentationargumentation admire ramda it is great library what does, i used small part what offers. wanted optimize size my bundle, i had already developed ramda habits. lead to idea recreate funtionality some ramda methods export as library.example const r = require(\"rambda\")const result = r.compose( r.filter(val => val>2), r.flatten,)([ [1], [2], [3], 4])console.log(result) // => [3,4]install npm rambda webpack node.js browser usage include your htmlhttps://cdnjs.cloudflare.com/ajax/libs/rambda/0.7.0/webversion.jsdifferences between rambda ramdarambda shadows small part the ramda's api. few things note:rambda's methods should compatible most the basic ramda's methods. more complex ramda specific methods(such r.__), should expect mismatch.rambda's type detect async functions. returned value is \"async\"rambda's map/filter only arrays, while ramda's map/filter accept objects.rambda's equals doesn't protect against circular structures ramda.equals does.rambda is tested compatability ramda.flip, this method be useful some cases. you need more ramda methods, what rambda offers, may check extended version rambda - rambdaxapiaddadd(: number, b: number): numberr.add(2, 3) //=> 5adjustadjust(replacefn: function, :number, arr:array): arrayreplaces index arr the result replacefn(arr[])r.adjust( => a + 1, 0, [0, 100]) //=> [1, 100]any(condition: function, arr: array): booleanreturns true at least member arr returns true, passed the condition functionr.(a => * a > 8)([1, 2, 3]) //=> truer.(a => * a > 10)([1, 2, 3]) //=> falseappendappend(valuetoappend: , arr: array): arrayr.append('foo', ['bar', 'baz']) //=> ['foo', 'bar', 'baz']containscontains(valuetofind: , arr: array): booleanreturns true valuetofind is part arrr.contains(2, [1, 2]) //=> truer.contains(3, [1, 2]) //=> falsecurrycurry(fn: function): functionreturns curried version fnconst addfournumbers = (, b, c, d) => + b + c + dconst curriedaddfournumbers = r.curry(addfournumbers)const f = curriedaddfournumbers(1, 2)const g = f(3)g(4) // => 10defaulttodefaultto(defaultargument: t, inputargument: ): treturns defaultargument inputargument is undefined the type inputargument is different the type defaultargument.returns inputargument any case.r.defaultto('foo', undefined) //=> 'foo'r.defaultto('foo')('bar') //=> 'bar'r.defaultto('foo')(1) //=> 'foo'dropdrop(howmanytodrop: number, arrorstr: array|string): array|stringreturns arrorstr howmanytodrop items dropped the leftr.drop(1, ['foo', 'bar', 'baz']) //=> ['bar', 'baz']r.drop(1, 'foo') //=> 'oo'droplastdroplast(howmanytodrop: number, arrorstr: array|string): array|stringreturns arrorstr howmanytodrop items dropped the rightr.droplast(1, ['foo', 'bar', 'baz']) //=> ['foo', 'bar']r.droplast(1, 'foo') //=> 'fo'equalsequals(: any, b: ): booleanreturns equality match between and bdoesn't handles cyclical data structuresr.equals(1, 1) //=> truer.equals({}, {}) //=> falser.equals([1, 2, 3], [1, 2, 3]) //=> truefilterfilter(filterfn: function, arr: array): arrayfilters arr throw boolean returning filterfnconst filterfn = => a % 2 === 0r.filter(filterfn, [1, 2, 3, 4]) //=> [2, 4]findfind(findfn: function, arr: array): t|undefinedreturns undefined the element arr satisfying findfnconst findfn = => r.type(.foo) === \"number\"const arr = [{foo: \"bar\"}, {foo: 1}]r.find(findfn, arr) //=> {foo: 1}findindexfindindex(findfn: function, arr: array): numberreturns -1 the index the element arr satisfying findfnconst findfn = => r.type(.foo) === \"number\"const arr = [{foo: \"bar\"}, {foo: 1}]r.find(findfn, arr) //=> 1flattenflatten(arr: array): arrayr.flatten([ 1, [ 2, [ 3 ] ] ]//=> [ 1, 2, 3 ]hashas(prop: string, obj: object): booleanreturns true obj has property propr.has(\"\", {a: 1}) //=> truer.has(\"b\", {: 1}) //=> falseheadhead(arrorstr: array|string): returns first element arrorstrr.head([1, 2, 3]) //=> 1r.head('foo') //=> 'f'indexofindexof(valuetofind: , arr: array): numberreturns -1 the index the element arr equal valuetofindr.indexof(1, [1, 2]) //=> 0initinit(arrorstr: array|string): array|stringreturns but last element arrorstrr.init([1, 2, 3]) //=> [1, 2]r.init('foo') //=> 'fo'joinjoin(separator: string, arr: array): stringr.join('-', [1, 2, 3]) //=> '1-2-3'lastlast(arrorstr: array|string): returns last element arrorstrr.last(['foo', 'bar', 'baz']) //=> 'baz'r.last('foo') //=> 'o'lengthlength(arrorstr: array|string): numberr.length([1, 2, 3]) //=> 3mapmap(mapfn: function, arr: array): arrayreturns result looping through arr mapfnconst mapfn = x => x * 2;r.map(mapfn, [1, 2, 3]) //=> [2, 4, 6]matchmap(regexpression: regex, str: string): arrayr.match(/([-z])/g, 'bananas') //=> ['ba', 'na', 'na']mergemerge(: object, b: object)returns result object.assign({}, , b)r.merge({ 'foo': 0, 'bar': 1 }, { 'foo': 7 })//=> { 'foo': 7, 'bar': 1 }omitomit(propstoomit: array, obj: object): objectreturns partial copy an obj omitting propstoomitr.omit(['', 'd'], {: 1, b: 2, c: 3}) //=> {b: 2, c: 3}pathpath(pathtosearch: array, obj: object): retrieve value pathtosearch object objr.path(['', 'b'], {: {b: 2}}) //=> 2r.path(['', 'c'], {: {b: 2}}) //=> undefinedpartialcurrypartialcurry(fn: function|async, : object, b: object): function|promise called function fn first set input , it return function. function wait be called second set input b it invoke fn the merged object a b.fn be asynchronous function. that case promise holding result fn is returned. the example below:const fn = ({, b, c}) => { return ( * b) + c}const curried = r.partialcurry(fn, {: 2})curried({b: 3, c: 10}) //=> 16note partialcurry is method specific rambda the method is part ramda's api can read argumentation creating partialcurry herepickpick(propstopick: array, obj: object): objectreturns partial copy an obj containing propstopick propertiesr.pick(['', 'c'], {: 1, b: 2}) //=> {: 1}pluckpluck(property: string, arr: array): arrayreturns list the values property taken the objects array objects arrr.pluck('')([{a: 1}, {: 2}, {b: 3}]) //=> [1, 2]prependprepend(valuetoprepend: , arr: array): arrayr.prepend('foo', ['bar', 'baz']) //=> ['foo', 'bar', 'baz']propprop(proptofind: string, obj: object): returns undefined the value property proptofind objr.prop('x', {x: 100}) //=> 100r.prop('x', {: 1}) //=> undefinedpropeqpropeq(proptofind: string, valuetomatch: , obj: object): booleanreturns true obj has property proptofind its value is equal valuetomatchconst proptofind = \"foo\"const valuetomatch = 0r.propeq(proptofind, valuetomatch)({foo: 0}) //=> truer.propeq(proptofind, valuetomatch)({foo: 1}) //=> falserangerange(start: number, end: number): arrayreturns array numbers start(inclusive) end(exclusive)r.range(0, 2) //=> [0, 1]repeatrepeat(valuetorepeat: t, num: number): arrayr.repeat('foo', 2) //=> ['foo', 'foo']replacereplace(strorregex: string|regex, replacer: string, str: string): stringreplace strorregex found str replacerr.replace('foo', 'bar', 'foo foo') //=> 'bar foo'r.replace(/foo/, 'bar', 'foo foo') //=> 'bar foo'r.replace(/foo/g, 'bar', 'foo foo') //=> 'bar bar'sortsort(sortfn: function, arr: array): arrayreturns copy arr sorted sortfnsortfn must return numberconst sortfn = (, b) => - br.sort(sortfn, [3, 1, 2]) //=> [1, 2, 3]sortbysortby(sortfn: function, arr: array): arrayreturns copy arr sorted sortfnsortfn must return value comparisonconst sortfn = obj => obj.foor.sortby(sortfn, [ {foo: 1}, {foo: 0}])//=> [{foo: 0}, {foo: 1}]splitsplit(separator: string, str: string): arrayr.split('-', '-b-c') //=> ['', 'b', 'c']spliteverysplitevery(slicelength: number, arrorstring: array|string): arraysplits arrorstr slices slicelengthr.splitevery(2, [1, 2, 3]) //=> [[1, 2], [3]]r.splitevery(3, 'foobar') //=> ['foo', 'bar']subtractsubtract(: number, b: number): numberreturns minus br.subtract(3, 1) //=> 2tailtail(arrorstr: array|string): array|stringreturns but first element arrorstrr.tail([1, 2, 3]) //=> [2, 3]r.tail('foo') //=> 'oo'take(num: number, arrorstr: array|string): array|stringreturns first num elements arrorstrr.(1, ['foo', 'bar']) //=> ['foo']r.(2, ['foo']) //=> 'fo'takelasttakelast(num: number, arrorstr: array|string): array|stringreturns last num elements arrorstrr.takelast(1, ['foo', 'bar']) //=> ['bar']r.takelast(2, ['foo']) //=> 'oo'testtest(regexpression: regex, str: string): booleandetermines whether str matches regexpressionr.test(/^f/, 'foo') //=> truer.test(/^f/, 'bar') //=> falsetolowertolower(str: string): stringr.tolower('foo') //=> 'foo'touppertoupper(str: string): stringr.toupper('foo') //=> 'foo'trimtrim(str: string): stringr.trim(' foo ') //=> 'foo'typetype(: any): stringr.type(() => {}) //=> \"function\"r.type(async () => {}) //=> \"async\"r.type([]) //=> \"array\"r.type({}) //=> \"object\"r.type('s') //=> \"string\"r.type(1) //=> \"number\"r.type(false) //=> \"boolean\"r.type(null) //=> \"null\"r.type(/[-z]/) //=> \"regexp\"uniquniq(arr: array): arrayreturns new array containing one copy each element arrr.uniq([1, 1, 2, 1]) //=> [1, 2]r.uniq([1, '1']) //=> [1, '1']updateupdate(: number, replacevalue: , arr: array): arrayreturns new copy the arr the element i indexreplaced replacevaluer.update(0, \"foo\", ['bar', 'baz']) //=> ['foo', baz]valuesvalues(obj: object): arrayreturns array of values objr.values({: 1, b: 2}) //=> [1, 2]benchmarkflowtype haven't tested fully, the partial test shows ramdadefinitions be used. need replace declare module ramda declare module rambda line 10 store file rambda.js your flow-typed foldermore infochangelog0.7.0 close issue #5 - change name curry partialcurry; add method curry, works like ramda's curry0.6.2 add separate documentation site via docsifyprojects using rambda learn smarterjson-validitylog-fnnightmare-helperstring-fnwatch-fnarticles rambdainterview dejan totef survivejs blogargumentation rambda's curry method"
}