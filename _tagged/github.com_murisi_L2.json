{
	"_id": "14510073",
	"site": "https://github.com/murisi/L2",
	"title": " L2: An experiment/programming language",
	"author": "murisitarusenga",
	"date": "2017-06-13T13:04:19.869Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c",
			"assembly",
			"shell"
		]
	},
	"content": "readme.md l2l2 is attempt find smallest distilled programming language equivalent c. goal is turn much c's preprocessor directives, control structures, statements, literals, functions requiring compiler assistance (setjmp, longjmp, alloca, ...) things definable inside l2 ( perhaps little assembly). language does surject all c, most glaring omission being of type-system. however, reckon result is still pretty interesting. approach taken achieve has been make c's features more composable, more multipurpose, , at least one occasion, add new feature that whole group distinct features be dropped. particular, most striking changes are c's:irregular syntax is replaced s-expressions; simple syntax composes with non-trivial preprocessor ( no, have merely transplanted common lisp's macros c)loop constructs are replaced what could describe a more structured variant setjmp longjmp without stack destruction ( no, is performance overhead associated this) are 9 language primitives for each of i describe syntax, exactly do english, i386 assembly translate , and example usage them. following comes brief description l2's internal representation the 9 functions (loosely speaking) manipulate . after comes description how non-primitive l2 expression is compiled. above descriptions about 8 pages are essentially complete description l2. readme ends a list reductions shows some c's constructs be defined terms l2. here, have demonstrated closures hint how more exotic things coroutines generators are possible using l2's continuations.getting startedbuilding l2shell interfaceprimitive expressionsbeginbinaryreferencefunctioninvoke continuation continuationcontinueinternal representationexpressionreductionscommentingnumbersbackquotingcharactersstringsconditional compilationvariable bindingswitch expressionclosuresgetting startedbuilding l2./buildl2 l2 compiler needs linux distribution running the i386 ( amd64 libc6-dev-i386 installed) architecture the gnu c compiler installed run successfully. build l2, simply run buildl2 script the root the repository. build should fast - are 2000 lines c code compile. will create directory called bin containing files l2compile demort.o. l2compile is compiler l2 its interface is described below. demort.o is a part l2, it be used the demonstrations below.shell interface./bin/l2compile (-pic | -pdc) -object output objects.o ... (- inputs.l2 ...) ... - inputs.l2 ..../bin/l2compile (-pic | -pdc) -library output objects.o ... (- inputs.l2 ...) ... - inputs.l2 ..../bin/l2compile (-pic | -pdc) -program output objects.o ... (- inputs.l2 ...) ... - inputs.l2 ...starting the hyphen argument, compiler reads inputs.l2 ... until either next hyphen argument is found the command line arguments are finished. each the files read should of form expression1 expression2 ... expressionn. compiler concatenates the l2 files read, the same order. that, compiler compiles each expression the concatenated l2 file emitting corresponding object code the same order the expressions the concatenated file. l2 is executed top-down, is main function. each expression is compiled the environment: set defined symbols. there are still unconsumed hyphens, the object file is packaged a shared library along objects.o ..., this shared library is dynamically loaded the environment. the compilation process starts again, this with next set inputs.l2.... there are more unconsumed hyphens, the output should either a position independent dependent object, shared library, program called output specified the 3 arguments l2compile. the final output is an object file, objects.o ... are embeded linked it. initial environment, one is before group files is compiled, comprises 17 functions: lst, lst?, fst, rst, sexpr, nil, nil?, -<character>-, <character>?, begin, b, , function, invoke, -continuation, -continuation, continue. former 9 are defined later. each of latter 8 functions does nothing else return s-expression formed prepending function name the list s-expressions supplied them. example, b function have following definition: (function b (sexprs) [lst [lst [-b-] [nil]] [' sexprs]]).examplefile1.l2(function foo (sexprs)(-continuation return(begin[putchar [+ (b 00000000000000000000000001100001) (b 00000000000000000000000000000001)]]{return [lst [lst [-b-] [lst [-e-] [lst [-g-] [lst [--] [lst [-n-] [nil]]]]]] [nil]]})))[putchar (b 00000000000000000000000001100001)]file2.l2(function bar ()[putchar (b 00000000000000000000000001100011)])(foo text does matter)[putchar (b 00000000000000000000000001100100)]running ./bin/l2compile -pdc -program myprogram bin/demort.o - file1.l2 - file2.l2 produces program called myprogram. during compilation, text \"ab\" should been printed standard output. \"a\" comes the last expression file1.l2. was printed the compilation file1.l2, it was being loaded the compiler. why? l2 libraries are executed top bottom they are dynamically loaded ( also they are statically linked). \"b\" comes within function file1.l2. was executed the expression (foo text does matter) file2.l2 was being compiled. why? the foo causes compiler invoke function called foo the environment. s-expression ( text does matter) is argument the function foo, the function foo ignores and returns s-expression (begin). hence (begin) replaces (foo text does matter) file2.l2. file2.l2 is entirely made of primitive expressions are compiled the specified below. resulting executable myprogram is run using command ./myprogram. prints text \"d\" executed. why? the last expression file2.l2 is only that actually does something. instead run ./bin/l2compile -pic -library mylibrary. bin/demort.o - file1.l2 - file2.l2, shared library named mylibrary. is produced. running objdump -t mylibrary. on shows that function bar is exported. also shows that foo is exported. why is second fact true? file1.l2 does come the final hyphen. only has relevance during compilation process. why is first fact true? file1.l2 comes the final hyphen because bar is top-level expression. mylibrary. is dynamically loaded (perhaps using dlopen), text \"d\" be printed standard output. if symbol bar (perhaps obtained using dlsym) is invoked, text \"c\" be printed standard output.running ./bin/l2compile -pic -object mylibrary.o bin/demort.o - file1.l2 - file2.l2 followed ./bin/l2compile -pdc -program myprogram mylibrary.o bin/demort.o - file1.l2 - produces program myprogram. execution the command should caused compiler print \"ab\" standard output the same reasons above. for second command, text \"da\" should been printed standard output. why? after file1.l2 is compiled object code, is packaged a shared object such way the object files mylibrary.o demort.o before . hence that shared library is loaded, last expression file2.l2 is executed followed the last expression file1.l2. being source files the final hyphen, mylibrary.o demort.o are linked nothing else in end produces executable called myprogram prints \"d\" standard output.primitive expressionsbegin(begin expression1 expression2 ... expressionn)evaluates subexpressions sequentially left right. is, evaluates expression1, expression2, so , ending the execution expressionn. specifying zero subexpressions is valid. return value is unspecified. expression is implemented emitting instructions expression1, emitting instructions expression2 immediately afterwords so , ending the emission expressionn. the expression [foo] prints text \"foo\" standard output the expression [bar] prints text \"bar\" standard output. (begin [foo] [bar] [foo] [foo] [foo]) prints text \"foobarfoofoofoo\" standard output.binary(b b31b30...b0) resulting value is 32 bit number specified binary inside brackets. specifying less or more 32 bits is error. useful implementing character string literals, numbers other bases. expression is implemented emitting instruction mov immediate value a memory location designated the surrounding expression. the expression [putchar x] prints character x. [putchar (b 00000000000000000000000001100001)] prints text \"\" to standard output.referencereference0 resulting value is address memory which reference refers. expression is implemented the emission an instruction lea some data a memory location designated the surrounding expression. the expression [' x] evaluates the value the reference x the expression [set x y] puts value y the reference x. (begin [set x (b 00000000000000000000000001100001)] [putchar [' x]]) prints text \"\" to standard output.(if expression0 expression1 expression2) expression0 is non-zero, only expression1 is evaluated its resulting value becomes of whole expression. expression0 is zero, only expression2 is evaluated its resulting value becomes of whole expression. expression is implemented first emitting instruction or expression0 itself. an instruction je expression2's label is emitted. the instructions expression1 are emitted the location the resulting value fixed the same memory address designated the resulting value the expression. an instruction is emitted jmp the end all instructions are emitted this expression. the label expression2 is emitted. the instructions expression2 are emitted the location the resulting value fixed the same memory address designated the resulting value the expression. expression [putchar ( (b 00000000000000000000000000000000) (b 00000000000000000000000001100001) (b 00000000000000000000000001100010))] prints text \"b\" standard output.function(function function0 (reference1 reference2 ... referencen) expression0)makes function be invoked exactly n arguments. the function is invoked, expression0 is evaluated an environment where function0 is reference the function itself reference1, reference2, to referencen are references the resulting values evaluating corresponding arguments the invoke expression invoking function. once evaluation is complete, control flow returns the invoke expression the invoke expression's resulting value is resulting value evaluating expression0. resulting value this function expression is reference the function. expression is implemented first emitting instruction mov address function0 ( label be emitted later) the memory location designated the surrounding expression. an instruction is emitted jmp the end all instructions are emitted this function. the label named function0 is emitted. instructios push each callee-saved register onto stack are emitted. an instruction push frame-pointer onto stack is emitted. an instruction move value the stack-pointer the frame-pointer is emitted. an instruction sub the stack-pointer amount words reserved this function's stack-frame is emitted. this instructions expression0 are emitted the location the resulting value fixed a word within stack-pointer's drop. this instruction is emitted mov word this location the register eax. finally, instructions are emitted leave current function's stack-frame, pop callee-save registers, ret the address the caller. expression [putchar [(function - (a b) [- [' b] [' ]]) (b 00000000000000000000000000000001) (b 00000000000000000000000001100011)]] prints text \"b\" standard output.invoke(invoke function0 expression1 expression2 ... expressionn)[function0 expression1 expression2 ... expressionn]both above expressions are equivalent. evaluates function0, expression1, expression2, to expressionn an unspecified order then invokes function0, reference a function, providing with resulting values evaluating expression1 to expressionn, order. resulting value this expression is determined the function being invoked.n+1 words must reserved the current function's stack-frame plan. expression is implemented emitting instructions any the subexpressions the location the resulting value fixed the corresponding reserved word. same is done the remaining expressions repeatedly until instructions all subexpressions been emitted. an instruction push last reserved word onto stack is emitted, followed the second last, so , ending an instruction push first reserved word onto stack. call instruction the zeroth reserved word the operand is emitted. note l2 expects registers esp, ebp, ebx, esi, edi be preserved across calls. add instruction pops n words off stack is emitted. an instruction is emitted mov register eax a memory location designated the surrounding expression. function the reference - returns value subtracting second parameter its could defined follows:-:movl 4(%esp), %eaxsubl 8(%esp), %eaxret following invokation it, (invoke putchar (invoke - (b 00000000000000000000000001100011) (b 00000000000000000000000000000001))), prints text \"b\" standard output. continuation(-continuation continuation0 expression0)makes continuation the containing expression is be continued with exactly argument. expression0 is evaluated an environment where continuation0 is reference the aforementioned continuation. resulting value this expression is unspecified the evaluation expression0 completes. the continuation continuation0 is continued , then with-continuation expression evaluates the resulting value the single argument within responsible continue expression.5+1 words must reserved the current function's stack-frame plan. call reference the word the reservation continuation0. expression is implemented first emitting instructions store program's state continuation0, is, instructions are emitted mov ebp, address the instruction should executed continuing ( label be emitted later), edi, esi, ebx, that order, the 5 words continuation0. this, instructions expression0 are emitted. the label the instruction the continuation is emitted. finally, instruction is emitted mov resulting value the continuation, 6th word continuation0, the memory location designated the surrounding expression.examplesnote the expression {continuation0 expression0} continues the continuation reference continuation0 resulting value evaluating expression0 its argument. the note mind, expression (begin [putchar (-continuation ignore (begin {ignore (b 00000000000000000000000001001110)} [foo] [foo] [foo]))] [bar]) prints text \"nbar\" standard output. following assembly function allocate receives number bytes is allocate its argument, allocates memory, passes initial address this memory the single argument the continuation receives its second argument.allocate:/* sanctioned l2 abi: */movl 8(%esp), %ecxmovl 16(%ecx), %ebxmovl 12(%ecx), %esimovl 8(%ecx), %edimovl 0(%ecx), %ebpsubl 4(%esp), %espandl $0xfffffffc, %espmovl %esp, 20(%ecx)jmp *4(%ecx) following usage it, (-continuation dest [allocate (b 00000000000000000000000000000011) dest]), evaluates the address the allocated memory. allocate had decreased esp returned, would been invalid l2 expects functions preserve esp. continuation(-continuation continuation0 (reference1 reference2 ... referencen) expression0)makes continuation be continued with exactly n arguments. the continuation is continued , expression0 is evaluated an environment where continuation0 is reference the continuation itself reference1, reference2, to referencen are references the resulting values evaluating corresponding arguments the continue expression continuing this function. undefined behavior occurs the evaluation expression0 completes - .e. programmer must direct control flow of continuation0 somewhere within expression0. resulting value this -continuation expression is reference the continuation.5+n words must reserved the current function's stack-frame plan. call reference the word the reservation continuation0. expression is implemented first emitting instruction mov reference continuation0 the memory location designated the surrounding expression. instructions are emitted store program's state continuation0, is, instructions are emitted mov ebp, address the instruction should executed continuing ( label be emitted later), edi, esi, ebx, that order, the 5 words continuation0. an instruction is emitted jmp the end all instructions are emitted this -continuation expression. the label the instruction the continuation is emitted. this instructions expression0 are emitted. expression {(-continuation forever ( b) (begin [putchar [' ]] [putchar [' b]] {forever [- [' ] (b 00000000000000000000000000000001)] [- [' b] (b 00000000000000000000000000000001)]})) (b 00000000000000000000000001011010) (b 00000000000000000000000001111010)} prints text \"zzyyxxww\"... standard output.continue(continue continuation0 expression1 expression2 ... expressionn){continuation0 expression1 expression2 ... expressionn}both above expressions are equivalent. evaluates continuation0, expression1, expression2, to expressionn an unspecified order then continues continuation0, reference a continuation, providing with local copies expression1 to expressionn order. resulting value this expression is unspecified.n+1 words must reserved the current function's stack-frame plan. expression is implemented emitting instructions any the subexpressions the location the resulting value fixed the corresponding reserved word. same is done the remaining expressions repeatedly until instructions all subexpressions been emitted. an instruction mov first reserved word 5 words the beginning the continuation is emitted, followed an instruction mov second reserved word an address immediately that, so , ending an instruction mov last reserved word the last memory address that area. program's state, is, ebp, address the instruction should executed continuing, edi, esi, ebx, that order, are is stored the beginning a continuation. instructions mov values the buffer the appropiate registers then set program counter appropiately are, last, emitted. expression (begin (-continuation cutter (continue (-continuation cuttee () (begin [bar] [bar] (continue cutter (b 00000000000000000000000000000000)) [bar] [bar] [bar])))) [foo]) prints text \"barbarfoo\" standard output. optimizationlooking the examples above where continuation reference does escape, (-continuation reference0 expression0) behaves lot the pseudo-assembly expression0 reference0: (make-continuation reference0 (...) expression0) behaves lot reference0: expression0. be more precise, references a particular continuation occur the continuation0 subexpression a continue statement, know the continuation is constrained the function which is declared, hence is need store restore ebp, edi, esi, ebx. continuations, , are efficient iteration is achieved l2.internal representation substituting the syntactic sugar used the invoke continue expressions. find all l2 programs are compositions the <pre-s-expression>s: <symbol> (<pre-s-expression> <pre-s-expression> ... <pre-s-expression>). we replace every symbol a list its characters that example foo becomes (f o o), now find all l2 programs are just compositions the <s-expression>s <character> (<s-expression> <s-expression> ... <s-expression>). following functions manipulate s-expressions are part the l2 language hence compiler does give references them special treatment during compilation. however, compiled code is loaded an l2 compiler, undefined references these functions are be dynamically resolved.[lst x y]x must a s-expression y list.makes list where x is and y is rest. the s-expression foo is stored a the list (bar) is stored b. [lst [' ] [' b]] is s-expression (foo bar).[lst? x]x must a s-expression.evaluates the complement zero x is list. otherwise evaluates zero. the s-expression foo is stored a. [lst? [' ]] evaluates (b 11111111111111111111111111111111).[fst x]x must a list.evaluates a s-expression is first x. the list foo is stored a. [fst [' ]] is s-expression . this is a list is character.[rst x]x must a list`.evaluates a list is rest x. the list foo is stored a. [rst [' ]] is s-expression oo.[sexpr x]x must a list.evaluates an s-expression wrapper x. the s-expression foo is stored a (bar) is stored b. [lst [sexpr [rst [' ]]] [' b]] is s-expression (oo bar). note without sexpr invokation, preconditions lst be violated.[nil]evaluates the empty list. the s-expression foo is stored a. [lst [' ] [nil]] is s-expression (foo).[nil? x]x must a list.evaluates the complement zero x is empty list. otherwise evaluates zero. the s-expression ((foo bar bar bar)) is stored x. [nil? [rst [' x]]] evaluates (b 11111111111111111111111111111111).[-<character>-]evaluates the character <character>. expression [lst [-f-] [lst [-o-] [lst [-o-] [nil]]]] evaluates the s-expression foo.[<character>? x]x must a s-expression.evaluates the complement zero x is character . otherwise evaluates zero. the s-expression (foo (bar bar) foo foo) is stored x. [m? [' x]] evaluates (b 00000000000000000000000000000000).expression(function0 expression1 ... expressionn) the above expression is a primitive expression, function0 is evaluated the environment. resulting value this evaluation is invoked the (unevaluated) list s-expressions (expression1 expression2 ... expressionn) its argument. list s-expressions returned this function replaces entire list s-expressions (function0 expression1 ... expressionn). the result this replacement is still non-primitive expression, the above process is repeated. this process terminates, appropiate assembly code the resulting primitive expression is emitted. expression ((function comment (sexprs) [fst [' sexprs]]) [foo] comment is ignored. , seriously.) is replaced [foo], in turn compiles assembly similar what is generated other invoke expressions.reductions the extensive list processing follows this section, following functions prove be convenient abbreviations:abbreviations.l2(function frst (l) [fst [rst [' l]]])(function frfst (l) [fst [rst [fst [' l]]]])(function frrst (l) [fst [rst [rst [' l]]]])(function frrrst (l) [fst [rst [rst [rst [' l]]]]])(function rfst (l) [rst [fst [' l]]])(function ffst (l) [fst [fst [' l]]])(function llst ( b c) [lst [' ] [lst [' b] [' c]]])(function lllst ( b c d) [lst [' ] [lst [' b] [lst [' c] [' d]]]])(function llllst ( b c d e) [lst [' ] [lst [' b] [lst [' c] [lst [' d] [' e]]]]])(function llllllst ( b c d e f g) [lst [' ] [lst [' b] [lst [' c] [lst [' d] [lst [' e] [lst [' f] [' g]]]]]]])commentingl2 has built- mechanism commenting code written it. following comment function follows takes list s-expressions its argument returns last s-expression that list ( itself is guaranteed be list s-expressions) effectively causing other s-expressions be ignored. implementation use follows:comments.l2(function ** (l)(-continuation return{(-continuation find ( last)( [nil? [' last]]{return [' ]}{find [fst [' last]] [rst [' last]]})) [fst [' l]] [rst [' l]]}))test.l2(** is comment, the next thing is is actually compiled: (begin))shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - test.l2numbersinteger literals prove be quite tedious l2 can seen some the examples the primitive expressions section. following function, d, implements decimal arithmetic reading an s-expression base 10 writing the equivalent s-expression base 2:numbers.l2(** turns 4-byte integer base-2 s-expression representation it.(function binary->base2sexpr (binary)[lst [lst [-b-] [nil]] [lst (-continuation return{(-continuation write (count out)( [' count]{write [- [' count] (b 00000000000000000000000000000001)][>> [' ] (b 00000000000000000000000000000001)][lst ( [and [' ] (b 00000000000000000000000000000001)] [-1-] [-0-]) [' ]]}{return [' ]})) (b 00000000000000000000000000100000) [' binary] [nil]}) [nil]]]))(function d (l)[binary->base2sexpr(** turns base-10 s-expression input a 4-byte integer.(-continuation return {(-continuation read ( out)( [nil? [' ]]{return [' ]}{read [rst [' ]] [+ [* [' out] (b 00000000000000000000000000001010)]( [9? [fst [' ]]] (b 00000000000000000000000000001001)( [8? [fst [' ]]] (b 00000000000000000000000000001000)( [7? [fst [' ]]] (b 00000000000000000000000000000111)( [6? [fst [' ]]] (b 00000000000000000000000000000110)( [5? [fst [' ]]] (b 00000000000000000000000000000101)( [4? [fst [' ]]] (b 00000000000000000000000000000100)( [3? [fst [' ]]] (b 00000000000000000000000000000011)( [2? [fst [' ]]] (b 00000000000000000000000000000010)( [1? [fst [' ]]] (b 00000000000000000000000000000001)(b 00000000000000000000000000000000))))))))))]})) [fst [' l]] (b 00000000000000000000000000000000)}))])test.l2[putchar (d 65)]shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - test.l2backquoting foo example the internal representation section shows tedious writing function outputs symbol be. backquote function reduces tedium. takes single s-expression its argument , generally, returns s-expression makes s-expression. exception this rule is if sub-expression its input s-expression is the form (, expr0), the result evaluating expr0 is inserted that position the output s-expression. backquote be implemented used follows:backquote.l2(function ` (l)[(function aux (s)( [nil? [' s]][lst [sexpr [llllllst [--][-n-][-v-][-o-][-k-][-e-][nil]]][lst [sexpr [lllst [-n-][--][-l-][nil]]] [nil]]]( (if [lst? [' s]] ( [not [nil? [' s]]] ( [lst? [fst [' s]]] ( [not [nil? [fst [' s]]]]( [,? [ffst [' s]]] [nil? [rfst [' s]]] (d 0)) (d 0)) (d 0)) (d 0)) (d 0))[frst [' s]][lst [sexpr [llllllst [--][-n-][-v-][-o-][-k-][-e-][nil]]][lst [sexpr [lllst [-l-][-s-][-t-][nil]]][lst ( [lst? [fst [' s]]][sexpr [aux [fst [' s]]]][sexpr [lst[sexpr [llllllst [--][-n-][-v-][-o-][-k-][-e-][nil]]][lst [sexpr [lst [---] [lst [fst [' s]] [lst [---] [nil]]]]] [nil]]]])[lst [sexpr [aux [rst [' s]]]] [nil]]]]]))) [fst [' l]]])anotherfunction.l2:(function -a-function (l)(` (function (,[nil]) [putchar (d 65)]))) equivalently(function -a-function (l)(`(function () [putchar (d 65)])))test.l2(-a-function)[]shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 - anotherfunction.l2 - test.l2characters d implemented, somewhat more readable implementation characters is possible. char function takes singleton list containing character s-expression returns ascii encoding using d expression. implementation use follows:characters.l2(function char (l) [(function aux (c)( [!? [' c]] (`(d 33))( [\"? [' c]] (`(d 34))( [$? [' c]] (`(d 36))( [%? [' c]] (`(d 37))( [&? [' c]] (`(d 38))( ['? [' c]] (`(d 39))( [*? [' c]] (`(d 42))( [+? [' c]] (`(d 43))( [,? [' c]] (`(d 44))( [-? [' c]] (`(d 45))( [.? [' c]] (`(d 46))( [/? [' c]] (`(d 47))( [0? [' c]] (`(d 48))( [1? [' c]] (`(d 49))( [2? [' c]] (`(d 50))( [3? [' c]] (`(d 51))( [4? [' c]] (`(d 52))( [5? [' c]] (`(d 53))( [6? [' c]] (`(d 54))( [7? [' c]] (`(d 55))( [8? [' c]] (`(d 56))( [9? [' c]] (`(d 57))( [:? [' c]] (`(d 58))( [;? [' c]] (`(d 59))( [<? [' c]] (`(d 60))( [=? [' c]] (`(d 61))( [>? [' c]] (`(d 62))( [?? [' c]] (`(d 63))( [a? [' c]] (`(d 65))( [b? [' c]] (`(d 66))( [c? [' c]] (`(d 67))( [d? [' c]] (`(d 68))( [e? [' c]] (`(d 69))( [f? [' c]] (`(d 70))( [g? [' c]] (`(d 71))( [h? [' c]] (`(d 72))( [i? [' c]] (`(d 73))( [j? [' c]] (`(d 74))( [k? [' c]] (`(d 75))( [l? [' c]] (`(d 76))( [m? [' c]] (`(d 77))( [n? [' c]] (`(d 78))( [o? [' c]] (`(d 79))( [p? [' c]] (`(d 80))( [q? [' c]] (`(d 81))( [r? [' c]] (`(d 82))( [s? [' c]] (`(d 83))( [t? [' c]] (`(d 84))( [u? [' c]] (`(d 85))( [v? [' c]] (`(d 86))( [w? [' c]] (`(d 87))( [x? [' c]] (`(d 88))( [y? [' c]] (`(d 89))( [z? [' c]] (`(d 90))( [\\? [' c]] (`(d 92))( [^? [' c]] (`(d 94))( [_? [' c]] (`(d 95))( [`? [' c]] (`(d 96))( [a? [' c]] (`(d 97))( [b? [' c]] (`(d 98))( [c? [' c]] (`(d 99))( [d? [' c]] (`(d 100))( [e? [' c]] (`(d 101))( [f? [' c]] (`(d 102))( [g? [' c]] (`(d 103))( [h? [' c]] (`(d 104))( [i? [' c]] (`(d 105))( [j? [' c]] (`(d 106))( [k? [' c]] (`(d 107))( [l? [' c]] (`(d 108))( [m? [' c]] (`(d 109))( [n? [' c]] (`(d 110))( [o? [' c]] (`(d 111))( [p? [' c]] (`(d 112))( [q? [' c]] (`(d 113))( [r? [' c]] (`(d 114))( [s? [' c]] (`(d 115))( [t? [' c]] (`(d 116))( [u? [' c]] (`(d 117))( [v? [' c]] (`(d 118))( [w? [' c]] (`(d 119))( [x? [' c]] (`(d 120))( [y? [' c]] (`(d 121))( [z? [' c]] (`(d 122))( [|? [' c]] (`(d 124))( [~? [' c]] (`(d 126)) (`(d 0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))[ffst [' l]]])test.l2[putchar (char )]shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 - characters.l2 - test.l2strings above exposition has purposefully avoided making strings it is tedious do using binary reference arithmetic. quote function takes list lists character s-expressions returns sequence operations required write ascii encoding memory. \"operations\" are essentially decreasing stack-pointer, putting characters that memory, returning address that memory. the stack-frame a function is destroyed upon return, strings implemented this should be returned. quote is implemented below along its helper function called reverse reverses lists:reverse.l2(function reverse (l)(-continuation return{(-continuation _ (l reversed)( [nil? [' l]]{return [' reversed]}{_ [rst [' l]] [lst [fst [' l]] [' reversed]]})) [' l] [nil]}))strings.l2(function \" (l) (-continuation return{(-continuation add-word (str index instrs)( [nil? [' str]]{return (`(-continuation return[allocate (,[binary->base2sexpr [' index]])(-continuation _ (str) (,[lst (` begin) [reverse [lst (`{return [' str]}) [' instrs]]]]))]))}{(-continuation add-char (word index instrs)( [nil? [' word]]{add-word [rst [' str]] [+ [' index] (d 1)][lst (`[set-char [+ [' str] (,[binary->base2sexpr [' index]])](,( [nil? [rst [' str]]] (`(d 0)) (`(d 32))))]) [' instrs]]}{add-char [rst [' word]] [+ [' index] (d 1)][lst (`[set-char [+ [' str] (,[binary->base2sexpr [' index]])] (char (,[lst [fst [' word]] [nil]]))])[' instrs]]}))[fst [' str]] [' index] [' instrs]})) [' l] (d 0) [nil]}))test.l2[printf (\" is the quote macro is used. printing number speechmarks \"%\") (d 123)]shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 - characters.l2 reverse.l2 strings.l2 - test.l2conditional compilation till , references functions defined elsewhere been only things used the subexpression an expression. sometimes, however, clarity the whole expression be improved inlining function. following code proves in context conditional compilation.test.l2(( [> (d 10) (d 20)] fst frst)[printf (\" am compiled!)][printf (\" am one compiled!)])shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 reverse.l2 - characters.l2 strings.l2 - test.l2variable bindingvariable binding is enabled the -continuation expression. -continuation is special , like function, allows references be bound. unlike function, however, expressions within -continuation directly access parent function's variables. let binding function implements following transformation:(let reference0 ((params args) ...) expr0)->(-continuation return{(-continuation reference0 (params ...){return expr0}) vals ...}) is implemented used follows:let.l2(** returns list mapper applied each element.(function map (l mapper)(-continuation return{(-continuation aux ( out)( [nil? [' ]]{return [reverse [' ]]}{aux [rst [' ]] [lst [[' mapper] [fst [' ]]] [' out]]})) [' l] [nil]})))(function let (l)(`(-continuation return(,[llst (` continue) (`(-continuation (,[fst [' l]])(,[map [frst [' l]] fst]){return (,[frrst [' l]])})) [map [frst [' l]] frst]]))))test.l2(let _((x (d 12)))(begin(function ? () [printf (\" x is %) [' x]])[?][what?][?]))note the above code what? is able access x x is defined outside all functions hence is statically allocated. note continuing _ a single argument rebinds x restarts execution the begin statement.shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 - characters.l2 strings.l2 let.l2 - test.l2switch expression we implement variant the switch statement is parameterized an equality predicate. switch selection function implements following transformation:(switch eq0 val0 (vals exprs) ... expr0)->(let temp0 ((tempeq0 eq0) (tempval0 val0))( [[' tempeq0] [' tempval0] vals1]exprs1( [[' tempeq0] [' tempval0] vals2]exprs2...( [[' tempeq0] [' tempval0] valsn]exprsnexpr0)))) is implemented used follows:switch.l2(function switch (l)(`(let temp0 ((tempeq0 (,[fst [' l]])) (tempval0 (,[frst [' l]])))(,(-continuation return{(-continuation aux (remaining else-clause)( [nil? [' remaining]]{return [' else-clause]}{aux [rst [' remaining]](`( (,[llllst (` invoke) (` [' tempeq0]) (` [' tempval0]) [ffst [' remaining]] [nil]])(,[frfst [' remaining]]) (,[' else-clause])))}))[rst [reverse [rrst [' l]]]] [fst [reverse [' l]]]})))))test.l2(switch = (d 10)((d 20) [printf (\" d is 20!)])((d 10) [printf (\" d is 10!)])((d 30) [printf (\" d is 30!)])[printf (\" s is something else.)])shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 reverse.l2 - switch.l2 characters.l2 strings.l2 let.l2 - test.l2closures restricted form closures be implemented l2. key their implementation is use continue expression \"continue\" of function is supposed provide lexical environment. doing instead merely returning the environment function, stack-pointer thus stack-frame the environment are preserved. following example implements function receives single argument \"returns\" (more accurately: continues) continuation adds value its own argument. first, following transformations are needed:(environment env0 (args ...) expr0)->(function env0 (cont0 args ...){[' cont0] expr0})(lambda (args ...) expr0)->(-continuation lambda0 (cont0 args ...){[' cont0] expr0})(; func0 args ...)->(-continuation return [func0 return args ...])(: cont0 args ...)->(-continuation return {cont0 return args ...}) are implemented used follows:closures.l2(function environment (l)(`(function (,[fst [' l]]) (,[lst (` cont0) [frst [' l]]]){[' cont0] (,[frrst [' l]])})))(function lambda (l)(`(-continuation lambda0 (,[lst (` cont0) [fst [' l]]]){[' cont0] (,[frst [' l]])})))(function ; (l)(`(-continuation return (,[lllst (` invoke) [fst [' l]] (` return) [rst [' l]]]))))(function : (l)(`(-continuation return (,[lllst (` continue) [fst [' l]] (` return) [rst [' l]]]))))test.l2(environment adder (x)(lambda (y) [+ [' x] [' y]]))(let _((add5 (; adder (d 5))) (add7 (; adder (d 7))))(begin[printf (\" %,) (: [' add5] (d 2))][printf (\" %,) (: [' add7] (d 3))][printf (\" %,) (: [' add5] (d 1))]))shell./bin/l2compile -pdc -program test demort.o - abbreviations.l2 comments.l2 - numbers.l2 - backquote.l2 reverse.l2 - characters.l2 strings.l2 closures.l2 let.l2 - test.l2"
}