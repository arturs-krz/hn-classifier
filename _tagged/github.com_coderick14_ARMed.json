{
	"_id": "14383836",
	"site": "https://github.com/coderick14/ARMed",
	"title": " A terminal-based emulator of the ARM instruction set written in Golang",
	"author": "coderick14",
	"date": "2017-06-13T13:07:23.782Z",
	"tags": {
		"categories": [
			"opensource",
			"arm",
			"golang",
			"assembly"
		],
		"languages": [
			"go",
			"shell"
		]
	},
	"content": "readme.md armed basic arm emulator written golangbuild instructionsbuild sourcerequires to installed configured get github.com/coderick14/armeddownload compiled binary download binary your required os architecture releasesusagearmed --help show the usage detailscontributionsfound bug? maybe add support some more instructions? feel free open a pull request raise issue!!note : windows, your cmd does support unicode characters, pipe output a file.armed.exe myfile > output.txt view file your favourite editor (notepad++, wordpad, sublime text etc)instructions supported v1.0instruction : additionexample : add x1, x2, x3meaning : x1 = x2 + x3instruction : subtractionexample : sub x1, x2, x3meaning : x1 = x2 - x3instruction : add immediateexample : addi x1, x2, #40meaning : x1 = x2 + 40instruction : sub immediateexample : subi x1, x2, #40meaning : x1 = x2 - 40instruction : add set flagsexample : adds x1, x2, x3meaning : x1 = x2 + x3comments : adds sets condition codesinstruction : sub set flagsexample : subs x1, x2, x3meaning : x1 = x2 - x3comments : subtracts sets condition codesinstruction : add immediate set flagsexample : addis x1, x2, #40meaning : x1 = x2 + 40comments : adds constant sets condition codesinstruction : sub immediate set flagsexample : subis x1, x2, #40meaning : x1 = x2 - 40comments : subtracts constant sets condition codesinstruction : loadexample : ldur x1, [x2, #40]meaning : x1 = memory[x2 + 40]comments : word memory registerinstruction : storeexample : stur x1, [x2, #40]meaning : memory[x2 + 40] = x1comments : word register memoryinstruction : load halfwordexample : ldurh x1, [x2, #40]meaning : x1 = memory[x2 + 40]comments : halfword memory registerinstruction : store halfwordexample : sturh x1, [x2, #40]meaning : memory[x2 + 40] = x1comments : halfword register memoryinstruction : load byteexample : ldurb x1, [x2, #40]meaning : x1 = memory[x2 + 40]comments : byte memory registerinstruction : store byteexample : sturb x1, [x2, #40]meaning : memory[x2 + 40] = x1comments : byte register memoryinstruction : move zeroexample : movz x1, 20, lsl 0meaning : x1 = 20 20*(2^16) 20*(2^32) 20*(2^48)comments : loads 16-bit constant, rest zeroesinstruction : move keepexample : movk x1, 20, lsl 0meaning : x1 = 20 20*(2^16) 20*(2^32) 20*(2^48)comments : loads 16-bit constant, rest unchangedinstruction : logical example : x1, x2, x3meaning : x1 = x2 & x3comments : bitwise- of x2 x3, stores result x1instruction : logical example : orr x1, x2, x3meaning : x1 = x2 | x3comments : bitwise- of x2 x3, stores result x1instruction : logical exclusive-example : eor x1, x2, x3meaning : x1 = x2 ^ x3comments : bitwise-xor x2 x3, stores result x1instruction : logical immediateexample : andi x1, x2, #20meaning : x1 = x2 & 20comments : bitwise- of x2 a constant, stores result x1instruction : logical immediateexample : orri x1, x2, #20meaning : x1 = x2 | 20comments : bitwise- of x2 a constant, stores result x1instruction : logical exclusive- immediateexample : eori x1, x2, #20meaning : x1 = x2 ^ 20comments : bitwise-xor x2 a constant, stores result x1instruction : logical left shiftexample : lsl x1, x2, #10meaning : x1 = x2 << 10comments : left shifts x2 a constant, stores result x1instruction : logical right shiftexample : lsr x1, x2, #10meaning : x1 = x2 >> 10comments : right shifts x2 a constant, stores result x1instruction : compare branch equal 0example : cbz x1, labelmeaning : (x1 == 0) to labelcomments : equal 0 test; pc-relative branchinstruction : compare branch not equal 0example : cbnz x1, labelmeaning : (x1 != 0) to labelcomments : notequal 0 test; pc-relative branchinstruction : conditional branchexample : b.cond labelmeaning : (condition true) to labelcomments : test condition codes; true, branchinstruction : unconditional branchexample : b labelmeaning : to labelcomments : branch pc-relative target addressinstruction : unconditional branch registerexample : br lrmeaning : to address stored lrcomments : branch address stored register. used switch, procedure returninstruction : unconditional branch linkexample : bl labelmeaning : x30 = pc + 4; to labelcomments : procedure call (pc-relative)"
}