{
	"_id": "14373433",
	"site": "https://github.com/Microsoft/TypeScript-React-Starter",
	"title": "Official starter template for TypeScript and React",
	"author": "tomduncalf",
	"date": "2017-06-13T13:57:07.365Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"typescript",
			"html",
			"css"
		]
	},
	"content": "readme.md typescript react starter quick start guide teach how wire typescript react. the end, 'll a project react typescriptlinting tslinttesting jest enzyme, state management redux'll the create-react-app tool quickly set .we assume you're already using node.js npm. may want get sense the basics react.install create-react-app're going use create-react-app it sets useful tools canonical defaults react projects. is a command-line utility scaffold new react projects.npm install -g create-react-appcreate new project'll create new project called -app:create-react-app -app --scripts-version=react-scripts-tsreact-scripts-ts is set adjustments take standard create-react-app project pipeline bring typescript the mix. this point, project layout should like following:-app/ .gitignore node_modules/ public/ src/ ... package.json tsconfig.json tslint.json note:tsconfig.json contains typescript-specific options our project.tslint.json stores settings our linter, tslint, use.package.json contains dependencies, well some shortcuts commands 'd to run testing, previewing, deploying app.public contains static assets the html page 're planning deploy , or images. can delete file this folder apart index.html.src contains typescript css code. index.tsx is entry-point our file, is mandatory.running projectrunning project is simple runningnpm run start runs start script specified our package.json, will spawn off server reloads page we save files.typically server runs http://localhost:3000, should automatically opened you. tightens iteration loop allowing to quickly preview changes.testing projecttesting is just command away:npm run test command runs jest, incredibly useful testing utility, against files whose extensions end .test.ts .spec.ts. with npm run start command, jest automatically run soon it detects changes. you'd , you run npm run start npm run test side side that can preview changes test simultaneously.creating production build running project npm run start, didn't end with optimized build.typically, want code ship users be fast small possible.certain optimizations minification accomplish , but often more .we call builds this \"production\" builds ( opposed development builds). run production build, runnpm run build will create optimized js css build ./build/static/js ./build/static/css respectively. won't need run production build of time, it is useful you need measure things the final size your app.creating component're going write hello component. component take name whatever want greet ( we'll call name), optionally number exclamation marks trail (enthusiasmlevel). we write something <hello name=\"daniel\" enthusiasmlevel={3} />, component should render something <div>hello daniel!!!</div>. enthusiasmlevel isn't specified, component should default showing exclamation mark. enthusiasmlevel is 0 negative, should throw error.'ll write hello.tsx:// src/components/hello.tsximport * react 'react';export interface props { name: string; enthusiasmlevel?: number;}function hello({ name, enthusiasmlevel = 1 }: props) { (enthusiasmlevel <= 0) { throw error(' could a little more enthusiastic. :d'); } return ( <div classname=\"hello\"> <div classname=\"greeting\"> hello {name + getexclamationmarks(enthusiasmlevel)} </div> </div> );}export default hello;// helpersfunction getexclamationmarks(numchars: number) { return array(numchars + 1).join('!');}notice we defined type named props specifies properties component take.name is required string, enthusiasmlevel is optional number ( you tell the ? we wrote after name). also wrote hello a stateless function component ( sfc). be specific, hello is function takes props object, destructures .if enthusiasmlevel isn't given our props object, will default 1.writing functions is of primary ways react allows to components. we wanted, could written out a class follows:class hello extends react.component<props, object> { render() { const { name, enthusiasmlevel = 1 } = .props; (enthusiasmlevel <= 0) { throw error(' could a little more enthusiastic. :d'); } return ( <div classname=\"hello\"> <div classname=\"greeting\"> hello {name + getexclamationmarks(enthusiasmlevel)} </div> </div> ); }}classes are useful our component instances some state. we don't really need think state this example - fact, specified as object react.component<props, object>, writing sfc tends be shorter.local component state is more useful the presentational level creating generic ui elements can shared between libraries. our application's lifecycle, will revisit applications manage general state redux a bit. that 've written component, let's dive index.tsx replace render <app /> a render <hello ... />. we'll import at top the file:import hello './components/hello'; then change our render call:reactdom.render( <hello name=\"typescript\" enthusiasmlevel={10} />, document.getelementbyid('root') htmlelement);type assertions final thing 'll point in section is line document.getelementbyid('root') htmlelement. syntax is called type assertion, sometimes called cast. is useful of telling typescript the real type an expression is you better the type checker. reason need do in case is getelementbyid's return type is htmlelement | null.put simply, getelementbyid returns null it 't find element a given id.'re assuming getelementbyid actually succeed, we need convince typescript that using as syntax.typescript has trailing \"bang\" syntax (!), removes null undefined the prior expression. we have written document.getelementbyid('root')!, in case wanted be bit more explicit.adding style styling component our setup is easy. style hello component, can create css file src/components/hello.css..hello { text-align: center; margin: 20px; font-size: 48px; font-family: 'segoe ui', tahoma, geneva, verdana, sans-serif;}.hello button { margin-left: 25px; margin-right: 25px; font-size: 40px; min-width: 50px;} tools create-react-app uses (namely, webpack various loaders) allow to import stylesheets 're interested .when build runs, imported .css files be concatenated an output file. in src/components/hello.tsx, 'll add following import.import './hello.css';writing tests jest had certain set assumptions our hello component.let's reiterate they were: we write something <hello name=\"daniel\" enthusiasmlevel={3} />, component should render something <div>hello daniel!!!</div>. enthusiasmlevel isn't specified, component should default showing exclamation mark. enthusiasmlevel is 0 negative, should throw error. can these requirements write few tests our components. first, let's install enzyme.enzyme is common tool the react ecosystem makes easier write tests how components behave. default, application includes library called jsdom allow to simulate dom test runtime behavior without browser.enzyme is similar, builds jsdom makes easier make certain queries our components.let's install as development- dependency.npm install -d enzyme @types/enzyme react-addons-test-utilsnotice installed packages enzyme well @types/enzyme. enzyme package refers the package containing javascript code actually gets run, while @types/enzyme is package contains declaration files (.d.ts files) that typescript understand you use enzyme. can learn more @types packages here. also had install react-addons-test-utils. is something enzyme expects be installed. that 've got enzyme set , let's start writing test!let's create file named src/components/hello.test.tsx, adjacent our hello.tsx file earlier.// src/components/hello.test.tsximport * react 'react';import * enzyme 'enzyme';import hello './hello';('renders correct text no enthusiasm level is given', () => { const hello = enzyme.shallow(<hello name='daniel' />); expect(hello.find(\".greeting\").text()).toequal('hello daniel!')});('renders correct text an explicit enthusiasm 1', () => { const hello = enzyme.shallow(<hello name='daniel' enthusiasmlevel={1}/>); expect(hello.find(\".greeting\").text()).toequal('hello daniel!')});('renders correct text an explicit enthusiasm level 5', () => { const hello = enzyme.shallow(<hello name='daniel' enthusiasmlevel={5} />); expect(hello.find(\".greeting\").text()).toequal('hello daniel!!!!!');});('throws the enthusiasm level is 0', () => { expect(() => { enzyme.shallow(<hello name='daniel' enthusiasmlevel={0} />); }).tothrow();});('throws the enthusiasm level is negative', () => { expect(() => { enzyme.shallow(<hello name='daniel' enthusiasmlevel={-1} />); }).tothrow();}); tests are extremely basic, you should able get gist things.adding state management this point, all 're using react is fetching data once displaying , you consider yourself done. if 're developing app 's more interactive, you may need add state management.state management general its own, react is useful library creating composable views.however, react doesn't with facility synchronizing data between application. far a react component is concerned, data flows down through children through props specify each element. react its own does provide built- support state management, react community uses libraries redux mobx.redux relies synchronizing data through centralized immutable store data, updates that data trigger re-render our application.state is updated an immutable fashion sending explicit action messages must handled functions called reducers. of explicit nature, is often easier reason how action affect state your program.mobx relies functional reactive patterns where state is wrapped through observables passed through props.keeping state fully synchronized any observers is done simply marking state observable. a nice bonus, library is already written typescript. are various merits tradeoffs both.generally redux tends see more widespread usage, for purposes this tutorial, 'll focus adding redux;however, should feel encouraged explore both. following section may a steep learning curve. strongly suggest familiarize yourself redux through documentation.setting stage actions doesn't sense add redux unless state our application changes. need source actions will trigger changes take place. can a timer, something the ui a button. our purposes, 're going add buttons control enthusiasm level our hello component.installing redux add redux, 'll install redux react-redux, well their types, a dependency.npm install -s redux react-redux @types/react-redux this case didn't need install @types/redux redux already comes its own definition files (.d.ts files).defining app's state need define shape the state redux store. this, can create file called src/types/index.tsx will contain definitions types we might throughout program.// src/types/index.tsxexport interface storestate { languagename: string; enthusiasmlevel: number;} intention is languagename be programming language app was written (i.e. typescript javascript) enthusiasmlevel vary. we write first container, 'll understand why intentionally made state slightly different our props.adding actionslet's start off creating set message types our app respond in src/constants/index.tsx.// src/constants/index.tsxexport const increment_enthusiasm = 'increment_enthusiasm';export type increment_enthusiasm = typeof increment_enthusiasm;export const decrement_enthusiasm = 'decrement_enthusiasm';export type decrement_enthusiasm = typeof decrement_enthusiasm; const/type pattern allows to typescript's string literal types an easily accessible refactorable .next, 'll create set actions functions can create actions src/actions/index.tsx.import * constants '../constants'export interface incremententhusiasm { type: constants.increment_enthusiasm;}export interface decremententhusiasm { type: constants.decrement_enthusiasm;}export type enthusiasmaction = incremententhusiasm | decremententhusiasm;export function incremententhusiasm(): incremententhusiasm { return { type: constants.increment_enthusiasm }}export function decremententhusiasm(): decremententhusiasm { return { type: constants.decrement_enthusiasm }}'ve created types describe increment actions decrement actions should like. also created type (enthusiasmaction) describe cases where action be increment a decrement.finally, made functions actually manufacture actions we use instead writing bulky object literals.'s clearly boilerplate here, you should feel free look libraries redux-actions once 've got hang things.adding reducer're ready write first reducer!reducers are functions generate changes creating modified copies our application's state, that no side effects. other words, 're we call pure functions. reducer go under src/reducers/index.tsx. function be ensure increments raise enthusiasm level 1, that decrements reduce enthusiasm level 1, that level never falls below 1.// src/reducers/index.tsximport { enthusiasmaction } '../actions';import { storestate } '../types/index';import { increment_enthusiasm, decrement_enthusiasm } '../constants/index';export function enthusiasm(state: storestate, action: enthusiasmaction): storestate { switch (action.type) { case increment_enthusiasm: return { ...state, enthusiasmlevel: state.enthusiasmlevel + 1 }; case decrement_enthusiasm: return { ...state, enthusiasmlevel: math.max(1, state.enthusiasmlevel - 1) }; } return state;}notice we're using object spread (...state) allows to create shallow copy our state, while replacing enthusiasmlevel.'s important the enthusiasmlevel property last, since otherwise would overridden the property our old state. may to write few tests your reducer.since reducers are pure functions, can passed arbitrary data. every input, reducers tested checking newly produced state.consider looking jest's toequal method accomplish .making container writing redux, will often write components well containers.components are often data-agnostic, work mostly a presentational level.containers typically wrap components feed any data is necessary display modify state. can read more this concept dan abramov's article presentational container components. let's update src/components/hello.tsx that can modify state.'ll add optional callback properties props named onincrement ondecrement:export interface props { name: string; enthusiasmlevel?: number; onincrement?: () => void; ondecrement?: () => void;} we'll bind those callbacks two buttons we'll add our component.function hello({ name, enthusiasmlevel = 1, onincrement, ondecrement }: props) { (enthusiasmlevel <= 0) { throw error(' could a little more enthusiastic. :d'); } return ( <div classname=\"hello\"> <div classname=\"greeting\"> hello {name + getexclamationmarks(enthusiasmlevel)} </div> <div> <button onclick={ondecrement}>-</button> <button onclick={onincrement}>+</button> </div> </div> );} general, 'd a idea write few tests onincrement ondecrement being triggered their respective buttons are clicked. it shot get hang writing tests your components. that component is updated, 're ready wrap into container.let's create file named src/containers/hello.tsx start off the following imports.import hello '../components/hello';import * actions '../actions/';import { storestate } '../types/index';import { connect, dispatch } 'react-redux'; real key pieces here are original hello component well the connect function react-redux.connect be able actually our original hello component turn into container using functions:mapstatetoprops massages data the current store part the shape our component needs.mapdispatchtoprops creates callback props pump actions our store using given dispatch function. we recall, application state consists two properties: languagename enthusiasmlevel. hello component, the hand, expected name an enthusiasmlevel.mapstatetoprops get relevant data the store, adjust if necessary, our component's props.let's ahead write .export function mapstatetoprops({ enthusiasmlevel, languagename }: storestate) { return { enthusiasmlevel, name: languagename, }}note mapstatetoprops creates 2 of 4 the properties hello component expects.namely, still to pass the onincrement ondecrement callbacks.mapdispatchtoprops is function takes dispatcher function. dispatcher function pass actions our store make updates, we create pair callbacks will call dispatcher necessary.export function mapdispatchtoprops(dispatch: dispatch<actions.enthusiasmaction>) { return { onincrement: () => dispatch(actions.incremententhusiasm()), ondecrement: () => dispatch(actions.decremententhusiasm()), }}finally, 're ready call connect.connect first mapstatetoprops mapdispatchtoprops, then return another function we use wrap component. resulting container is defined the following line code:export default connect(mapstatetoprops, mapdispatchtoprops)(hello); we're finished, file should like :// src/containers/hello.tsximport hello '../components/hello';import * actions '../actions/';import { storestate } '../types/index';import { connect, dispatch } 'react-redux';export function mapstatetoprops({ enthusiasmlevel, languagename }: storestate) { return { enthusiasmlevel, name: languagename, }}export function mapdispatchtoprops(dispatch: dispatch<actions.enthusiasmaction>) { return { onincrement: () => dispatch(actions.incremententhusiasm()), ondecrement: () => dispatch(actions.decremententhusiasm()), }}export default connect(mapstatetoprops, mapdispatchtoprops)(hello);creating storelet's back src/index.tsx. put all together, need create store an initial state, set up all our reducers.import { createstore } 'redux';import { enthusiasm } './reducers/index';import { storestate } './types/index';const store = createstore<storestate>(enthusiasm, { enthusiasmlevel: 1, languagename: 'typescript',});store is, you might've guessed, central store our application's global state.next, 're going swap use ./src/components/hello ./src/containers/hello use react-redux's provider wire our props our container.'ll import each:import hello './containers/hello';import { provider } 'react-redux'; pass store through the provider's attributes:reactdom.render( <provider store={store}> <hello /> </provider>, document.getelementbyid('root') htmlelement);notice hello longer needs props, since used connect function adapt application's state our wrapped hello component's props.ejecting at point, feel there are certain customizations the create-react-app setup has made difficult, can always opt- and the various configuration options need. example, you'd to add webpack plugin, might necessary take advantage the \"eject\" functionality create-react-app provides.simply runnpm run eject you should good go! a heads , you may to commit your before running eject. cannot undo eject command, opting is permanent unless can recover a commit prior running eject.next stepscreate-react-app comes a lot great stuff.much it is documented the default readme.md was generated our project, give a quick read. you still to learn more redux, can check the official website documentation. same goes mobx. you to eject some point, may need know little bit more webpack. can check our react & webpack walkthrough here. some point might need routing. are several solutons, react-router is probably most popular redux projects, is often used conjunction react-router-redux."
}