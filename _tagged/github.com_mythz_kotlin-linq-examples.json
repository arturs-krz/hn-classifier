{
	"_id": "14365945",
	"site": "https://github.com/mythz/kotlin-linq-examples",
	"title": "101 C# LINQ Samples in Kotlin",
	"author": "mythz",
	"date": "2017-06-13T13:57:08.312Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"kotlin"
		]
	},
	"content": "readme.md 101 c# linq samples kotlin project contains c# 101 linq samplesrewritten kotlin. the existing java linq examples,kotlin examples run have results displayed inside android app courtesy therich support kotlin android studio.compare kotlin other linq examples written :javaswiftclojuredartelixircomparing against java examplesshowcases power expressiveness both languages ability developing native android appswhere java 7 is far worst language functional/linq-style programming vs kotlin is of best - resulting a much more readable maintainable code-base 's less 1/2 size.kotlin android resources help getting started kotlin, 'll maintain links useful resources helping develop android apps kotlin below:getting started android kotlin (kotlinlang.org)kotlin android developers (javaadvent.com)android development kotlin - jake wharton (youtube.com)call .net web services kotlin you're looking create effortles typed api consuming .net web services jvm kotlin android apps checkout servicestack'skotlin add servicestack reference.running exampleseach the linq examples be run the included android app its results logged the screen:run included android studio project execute the examples. can choose only run specific examples commenting any the sections 're interested mainactivity.kt. copy the linq examples output is available linq-log.txt.contents samples below mirrors c# linq samples layout the names the top-level java methods matching corresponding c# examples.linq - restriction operators / msdn c#linq - projection operators / msdn c#linq - partitioning operators / msdn c#linq - ordering operators / msdn c#linq - grouping operators / msdn c#linq - set operators / msdn c#linq - conversion operators / msdn c#linq - element operators / msdn c#linq - generation operators / msdn c#linq - quantifiers / msdn c#linq - aggregate operators / msdn c#linq - miscellaneous operators / msdn c#linq - query execution / msdn c#linq - join operators / msdn c#kotlin functional utilskotlin has great language built- library support simplify programming a functional-style where of linq examplesare able use kotlins built- utils. of more advanced linq examples join's were missing kotlins standard library, this leverage existing implementations servicestack's java android client library: net.servicestack:android.install include in android studio project, add to build.gradle dependency, e.g:dependencies { compile filetree(dir: 'libs', include: ['*.jar']) compile 'net.servicestack:android:1.0.31'}pure java projects should add net.servicestack:client dependency instead:dependencies { compile 'net.servicestack:client:1.0.31'}alternatively library is automatically added adding typed remote service reference servicestack ide plugins intellij idea eclipse maven projects.kotlin extensions a 2 extensionswere required cover kotlin's missing difference api.side--side - c# linq vs kotlin a side--side comparison, original c# source code is displayed above equivalent kotlin translation. output shows logging output running kotlin android app.outputs ending ... illustrates a partial response is displayed. c# objectdumper util used is downloadable msdn - objectdumper.ziplinq - restriction operatorslinq1: where - simple 1//c#public void linq1() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var lownums = n numbers where n < 5 select n; console.writeline(\"numbers < 5:\"); foreach (var x lownums) { console.writeline(x); } } //kotlinfun linq1() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val lownums = numbers.filter { < 5 } log.d(\"numbers < 5:\") lownums.foreach { log.d() }}outputnumbers < 5:41320linq2: where - simple 2//c#public void linq2() { list<product> products = getproductlist(); var soldoutproducts = p products where p.unitsinstock == 0 select p; console.writeline(\"sold products:\"); foreach (var product soldoutproducts) { console.writeline(\"{0} is sold !\", product.productname); } } //kotlinfun linq2() { val soldoutproducts = products.filter { .unitsinstock == 0 } log.d(\"sold products:\") soldoutproducts.foreach { log.d(\"${.productname} is sold !\") }}outputsold products:chef anton's gumbo mix is sold !alice mutton is sold !thüringer rostbratwurst is sold !gorgonzola telino is sold !perth pasties is sold !linq3: where - simple 3//c#public void linq3() { list<product> products = getproductlist(); var expensiveinstockproducts = p products where p.unitsinstock > 0 && p.unitprice > 3.00m select p; console.writeline(\"-stock products cost more 3.00:\"); foreach (var product expensiveinstockproducts) { console.writeline(\"{0} is stock costs more 3.00.\", product.productname); } } //kotlinfun linq3() { val expensiveinstockproducts = products.filter { .unitsinstock > 0 && .unitprice > 3.00 } log.d(\"-stock products cost more 3.00:\") expensiveinstockproducts.foreach { log.d(\"${.productname} is stock costs more 3.00.\") }}output-stock products cost more 3.00:chai is stock costs more 3.00.chang is stock costs more 3.00.aniseed syrup is stock costs more 3.00....linq4: where - drilldown//c#public void linq4() { list<customer> customers = getcustomerlist(); var wacustomers = c customers where c.region == \"wa\" select c; console.writeline(\"customers washington their orders:\"); foreach (var customer wacustomers) { console.writeline(\"customer {0}: {1}\", customer.customerid, customer.companyname); foreach (var order customer.orders) { console.writeline(\" order {0}: {1}\", order.orderid, order.orderdate); } } } //kotlinfun linq4() { val wacustomers = customers.filter { \"wa\" == .region } log.d(\"customers washington their orders:\") wacustomers.foreach { c -> log.d(\"customer ${c.customerid} ${c.companyname}\") c.orders.foreach { log.d(\" order ${.orderid}: ${datefmt(.orderdate)}\") } }}outputcustomers washington their orders:customer lazyk lazy k kountry store order 10482: 1997/03/21 order 10545: 1997/05/22customer traih trail's head gourmet provisioners order 10574: 1997/06/19 order 10577: 1997/06/23 order 10822: 1998/01/08 ...linq5: where - indexed//c#public void linq5() { string[] digits = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var shortdigits = digits.where((digit, index) => digit.length < index); console.writeline(\"short digits:\"); foreach (var d shortdigits) { console.writeline(\" word {0} is shorter its value.\", d); } }//kotlinfun linq5() { val digits = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val shortdigits = digits.filterindexed { , it -> .length < } log.d(\"short digits:\") shortdigits.foreach { log.d(\" word $ is shorter its value.\") }}outputshort digits: word five is shorter its value. word six is shorter its value. word seven is shorter its value. word eight is shorter its value. word nine is shorter its value.linq - projection operatorslinq6: select - simple 1//c#public void linq6() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var numsplusone = n numbers select n + 1; console.writeline(\"numbers + 1:\"); foreach (var in numsplusone) { console.writeline(); } }//kotlinfun linq06() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val numsplusone = numbers.map { + 1 } log.d(\"numbers + 1:\") numsplusone.foreach { log.d() }}outputnumbers + 1:65241097831linq7: select - simple 2//c#public void linq7() { list<product> products = getproductlist(); var productnames = p products select p.productname; console.writeline(\"product names:\"); foreach (var productname productnames) { console.writeline(productname); } }//kotlinfun linq07() { val productnames = products.map { .productname } log.d(\"product names:\") productnames.foreach { log.d() }}outputproduct names:chaichanganiseed syrupchef anton's cajun seasoningchef anton's gumbo mix...linq8: select - transformation//c#public void linq8() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; string[] strings = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var textnums = n numbers select strings[n]; console.writeline(\"number strings:\"); foreach (var s textnums) { console.writeline(s); } }//kotlinfun linq08() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val strings = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val textnums = numbers.map { strings[] } log.d(\"number strings:\") textnums.foreach { log.d() }}outputnumber strings:fivefourthreenineeightsixsevenzerolinq9: select - anonymous types 1//c#public void linq9() { string[] words = { \"apple\", \"blueberry\", \"cherry\" }; var upperlowerwords = w words select { upper = w.toupper(), lower = w.tolower() }; foreach (var ul upperlowerwords) { console.writeline(\"uppercase: {0}, lowercase: {1}\", ul.upper, ul.lower); } }//kotlinfun linq09() { val words = arrayof(\"apple\", \"blueberry\", \"cherry\") val upperlowerwords = words.map { w -> pair(w.touppercase(), w.tolowercase()) } upperlowerwords.foreach { log.d(\"uppercase: ${.first}, lowercase: ${.second}\") }}outputuppercase: apple, lowercase: appleuppercase: blueberry, lowercase: blueberryuppercase: cherry, lowercase: cherrylinq10: select - anonymous types 2//c#public void linq10() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; string[] strings = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var digitoddevens = n numbers select { digit = strings[n], = (n % 2 == 0) }; foreach (var d digitoddevens) { console.writeline(\" digit {0} is {1}.\", d.digit, d. ? \"even\" : \"odd\"); } }//kotlinfun linq10() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val strings = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val digitoddevens = numbers.map { pair(strings[], it % 2 == 0) } digitoddevens.foreach { val (d,iseven) = log.d(\" digit $d is ${ (iseven) \"\" else \"odd\"}.\") }}output digit five is odd. digit four is .the digit is odd. digit three is odd. digit nine is odd. digit eight is .the digit six is .the digit seven is odd. digit is .the digit zero is .linq11: select - anonymous types 3//c#public void linq11() { list<product> products = getproductlist(); var productinfos = p products select { p.productname, p.category, price = p.unitprice }; console.writeline(\"product info:\"); foreach (var productinfo productinfos) { console.writeline(\"{0} is the category {1} costs {2} per unit.\", productinfo.productname, productinfo.category, productinfo.price); } }//kotlinfun linq11() { val productinfos = products.map { p -> triple(p.productname, p.category, p.unitprice) } log.d(\"product info:\") productinfos.foreach { val (name,category,cost) = log.d(\"$name is the category $category costs $cost per unit.\") }}outputproduct info:chai is the category beverages costs 18.0 per unit.chang is the category beverages costs 19.0 per unit.aniseed syrup is the category condiments costs 10.0 per unit....linq12: select - indexed//c#public void linq12() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var numsinplace = numbers.select((num, index) => { num = num, inplace = (num == index) }); console.writeline(\"number: -place?\"); foreach (var n numsinplace) { console.writeline(\"{0}: {1}\", n.num, n.inplace); } }//kotlinfun linq12() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val numsinplace = numbers.mapindexed { index, n -> pair(n, n == index) } log.d(\"number: -place?\") numsinplace.foreach { log.d(\"${.first.tostring()}: ${.second}\") }}outputnumber: -place?5: false4: false1: false3: true9: false8: false6: true7: true2: false0: falselinq13: select - filtered//c#public void linq13() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; string[] digits = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var lownums = n numbers where n < 5 select digits[n]; console.writeline(\"numbers < 5:\"); foreach (var num lownums) { console.writeline(num); } }//kotlinfun linq13() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val digits = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val lownums = numbers.filter { < 5 }.map { digits[] } log.d(\"numbers < 5:\") lownums.foreach { log.d() }}outputnumbers < 5:fourthreezerolinq14: selectmany - compound 1//c#public void linq14() { int[] numbersa = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersb = { 1, 3, 5, 7, 8 }; var pairs = a numbersa b numbersb where < b select { a, b }; console.writeline(\"pairs where < b:\"); foreach (var pair pairs) { console.writeline(\"{0} is less {1}\", pair., pair.b); } }//kotlinfun linq14() { val numbersa = intarrayof(0, 2, 4, 5, 6, 8, 9) val numbersb = intarrayof(1, 3, 5, 7, 8) val pairs = numbersa.flatmap { -> numbersb.filter { b -> < b } .map { pair(, it) } } log.d(\"pairs where < b:\") pairs.foreach { log.d(\"${.first.tostring()} is less ${it.second}\") }}outputpairs where < b:0 is less 10 is less 30 is less 50 is less 70 is less 82 is less 32 is less 52 is less 72 is less 84 is less 54 is less 74 is less 85 is less 75 is less 86 is less 76 is less 8linq15: selectmany - compound 2//c#public void linq15() { list<customer> customers = getcustomerlist(); var orders = c customers o c.orders where o.total < 500.00m select { c.customerid, o.orderid, o.total }; objectdumper.write(orders); }//kotlinfun linq15() { val orders = customers.flatmap { c -> c.orders.filter { .total < 500 } .map { o -> triple(c.customerid, o.orderid, o.total) } } orders.foreach { log.d() }}output(alfki, 10702, 330.0)(alfki, 10952, 471.2)(anatr, 10308, 88.8)(anatr, 10625, 479.75)...linq16: selectmany - compound 3//c#public void linq16() { list<customer> customers = getcustomerlist(); var orders = c customers o c.orders where o.orderdate >= datetime(1998, 1, 1) select { c.customerid, o.orderid, o.orderdate }; objectdumper.write(orders); }//kotlinfun linq16() { val date = date(98, 0, 1) //= 1998-01-01 val orders = customers.flatmap { c -> c.orders.filter { .orderdate >= date } .map { o -> triple(c.customerid, o.orderid, o.orderdate) } } orders.foreach { log.d() }}output(alfki, 10835, thu jan 15 00:00:00 pst 1998)(alfki, 10952, mon mar 16 00:00:00 pst 1998)(alfki, 11011, thu apr 09 00:00:00 pdt 1998)(anatr, 10926, wed mar 04 00:00:00 pst 1998)(anton, 10856, wed jan 28 00:00:00 pst 1998)...linq17: selectmany - assignment//c#public void linq17() { list<customer> customers = getcustomerlist(); var orders = c customers o c.orders where o.total >= 2000.0m select { c.customerid, o.orderid, o.total }; objectdumper.write(orders); }//kotlinfun linq17() { val orders = customers.flatmap { c -> c.orders.filter { .total >= 2000 } .map { o -> triple(c.customerid, o.orderid, o.total) } } orders.foreach { log.d() }}output(anton, 10573, 2082.0)(arout, 10558, 2142.9)(arout, 10953, 4441.25)(bergs, 10384, 2222.4)(bergs, 10524, 3192.65)...linq18: selectmany - multiple //c#public void linq18() { list<customer> customers = getcustomerlist(); datetime cutoffdate = datetime(1997, 1, 1); var orders = c customers where c.region == \"wa\" o c.orders where o.orderdate >= cutoffdate select { c.customerid, o.orderid }; objectdumper.write(orders); }//kotlinfun linq18() { val cutoffdate = date(97, 0, 1) //1997-01-01 val orders = customers .filter { .region == \"wa\" }.flatmap { c -> c.orders.filter { .orderdate > cutoffdate } .map { o -> pair(c.customerid, o.orderid) } } orders.foreach { log.d() }}output(lazyk, 10482)(lazyk, 10545)(traih, 10574)(traih, 10577)(traih, 10822)(whitc, 10469)(whitc, 10483)(whitc, 10504)(whitc, 10596)(whitc, 10693)(whitc, 10696)(whitc, 10723)(whitc, 10740)(whitc, 10861)(whitc, 10904)(whitc, 11032)(whitc, 11066)linq19: selectmany - indexed//c#public void linq19() { list<customer> customers = getcustomerlist(); var customerorders = customers.selectmany( (cust, custindex) => cust.orders.select(o => \"customer #\" + (custindex + 1) + \" has order orderid \" + o.orderid)); objectdumper.write(customerorders); }//kotlinfun linq19() { var custindex = 0 val customerorders = customers.flatmap { c -> c.orders.mapindexed { index, o -> \"customer #$index has order orderid ${o.orderid}\" } } customerorders.foreach { log.d() }}outputcustomer #1 has order orderid 10643customer #1 has order orderid 10692customer #1 has order orderid 10702customer #1 has order orderid 10835customer #1 has order orderid 10952customer #1 has order orderid 11011customer #2 has order orderid 10308customer #2 has order orderid 10625customer #2 has order orderid 10759customer #2 has order orderid 10926...linq - partitioning operatorslinq20: - simple//c#public void linq20() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var first3numbers = numbers.(3); console.writeline(\" 3 numbers:\"); foreach (var n first3numbers) { console.writeline(n); } }//kotlinfun linq20() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val first3numbers = numbers.(3) log.d(\" 3 numbers:\") first3numbers.foreach { log.d() }}output 3 numbers:541linq21: - nested//c#public void linq21() { list<customer> customers = getcustomerlist(); var first3waorders = ( c customers o c.orders where c.region == \"wa\" select { c.customerid, o.orderid, o.orderdate }) .(3); console.writeline(\" 3 orders wa:\"); foreach (var order first3waorders) { objectdumper.write(order); } }//kotlinfun linq21() { val first3waorders = customers .filter { .region == \"wa\" } .flatmap { c -> c.orders.map { o -> triple(c.customerid, o.orderid, o.orderdate) } } .(3) log.d(\" 3 orders wa:\") first3waorders.foreach { log.d() }}output 3 orders wa:(lazyk, 10482, fri mar 21 00:00:00 pst 1997)(lazyk, 10545, thu may 22 00:00:00 pdt 1997)(traih, 10574, thu jun 19 00:00:00 pdt 1997)linq22: skip - simple//c#public void linq22() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var allbutfirst4numbers = numbers.skip(4); console.writeline(\" but 4 numbers:\"); foreach (var n allbutfirst4numbers) { console.writeline(n); } }//kotlinfun linq22() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val allbutfirst4numbers = numbers.drop(4) log.d(\" but 4 numbers:\") allbutfirst4numbers.foreach { log.d() }}output but 4 numbers:986720linq23: skip - nested//c#public void linq23() { list<customer> customers = getcustomerlist(); var waorders = c customers o c.orders where c.region == \"wa\" select { c.customerid, o.orderid, o.orderdate }; var allbutfirst2orders = waorders.skip(2); console.writeline(\" but 2 orders wa:\"); foreach (var order allbutfirst2orders) { objectdumper.write(order); } }//kotlinfun linq23() { val waorders = customers .filter { .region == \"wa\" } .flatmap { c -> c.orders.map { o -> triple(c.customerid, o.orderid, o.orderdate) } } val allbutfirst2orders = waorders.drop(2) log.d(\" but 2 orders wa:\") allbutfirst2orders.foreach { log.d() }}output but 2 orders wa:(traih, 10574, thu jun 19 00:00:00 pdt 1997)(traih, 10577, mon jun 23 00:00:00 pdt 1997)(traih, 10822, thu jan 08 00:00:00 pst 1998)(whitc, 10269, wed jul 31 00:00:00 pdt 1996)(whitc, 10344, fri nov 01 00:00:00 pst 1996)(whitc, 10469, mon mar 10 00:00:00 pst 1997)(whitc, 10483, mon mar 24 00:00:00 pst 1997)(whitc, 10504, fri apr 11 00:00:00 pdt 1997)(whitc, 10596, fri jul 11 00:00:00 pdt 1997)(whitc, 10693, mon oct 06 00:00:00 pdt 1997)(whitc, 10696, wed oct 08 00:00:00 pdt 1997)(whitc, 10723, thu oct 30 00:00:00 pst 1997)(whitc, 10740, thu nov 13 00:00:00 pst 1997)(whitc, 10861, fri jan 30 00:00:00 pst 1998)(whitc, 10904, tue feb 24 00:00:00 pst 1998)(whitc, 11032, fri apr 17 00:00:00 pdt 1998)(whitc, 11066, fri may 01 00:00:00 pdt 1998)linq24: takewhile - simple//c#public void linq24() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var firstnumberslessthan6 = numbers.takewhile(n => n < 6); console.writeline(\" numbers less 6:\"); foreach (var n firstnumberslessthan6) { console.writeline(n); } }//kotlinfun linq24() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val firstnumberslessthan6 = numbers.takewhile { < 6 } log.d(\" numbers less 6:\") firstnumberslessthan6.foreach { log.d() }}output numbers less 6:5413linq25: takewhile - indexed//c#public void linq25() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var firstsmallnumbers = numbers.takewhile((n, index) => n >= index); console.writeline(\" numbers less their position:\"); foreach (var n firstsmallnumbers) { console.writeline(n); } }//kotlinfun linq25() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) var index = 0 val firstsmallnumbers = numbers.takewhile { >= index++ } log.d(\" numbers less their position:\") firstsmallnumbers.foreach { log.d() }}output numbers less their position:54linq26: skipwhile - simple//c#public void linq26() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var allbutfirst3numbers = numbers.skipwhile(n => n % 3 != 0); console.writeline(\" elements starting first element divisible 3:\"); foreach (var n allbutfirst3numbers) { console.writeline(n); } }//kotlinfun linq26() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val allbutfirst3numbers = numbers.dropwhile { % 3 != 0 } log.d(\" elements starting first element divisible 3:\") allbutfirst3numbers.foreach { log.d() }}output elements starting first element divisible 3:3986720linq27: skipwhile - indexed//c#public void linq27() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var laternumbers = numbers.skipwhile((n, index) => n >= index); console.writeline(\" elements starting first element less its position:\"); foreach (var n laternumbers) { console.writeline(n); } }//kotlinfun linq27() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) var index = 0 val laternumbers = numbers.dropwhile { >= index++ } log.d(\" elements starting first element less its position:\") laternumbers.foreach { log.d() }}output elements starting first element less its position:13986720linq - ordering operatorslinq28: orderby - simple 1//c#public void linq28() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; var sortedwords = w words orderby w select w; console.writeline(\" sorted list words:\"); foreach (var w sortedwords) { console.writeline(w); } }//kotlinfun linq28() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val sortedwords = words.sorted() log.d(\" sorted list words:\") sortedwords.foreach { log.d() }}output sorted list words:appleblueberrycherrylinq29: orderby - simple 2//c#public void linq29() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; var sortedwords = w words orderby w.length select w; console.writeline(\" sorted list words ( length):\"); foreach (var w sortedwords) { console.writeline(w); } }//kotlinfun linq29() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val sortedwords = words.sortedby { s -> s.length } log.d(\" sorted list words ( length):\") sortedwords.foreach { log.d() }}output sorted list words ( length):applecherryblueberrylinq30: orderby - simple 3//c#public void linq30() { list<product> products = getproductlist(); var sortedproducts = p products orderby p.productname select p; objectdumper.write(sortedproducts); }//kotlinfun linq30() { val sortedproducts = products.sortedby { .productname } sortedproducts.foreach { log.d() }}output(product id=17, name=alice mutton, cat=meat/poultry, price=39.0, instock=0)(product id=3, name=aniseed syrup, cat=condiments, price=10.0, instock=13)(product id=40, name=boston crab meat, cat=seafood, price=18.4, instock=123)(product id=60, name=camembert pierrot, cat=dairy products, price=34.0, instock=19)(product id=18, name=carnarvon tigers, cat=seafood, price=62.5, instock=42)...linq31: orderby - comparer//c#public void linq31() { string[] words = { \"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\" }; var sortedwords = words.orderby( => a, caseinsensitivecomparer()); objectdumper.write(sortedwords); } //kotlinfun linq31() { val words = arrayof(\"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\") val sortedwords = words.sortedwith(string.case_insensitive_order) sortedwords.foreach { log.d() }}outputabacusappleblueberrybranchcherrycloverlinq32: orderbydescending - simple 1//c#public void linq32() { double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 }; var sorteddoubles = d doubles orderby d descending select d; console.writeline(\" doubles highest lowest:\"); foreach (var d sorteddoubles) { console.writeline(d); } }//kotlinfun linq32() { val doubles = doublearrayof(1.7, 2.3, 1.9, 4.1, 2.9) val sorteddoubles = doubles.sorteddescending() log.d(\" doubles highest lowest:\") sorteddoubles.foreach { log.d() }}output doubles highest lowest:4.12.92.31.91.7linq33: orderbydescending - simple 2//c#public void linq33() { list<product> products = getproductlist(); var sortedproducts = p products orderby p.unitsinstock descending select p; objectdumper.write(sortedproducts); }//kotlinfun linq33() { val sortedproducts = products.sortedbydescending { .unitsinstock } sortedproducts.foreach { log.d() }}output(product id=75, name=rhönbräu klosterbier, cat=beverages, price=7.75, instock=125)(product id=40, name=boston crab meat, cat=seafood, price=18.4, instock=123)(product id=6, name=grandma's boysenberry spread, cat=condiments, price=25.0, instock=120)(product id=55, name=pâté chinois, cat=meat/poultry, price=24.0, instock=115)(product id=61, name=sirop d'érable, cat=condiments, price=28.5, instock=113)...linq34: orderbydescending - comparer//c#public void linq34() { string[] words = { \"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\" }; var sortedwords = words.orderbydescending( => a, caseinsensitivecomparer()); objectdumper.write(sortedwords); } //kotlinfun linq34() { val words = arrayof(\"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\") val sortedwords = words.sortedwith(string.case_insensitive_order).reversed() sortedwords.foreach { log.d() }}outputclovercherrybranchblueberryappleabacuslinq35: thenby - simple//c#public void linq35() { string[] digits = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var sorteddigits = d digits orderby d.length, d select d; console.writeline(\"sorted digits:\"); foreach (var d sorteddigits) { console.writeline(d); } }//kotlinfun linq35() { val digits = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val sorteddigits = digits.sorted().sortedby { .length } log.d(\"sorted digits:\") sorteddigits.foreach { log.d() }}outputsorted digits:sixfivefourninezeroeightseventhreelinq36: thenby - comparer//c#public void linq36() { string[] words = { \"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\" }; var sortedwords = words.orderby( => a.length) .thenby( => a, caseinsensitivecomparer()); objectdumper.write(sortedwords); } //kotlinfun linq36() { val words = arrayof(\"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\") val sortedwords = words.sortedwith(string.case_insensitive_order).sortedby { .length } sortedwords.foreach { log.d() }}outputappleabacusbranchcherrycloverblueberrylinq37: thenbydescending - simple//c#public void linq37() { list<product> products = getproductlist(); var sortedproducts = p products orderby p.category, p.unitprice descending select p; objectdumper.write(sortedproducts); }//kotlinfun linq37() { val sortedproducts = orderbyall(products, comparator<product> { , b -> .category.compareto(b.category) }, comparator<product> { , b -> b.unitprice.compareto(.unitprice) }) sortedproducts.foreach { log.d() }}output(product id=38, name=côte de blaye, cat=beverages, price=263.5, instock=17)(product id=43, name=ipoh coffee, cat=beverages, price=46.0, instock=17)(product id=2, name=chang, cat=beverages, price=19.0, instock=17)(product id=1, name=chai, cat=beverages, price=18.0, instock=39)(product id=35, name=steeleye stout, cat=beverages, price=18.0, instock=20)(product id=39, name=chartreuse verte, cat=beverages, price=18.0, instock=69)(product id=76, name=lakkalikööri, cat=beverages, price=18.0, instock=57)(product id=70, name=outback lager, cat=beverages, price=15.0, instock=15)(product id=34, name=sasquatch ale, cat=beverages, price=14.0, instock=111)...linq38: thenbydescending - comparer//c#public void linq38() { string[] words = { \"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\" }; var sortedwords = words.orderby( => a.length) .thenbydescending( => a, caseinsensitivecomparer()); objectdumper.write(sortedwords); } //kotlinfun linq38() { val words = arrayof(\"apple\", \"abacus\", \"branch\", \"blueberry\", \"clover\", \"cherry\") val sortedwords = orderbyall(words, comparator<string> { , b -> integer.compare(.length, b.length) }, comparator<string> { , b -> string.case_insensitive_order.compare(b, ) }) sortedwords.foreach { log.d() }}outputappleclovercherrybranchabacusblueberrylinq39: reverse//c#public void linq39() { string[] digits = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; var reversedidigits = ( d digits where d[1] == '' select d) .reverse(); console.writeline(\" backwards list the digits a second character 'i':\"); foreach (var d reversedidigits) { console.writeline(d); } }//kotlinfun linq39() { val digits = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val reversedidigits = digits.filter { [1] == '' }.reversed() log.d(\" backwards list the digits a second character 'i':\") reversedidigits.foreach { log.d() }}output backwards list the digits a second character 'i':nineeightsixfivelinq - grouping operatorslinq40: groupby - simple 1//c#public void linq40() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var numbergroups = n numbers group n n % 5 g select { remainder = g.key, numbers = g }; foreach (var g numbergroups) { console.writeline(\"numbers a remainder {0} divided 5:\", g.remainder); foreach (var n g.numbers) { console.writeline(n); } } }//kotlinfun linq40() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val numbergroups = numbers.groupby { % 5 } .map { pair(.key, ) } numbergroups.foreach { -> val (remainder, g) = log.d(\"numbers a remainder $remainder divided 5:\") g.value.foreach { log.d() } }}outputnumbers a remainder 0 divided 5:50numbers a remainder 4 divided 5:49numbers a remainder 1 divided 5:16numbers a remainder 3 divided 5:38numbers a remainder 2 divided 5:72linq41: groupby - simple 2//c#public void linq41() { string[] words = { \"blueberry\", \"chimpanzee\", \"abacus\", \"banana\", \"apple\", \"cheese\" }; var wordgroups = w words group w w[0] g select { firstletter = g.key, words = g }; foreach (var g wordgroups) { console.writeline(\"words start the letter '{0}':\", g.firstletter); foreach (var w g.words) { console.writeline(w); } } }//kotlinfun linq41() { val words = arrayof(\"blueberry\", \"chimpanzee\", \"abacus\", \"banana\", \"apple\", \"cheese\") val wordgroups = words.groupby { [0] } .map { pair(.key, ) } wordgroups.foreach { val (firstletter, g) = log.d(\"words start the letter '$firstletter':\") g.value.foreach { log.d() } }}outputwords start the letter 'b':blueberrybananawords start the letter 'c':chimpanzeecheesewords start the letter '':abacusapplelinq42: groupby - simple 3//c#public void linq42() { list<product> products = getproductlist(); var ordergroups = p products group p p.category g select { category = g.key, products = g }; objectdumper.write(ordergroups, 1); } //kotlinfun linq42() { val ordergroups = products.groupby { .category } .map { pair(.key, ) } ordergroups.foreach { val (category,g) = log.d(\"${category}:\") g.value.foreach { log.d() } }}outputbeverages:(product id=1, name=chai, cat=beverages, price=18.0, instock=39)(product id=2, name=chang, cat=beverages, price=19.0, instock=17)(product id=24, name=guaraná fantástica, cat=beverages, price=4.5, instock=20)(product id=34, name=sasquatch ale, cat=beverages, price=14.0, instock=111)(product id=35, name=steeleye stout, cat=beverages, price=18.0, instock=20)(product id=38, name=côte de blaye, cat=beverages, price=263.5, instock=17)(product id=39, name=chartreuse verte, cat=beverages, price=18.0, instock=69)(product id=43, name=ipoh coffee, cat=beverages, price=46.0, instock=17)(product id=67, name=laughing lumberjack lager, cat=beverages, price=14.0, instock=52)(product id=70, name=outback lager, cat=beverages, price=15.0, instock=15)(product id=75, name=rhönbräu klosterbier, cat=beverages, price=7.75, instock=125)(product id=76, name=lakkalikööri, cat=beverages, price=18.0, instock=57)condiments:(product id=3, name=aniseed syrup, cat=condiments, price=10.0, instock=13)(product id=4, name=chef anton's cajun seasoning, cat=condiments, price=22.0, instock=53)linq43: groupby - nested//c#public void linq43() { list<customer> customers = getcustomerlist(); var customerordergroups = c customers select { c.companyname, yeargroups = o c.orders group o o.orderdate. into yg select { year = yg.key, monthgroups = o yg group o o.orderdate.month mg select { month = mg.key, orders = mg } } }; objectdumper.write(customerordergroups, 3); } //kotlinfun linq43() { val customerordergroups = customers.map { c -> pair(c.companyname, c.orders.groupby { .orderdate. + 1900 } .map { pair(.key, .value.groupby { .orderdate.month + 1 }) }) } customerordergroups.foreach { val (companyname, yeargroups) = log.d(\"# $companyname\") yeargroups.foreach { val (,monthgroups) = log.d(\"${.tostring()}: \") monthgroups.foreach { log.d(\" $\") } } }}output# alfreds futterkiste1997: 8=[(order id=10643, total=814.5)] 10=[(order id=10692, total=878.0), (order id=10702, total=330.0)]1998: 1=[(order id=10835, total=845.8)] 3=[(order id=10952, total=471.2)] 4=[(order id=11011, total=933.5)]linq44: groupby - comparer//c#public void linq44() { string[] anagrams = { \" \", \" salt\", \" earn \", \" last \", \" near \", \" form \" }; var ordergroups = anagrams.groupby(w => w.trim(), anagramequalitycomparer()); objectdumper.write(ordergroups, 1); } //kotlinfun linq44() { val anagrams = listof(\" \", \" salt\", \" earn \", \" last \", \" near \", \" form \") val ordergroups = groupby(anagrams, { w -> w.trim { <= ' ' } }, { a, b -> val achars = .tochararray() val bchars = b.tochararray() arrays.sort(achars) arrays.sort(bchars) arrays.equals(achars, bchars) }) ordergroups.foreach { g -> val sb = stringbuilder() g.foreach { w -> (sb.length > 0) sb.append(\", \") sb.append(\"'\").append(w).append(\"'\") } log.d(\"[ $sb ]\") }}output[ ' earn ', ' near ' ][ ' salt', ' last ' ][ ' ', ' form ' ]linq45: groupby - comparer, mapped//c#public void linq45() { string[] anagrams = { \" \", \" salt\", \" earn \", \" last \", \" near \", \" form \" }; var ordergroups = anagrams.groupby( w => w.trim(), => a.toupper(), anagramequalitycomparer() ); objectdumper.write(ordergroups, 1); } //kotlinfun linq45() { val anagrams = listof(\" \", \" salt\", \" earn \", \" last \", \" near \", \" form \") val ordergroups = groupby(anagrams, { w -> w.trim { <= ' ' } }, { a, b -> val achars = .tochararray() val bchars = b.tochararray() arrays.sort(achars) arrays.sort(bchars) arrays.equals(achars, bchars) }, { .touppercase() }) ordergroups.foreach { g -> val sb = stringbuilder() g.foreach { (sb.length > 0) sb.append(\", \") sb.append(\"'\").append().append(\"'\") } log.d(\"[ $sb ]\") }}output[ ' earn ', ' near ' ][ ' salt', ' last ' ][ ' ', ' form ' ]linq - set operatorslinq46: distinct - 1//c#public void linq46() { int[] factorsof300 = { 2, 2, 3, 5, 5 }; var uniquefactors = factorsof300.distinct(); console.writeline(\"prime factors 300:\"); foreach (var f uniquefactors) { console.writeline(f); } }//kotlinfun linq46() { val factorsof300 = intarrayof(2, 2, 3, 5, 5) val uniquefactors = factorsof300.distinct() log.d(\"prime factors 300:\") uniquefactors.foreach { log.d() }}outputprime factors 300:235linq47: distinct - 2//c#public void linq47() { list<product> products = getproductlist(); var categorynames = ( p products select p.category) .distinct(); console.writeline(\"category names:\"); foreach (var n categorynames) { console.writeline(n); } }//kotlinfun linq47() { val categorynames = products.map { .category}.distinct() log.d(\"category names:\") categorynames.foreach { log.d() }}outputcategory names:beveragescondimentsproducemeat/poultryseafooddairy productsconfectionsgrains/cerealslinq48: union - 1//c#public void linq48() { int[] numbersa = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersb = { 1, 3, 5, 7, 8 }; var uniquenumbers = numbersa.union(numbersb); console.writeline(\"unique numbers both arrays:\"); foreach (var n uniquenumbers) { console.writeline(n); } }//kotlinfun linq48() { val numbersa = listof(0, 2, 4, 5, 6, 8, 9) val numbersb = listof(1, 3, 5, 7, 8) val uniquenumbers = numbersa.union(numbersb) log.d(\"unique numbers both arrays:\") uniquenumbers.foreach { log.d() }}outputunique numbers both arrays:0245689137linq49: union - 2//c#public void linq49() { list<product> products = getproductlist(); list<customer> customers = getcustomerlist(); var productfirstchars = p products select p.productname[0]; var customerfirstchars = c customers select c.companyname[0]; var uniquefirstchars = productfirstchars.union(customerfirstchars); console.writeline(\"unique letters product names customer names:\"); foreach (var ch uniquefirstchars) { console.writeline(ch); } }//kotlinfun linq49() { val productfirstchars = products.map { .productname[0] } val customerfirstchars = customers.map { .companyname[0] } val uniquefirstchars = productfirstchars.union(customerfirstchars) log.d(\"unique letters product names customer names:\") uniquefirstchars.foreach { log.d() }}outputunique letters product names customer names:cgunmqktpsrbjzvfewlodhlinq50: intersect - 1//c#public void linq50() { int[] numbersa = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersb = { 1, 3, 5, 7, 8 }; var commonnumbers = numbersa.intersect(numbersb); console.writeline(\"common numbers shared both arrays:\"); foreach (var n commonnumbers) { console.writeline(n); } }//kotlinfun linq50() { val numbersa = listof(0, 2, 4, 5, 6, 8, 9) val numbersb = listof(1, 3, 5, 7, 8) val commonnumbers = numbersa.intersect(numbersb) log.d(\"common numbers shared both arrays:\") commonnumbers.foreach { log.d() }}outputcommon numbers shared both arrays:58linq51: intersect - 2//c#public void linq51() { list<product> products = getproductlist(); list<customer> customers = getcustomerlist(); var productfirstchars = p products select p.productname[0]; var customerfirstchars = c customers select c.companyname[0]; var commonfirstchars = productfirstchars.intersect(customerfirstchars); console.writeline(\"common letters product names customer names:\"); foreach (var ch commonfirstchars) { console.writeline(ch); } }//kotlinfun linq51() { val productfirstchars = products.map { .productname[0] } val customerfirstchars = customers.map { .companyname[0] } val commonfirstchars = productfirstchars.intersect(customerfirstchars) log.d(\"common letters product names customer names:\") commonfirstchars.foreach { log.d() }}outputcommon letters product names customer names:cgnmqktpsrbvfewlolinq52: except - 1//c#public void linq52() { int[] numbersa = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersb = { 1, 3, 5, 7, 8 }; ienumerable<int> aonlynumbers = numbersa.except(numbersb); console.writeline(\"numbers first array not second array:\"); foreach (var n aonlynumbers) { console.writeline(n); } }//kotlinfun linq52() { val numbersa = listof(0, 2, 4, 5, 6, 8, 9) val numbersb = listof(1, 3, 5, 7, 8) val aonlynumbers = numbersa.difference(numbersb) log.d(\"numbers first array not second array:\") aonlynumbers.foreach { log.d() }}outputnumbers first array not second array:02469linq53: except - 2//c#public void linq53() { list<product> products = getproductlist(); list<customer> customers = getcustomerlist(); var productfirstchars = p products select p.productname[0]; var customerfirstchars = c customers select c.companyname[0]; var productonlyfirstchars = productfirstchars.except(customerfirstchars); console.writeline(\" letters product names, not customer names:\"); foreach (var ch productonlyfirstchars) { console.writeline(ch); } }//kotlinfun linq53() { val productfirstchars = products.map { .productname[0] } val customerfirstchars = customers.map { .companyname[0] } val productonlyfirstchars = productfirstchars.difference(customerfirstchars) log.d(\" letters product names, not customer names:\") productonlyfirstchars.foreach { log.d() }}output letters product names, not customer names:ujzlinq - conversion operatorslinq54: toarray//c#public void linq54() { double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 }; var sorteddoubles = d doubles orderby d descending select d; var doublesarray = sorteddoubles.toarray(); console.writeline(\"every double highest lowest:\"); (int d = 0; d < doublesarray.length; d += 2) { console.writeline(doublesarray[d]); } }//kotlinfun linq54() { val doubles = doublearrayof(1.7, 2.3, 1.9, 4.1, 2.9) val sorteddoubles = doubles.sorteddescending() val doublesarray = sorteddoubles.todoublearray() log.d(\"every double highest lowest:\") var d = 0 while (d < doublesarray.size) { log.d(doublesarray[d]) d += 2 }}outputevery double highest lowest:4.12.31.7linq55: tolist//c#public void linq55() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; var sortedwords = w words orderby w select w; var wordlist = sortedwords.tolist(); console.writeline(\" sorted word list:\"); foreach (var w wordlist) { console.writeline(w); } }//kotlinfun linq55() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val sortedwords = words.sorted() val wordlist = sortedwords.tolist() log.d(\" sorted word list:\") wordlist.foreach { log.d() }}output sorted word list:appleblueberrycherrylinq56: todictionary//c#public void linq56() { var scorerecords = [] { new {name = \"alice\", score = 50}, {name = \"bob\" , score = 40}, {name = \"cathy\", score = 45} }; var scorerecordsdict = scorerecords.todictionary(sr => sr.name); console.writeline(\"bob's score: {0}\", scorerecordsdict[\"bob\"]); }//kotlinfun linq56() { val scorerecords = listof( pair(\"alice\", 50), pair(\"bob\", 40), pair(\"cathy\", 45) ) val scorerecordsdict = scorerecords.tomap() log.d(\"bob's score: ${scorerecordsdict[\"bob\"]}\")}outputbob's score: 40linq57: oftype//c#public void linq57() { object[] numbers = { null, 1.0, \"\", 3, \"four\", 5, \"six\", 7.0 }; var doubles = numbers.oftype<double>(); console.writeline(\"numbers stored doubles:\"); foreach (var d doubles) { console.writeline(d); } }//kotlinfun linq57() { val numbers = arrayof(null, 1.0, \"\", 3, \"four\", 5, \"six\", 7.0) val doubles = numbers.filter { is double } log.d(\"numbers stored doubles:\") doubles.foreach { log.d() }}outputnumbers stored doubles:1.07.0linq - element operatorslinq58: - simple//c#public void linq58() { list<product> products = getproductlist(); product product12 = ( p products where p.productid == 12 select p) .(); objectdumper.write(product12); }//kotlinfun linq58() { val product12 = products.filter { .productid == 12 }.() log.d(product12)}output(product id=12, name=queso manchego la pastora, cat=dairy products, price=38.0, instock=86)linq59: - condition//c#public void linq59() { string[] strings = { \"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" }; string startswitho = strings.(s => s[0] == 'o'); console.writeline(\" string starting 'o': {0}\", startswitho); }//kotlinfun linq59() { val strings = arrayof(\"zero\", \"\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\") val startswitho = strings. { it[0] == 'o' } log.d(\" string starting 'o': $startswitho\")}output string starting 'o': linq61: firstordefault - simple//c#public void linq61() { int[] numbers = { }; int firstnumordefault = numbers.firstordefault(); console.writeline(firstnumordefault); }//kotlinfun linq61() { val numbers = intarrayof() val firstnumordefault = numbers.firstornull() ?: 0 log.d(firstnumordefault)}output0linq62: firstordefault - condition//c#public void linq62() { list<product> products = getproductlist(); product product789 = products.firstordefault(p => p.productid == 789); console.writeline(\"product 789 exists: {0}\", product789 != null); }//kotlinfun linq62() { val product789 = products.firstornull { .productid == 789 } log.d(\"product 789 exists: ${product789 != null}\")}outputproduct 789 exists: falselinq64: elementat//c#public void linq64() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int fourthlownum = ( n numbers where n > 5 select n) .elementat(1); // second number is index 1 sequences 0-based indexing console.writeline(\"second number > 5: {0}\", fourthlownum); }//kotlinfun linq64() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val fourthlownum = numbers.filter { > 5 }[1] log.d(\"second number > 5: $fourthlownum\")}outputsecond number > 5: 8linq - generation operatorslinq65: range//c#public void linq65() { var numbers = n enumerable.range(100, 50) select { number = n, oddeven = n % 2 == 1 ? \"odd\" : \"\" }; foreach (var n numbers) { console.writeline(\" number {0} is {1}.\", n.number, n.oddeven); } }//kotlinfun linq65() { val numbers = (100..150).map { n -> pair(n, (n % 2 == 1) \"odd\" else \"\") } numbers.foreach { log.d(\" number ${.first} is ${.second}\") }}output number 100 is the number 101 is odd number 102 is the number 103 is odd number 104 is the number 105 is odd number 106 is the number 107 is odd number 108 is the number 109 is odd number 110 is ...linq66: repeat//c#public void linq66() { var numbers = enumerable.repeat(7, 10); foreach (var n numbers) { console.writeline(n); } }//kotlinfun linq66() { val numbers = \"7\".repeat(10) numbers.foreach { log.d() }}output7777777777linq - quantifierslinq67: - simple//c#public void linq67() { string[] words = { \"believe\", \"relief\", \"receipt\", \"field\" }; bool iaftere = words.(w => w.contains(\"ei\")); console.writeline(\" is word contains the list contains 'ei': {0}\", iaftere); }//kotlinfun linq67() { val words = arrayof(\"believe\", \"relief\", \"receipt\", \"field\") val iaftere = words. { it.contains(\"ei\") } log.d(\" is word contains the list contains 'ei': $iaftere\")}output is word contains the list contains 'ei': truelinq69: - grouped//c#public void linq69() { list<product> products = getproductlist(); var productgroups = p products group p p.category g where g.(p => p.unitsinstock == 0) select { category = g.key, products = g }; objectdumper.write(productgroups, 1); }//kotlinfun linq69() { val productgroups = products .groupby { .category } .filter { .value. { it.unitsinstock == 0 } } .map { pair(.key, ) } productgroups.foreach { log.d(.second) }}outputcondiments=[(product id=3, name=aniseed syrup, cat=condiments, price=10.0, instock=13), (product id=4, name=chef anton's cajun seasoning, cat=condiments, price=22.0, instock=53), (product id=5, name=chef anton's gumbo mix, cat=condiments, price=21.35, instock=0), (product id=6, name=grandma's boysenberry spread, cat=condiments, price=25.0, instock=120), (product id=8, name=northwoods cranberry sauce, cat=condiments, price=40.0, instock=6), (product id=15, name=genen shouyu, cat=condiments, price=15.5, instock=39), (product id=44, name=gula malacca, cat=condiments, price=19.45, instock=27), (product id=61, name=sirop d'érable, cat=condiments, price=28.5, instock=113), (product id=63, name=vegie-spread, cat=condiments, price=43.9, instock=24), (product id=65, name=louisiana fiery hot pepper sauce, cat=condiments, price=21.05, instock=76), (product id=66, name=louisiana hot spiced okra, cat=condiments, price=17.0, instock=4), (product id=77, name=original frankfurter grüne ße, cat=condiments, price=13.0, instock=32)]meat/poultry=[(product id=9, name=mishi kobe niku, cat=meat/poultry, price=97.0, instock=29), (product id=17, name=alice mutton, cat=meat/poultry, price=39.0, instock=0), (product id=29, name=thüringer rostbratwurst, cat=meat/poultry, price=123.79, instock=0), (product id=53, name=perth pasties, cat=meat/poultry, price=32.8, instock=0), (product id=54, name=tourtière, cat=meat/poultry, price=7.45, instock=21), (product id=55, name=pâté chinois, cat=meat/poultry, price=24.0, instock=115)]dairy products=[(product id=11, name=queso cabrales, cat=dairy products, price=21.0, instock=22), (product id=12, name=queso manchego la pastora, cat=dairy products, price=38.0, instock=86), (product id=31, name=gorgonzola telino, cat=dairy products, price=12.5, instock=0), (product id=32, name=mascarpone fabioli, cat=dairy products, price=32.0, instock=9), (product id=33, name=geitost, cat=dairy products, price=2.5, instock=112), (product id=59, name=raclette courdavault, cat=dairy products, price=55.0, instock=79), (product id=60, name=camembert pierrot, cat=dairy products, price=34.0, instock=19), (product id=69, name=gudbrandsdalsost, cat=dairy products, price=36.0, instock=26), (product id=71, name=flotemysost, cat=dairy products, price=21.5, instock=26), (product id=72, name=mozzarella di giovanni, cat=dairy products, price=34.8, instock=14)]...linq70: - simple//c#public void linq70() { int[] numbers = { 1, 11, 3, 19, 41, 65, 19 }; bool onlyodd = numbers.(n => n % 2 == 1); console.writeline(\" list contains odd numbers: {0}\", onlyodd); }//kotlinfun linq70() { val numbers = intarrayof(1, 11, 3, 19, 41, 65, 19) val onlyodd = numbers. { it % 2 == 1 } log.d(\" list contains odd numbers: $onlyodd\")}output list contains odd numbers: truelinq72: - grouped//c#public void linq72() { list<product> products = getproductlist(); var productgroups = p products group p p.category g where g.(p => p.unitsinstock > 0) select { category = g.key, products = g }; objectdumper.write(productgroups, 1); }//kotlinfun linq72() { val productgroups = products .groupby { .category } .filter { .value. { it.unitsinstock > 0 } } .map { pair(.key, ) } productgroups.foreach { log.d(.second) }}outputbeverages=[(product id=1, name=chai, cat=beverages, price=18.0, instock=39), (product id=2, name=chang, cat=beverages, price=19.0, instock=17), (product id=24, name=guaraná fantástica, cat=beverages, price=4.5, instock=20), (product id=34, name=sasquatch ale, cat=beverages, price=14.0, instock=111), (product id=35, name=steeleye stout, cat=beverages, price=18.0, instock=20), (product id=38, name=côte de blaye, cat=beverages, price=263.5, instock=17), (product id=39, name=chartreuse verte, cat=beverages, price=18.0, instock=69), (product id=43, name=ipoh coffee, cat=beverages, price=46.0, instock=17), (product id=67, name=laughing lumberjack lager, cat=beverages, price=14.0, instock=52), (product id=70, name=outback lager, cat=beverages, price=15.0, instock=15), (product id=75, name=rhönbräu klosterbier, cat=beverages, price=7.75, instock=125), (product id=76, name=lakkalikööri, cat=beverages, price=18.0, instock=57)]...linq - aggregate operatorslinq73: count - simple//c#public void linq73() { int[] factorsof300 = { 2, 2, 3, 5, 5 }; int uniquefactors = factorsof300.distinct().count(); console.writeline(\" are {0} unique factors 300.\", uniquefactors); }//kotlinfun linq73() { val factorsof300 = intarrayof(2, 2, 3, 5, 5) val uniquefactors = factorsof300.distinct().size log.d(\" are $uniquefactors unique factors 300.\")}output are 3 unique factors 300.linq74: count - conditional//c#public void linq74() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int oddnumbers = numbers.count(n => n % 2 == 1); console.writeline(\" are {0} odd numbers the list.\", oddnumbers); }//kotlinfun linq74() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val oddnumbers = numbers.count { % 2 == 1 } log.d(\" are $oddnumbers odd numbers the list.\")}output are 5 odd numbers the list.linq76: count - nested//c#public void linq76() { list<customer> customers = getcustomerlist(); var ordercounts = c customers select { c.customerid, ordercount = c.orders.count() }; objectdumper.write(ordercounts); }//kotlinfun linq76() { val ordercounts = customers.map { pair(.customerid, .orders.size) } ordercounts.foreach { log.d() }}output(alfki, 6)(anatr, 4)(anton, 7)(arout, 13)(bergs, 18)(blaus, 7)(blonp, 11)...linq77: count - grouped//c#public void linq77() { list<product> products = getproductlist(); var categorycounts = p products group p p.category g select { category = g.key, productcount = g.count() }; objectdumper.write(categorycounts }//kotlinfun linq77() { val categorycounts = products.groupby { .category } .map { pair(.key, .value.size) } categorycounts.foreach { log.d() }}output(beverages, 12)(condiments, 12)(produce, 5)(meat/poultry, 6)(seafood, 12)(dairy products, 10)(confections, 13)(grains/cereals, 7)linq78: sum - simple//c#public void linq78() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; double numsum = numbers.sum(); console.writeline(\" sum the numbers is {0}.\", numsum); }//kotlinfun linq78() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val numsum = numbers.sum().todouble() log.d(\" sum the numbers is $numsum\")}output sum the numbers is 45.0linq79: sum - projection//c#public void linq79() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; double totalchars = words.sum(w => w.length); console.writeline(\" are total {0} characters these words.\", totalchars); }//kotlinfun linq79() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val totalchars = words.sumby { .length } log.d(\" are total $totalchars characters these words.\")}output are total 20 characters these words.linq80: sum - grouped//c#public void linq80() { list<product> products = getproductlist(); var categories = p products group p p.category g select { category = g.key, totalunitsinstock = g.sum(p => p.unitsinstock) }; objectdumper.write(categories); }//kotlinfun linq80() { val categories = products.groupby { .category } .map { pair(.key, .value.sumby { .unitsinstock }) } categories.foreach { log.d() }}output(beverages, 559)(condiments, 507)(produce, 100)(meat/poultry, 165)(seafood, 701)(dairy products, 393)(confections, 386)(grains/cereals, 308)linq81: min - simple//c#public void linq81() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int minnum = numbers.min(); console.writeline(\" minimum number is {0}.\", minnum); }//kotlinfun linq81() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val minnum = numbers.min() log.d(\" minimum number is $minnum\")}output minimum number is 0linq82: min - projection//c#public void linq82() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; int shortestword = words.min(w => w.length); console.writeline(\" shortest word is {0} characters long.\", shortestword); }//kotlinfun linq82() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val shortestword = words.minby { .length }?.length log.d(\" shortest word is $shortestword characters long.\")}output shortest word is 5 characters long.linq83: min - grouped//c#public void linq83() { list<product> products = getproductlist(); var categories = p products group p p.category g select { category = g.key, cheapestprice = g.min(p => p.unitprice) }; objectdumper.write(categories); }//kotlinfun linq83() { val categories = products.groupby { .category } .map { pair(.key, .value.minby { .unitprice }?.unitprice) } categories.foreach { log.d() }}output(beverages, 4.5)(condiments, 10.0)(produce, 10.0)(meat/poultry, 7.45)(seafood, 6.0)(dairy products, 2.5)(confections, 9.2)(grains/cereals, 7.0)linq84: min - elements//c#public void linq84() { list<product> products = getproductlist(); var categories = p products group p p.category g let minprice = g.min(p => p.unitprice) select { category = g.key, cheapestproducts = g.where(p => p.unitprice == minprice) }; objectdumper.write(categories, 1); }//kotlinfun linq84() { val categories = products.groupby { .category } .map { val minprice = .value.minby { .unitprice }!!.unitprice pair(.key, .value.filter { p -> p.unitprice == minprice }) } categories.foreach { val (category,cheapestproducts) = log.d(category + \": \") cheapestproducts.foreach { log.d() } }}outputbeverages: (product id=24, name=guaraná fantástica, cat=beverages, price=4.5, instock=20)condiments: (product id=3, name=aniseed syrup, cat=condiments, price=10.0, instock=13)produce: (product id=74, name=longlife tofu, cat=produce, price=10.0, instock=4)meat/poultry: (product id=54, name=tourtière, cat=meat/poultry, price=7.45, instock=21)seafood: (product id=13, name=konbu, cat=seafood, price=6.0, instock=24)dairy products: (product id=33, name=geitost, cat=dairy products, price=2.5, instock=112)confections: (product id=19, name=teatime chocolate biscuits, cat=confections, price=9.2, instock=25)grains/cereals: (product id=52, name=filo mix, cat=grains/cereals, price=7.0, instock=38)linq85: max - simple//c#public void linq85() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int maxnum = numbers.max(); console.writeline(\" maximum number is {0}.\", maxnum); }//kotlinfun linq85() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val maxnum = numbers.max() log.d(\" maximum number is $maxnum\")}output maximum number is 9linq86: max - projection//c#public void linq86() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; int longestlength = words.max(w => w.length); console.writeline(\" longest word is {0} characters long.\", longestlength); }//kotlinfun linq86() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val longestlength = words.maxby { .length }?.length log.d(\" longest word is $longestlength characters long.\")}output longest word is 9 characters long.linq87: max - grouped//c#public void linq87() { list<product> products = getproductlist(); var categories = p products group p p.category g select { category = g.key, mostexpensiveprice = g.max(p => p.unitprice) }; objectdumper.write(categories); }//kotlinfun linq87() { val categories = products.groupby { .category } .map { pair(.key, .value.maxby { .unitprice }?.unitprice) } categories.foreach { log.d() }}output(beverages, 263.5)(condiments, 43.9)(produce, 53.0)(meat/poultry, 123.79)(seafood, 62.5)(dairy products, 55.0)(confections, 81.0)(grains/cereals, 38.0)linq88: max - elements//c#public void linq88() { list<product> products = getproductlist(); var categories = p products group p p.category g let maxprice = g.max(p => p.unitprice) select { category = g.key, mostexpensiveproducts = g.where(p => p.unitprice == maxprice) }; objectdumper.write(categories, 1); }//kotlinfun linq88() { val categories = products.groupby { .category } .map { val maxprice = .value.maxby { p -> p.unitprice }?.unitprice pair(.key, .value.filter { p -> p.unitprice == maxprice }) } categories.foreach { val (category, mostexpensiveproducts) = log.d(\"$category: \") mostexpensiveproducts.foreach { log.d() } }}outputbeverages: (product id=38, name=côte de blaye, cat=beverages, price=263.5, instock=17)condiments: (product id=63, name=vegie-spread, cat=condiments, price=43.9, instock=24)produce: (product id=51, name=manjimup dried apples, cat=produce, price=53.0, instock=20)meat/poultry: (product id=29, name=thüringer rostbratwurst, cat=meat/poultry, price=123.79, instock=0)seafood: (product id=18, name=carnarvon tigers, cat=seafood, price=62.5, instock=42)dairy products: (product id=59, name=raclette courdavault, cat=dairy products, price=55.0, instock=79)confections: (product id=20, name=sir rodney's marmalade, cat=confections, price=81.0, instock=40)grains/cereals: (product id=56, name=gnocchi di nonna alice, cat=grains/cereals, price=38.0, instock=21)linq89: average - simple//c#public void linq89() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; double averagenum = numbers.average(); console.writeline(\" average number is {0}.\", averagenum); }//kotlinfun linq89() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val averagenum = numbers.average() log.d(\" average number is $averagenum\")}output average number is 4.5linq90: average - projection//c#public void linq90() { string[] words = { \"cherry\", \"apple\", \"blueberry\" }; double averagelength = words.average(w => w.length); console.writeline(\" average word length is {0} characters.\", averagelength); }//kotlinfun linq90() { val words = arrayof(\"cherry\", \"apple\", \"blueberry\") val averagelength = words.map { .length }.average() log.d(\" average word length is $averagelength characters.\")}output average word length is 6.666666666666667 characters.linq91: average - grouped//c#public void linq91() { list<product> products = getproductlist(); var categories = p products group p p.category g select { category = g.key, averageprice = g.average(p => p.unitprice) }; objectdumper.write(categories); }//kotlinfun linq91() { val categories = products.groupby { .category } .map { pair(.key, .value.map{.unitprice }.average() ) } categories.foreach { log.d(\"category: ${.first}, averageprice: ${.second}\") }}outputcategory: beverages, averageprice: 37.979166666666664category: condiments, averageprice: 23.0625category: produce, averageprice: 32.37category: meat/poultry, averageprice: 54.00666666666667category: seafood, averageprice: 20.6825category: dairy products, averageprice: 28.73category: confections, averageprice: 25.16category: grains/cereals, averageprice: 20.25linq92: aggregate - simple//c#public void linq92() { double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double product = doubles.aggregate((runningproduct, nextfactor) => runningproduct * nextfactor); console.writeline(\"total product all numbers: {0}\", product); }//kotlinfun linq92() { val doubles = doublearrayof(1.7, 2.3, 1.9, 4.1, 2.9) val product = doubles.reduce { runningproduct, nextfactor -> runningproduct * nextfactor } log.d(\"total product all numbers: $product\")}outputtotal product all numbers: 88.33080999999999linq93: aggregate - seed//c#public void linq93() { double startbalance = 100.0; int[] attemptedwithdrawals = { 20, 10, 40, 50, 10, 70, 30 }; double endbalance = attemptedwithdrawals.aggregate(startbalance, (balance, nextwithdrawal) => ((nextwithdrawal <= balance) ? (balance - nextwithdrawal) : balance)); console.writeline(\"ending balance: {0}\", endbalance); }//kotlinfun linq93() { val startbalance = 100 val attemptedwithdrawals = intarrayof(20, 10, 40, 50, 10, 70, 30) var = 0 val endbalance = attemptedwithdrawals.reduce { acc, nextwithdrawal -> val balance = (i++ == 0 && nextwithdrawal <= acc) startbalance - acc else acc (nextwithdrawal <= balance) balance - nextwithdrawal else balance } log.d(\"ending balance: $endbalance\")}outputending balance: 20linq - miscellaneous operatorslinq94: concat - 1//c#public void linq94() { int[] numbersa = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersb = { 1, 3, 5, 7, 8 }; var allnumbers = numbersa.concat(numbersb); console.writeline(\" numbers both arrays:\"); foreach (var n allnumbers) { console.writeline(n); } }//kotlinfun linq94() { val numbersa = intarrayof(0, 2, 4, 5, 6, 8, 9) val numbersb = intarrayof(1, 3, 5, 7, 8) val allnumbers = numbersa + numbersb log.d(\" numbers both arrays:\") allnumbers.foreach { log.d() }}output numbers both arrays:024568913578linq95: concat - 2//c#public void linq95() { list<customer> customers = getcustomerlist(); list<product> products = getproductlist(); var customernames = c customers select c.companyname; var productnames = p products select p.productname; var allnames = customernames.concat(productnames); console.writeline(\"customer product names:\"); foreach (var n allnames) { console.writeline(n); } }//kotlinfun linq95() { val customernames = customers.map { .companyname } val productnames = products.map { .productname } val allnames = customernames + productnames log.d(\"customer product names:\") allnames.foreach { log.d() }}outputcustomer product names:alfreds futterkisteana trujillo emparedados y heladosantonio moreno taqueríaround hornberglunds snabbköpblauer delikatessen...linq96: equalall - 1//c#public void linq96() { var wordsa = string[] { \"cherry\", \"apple\", \"blueberry\" }; var wordsb = string[] { \"cherry\", \"apple\", \"blueberry\" }; bool match = wordsa.sequenceequal(wordsb); console.writeline(\" sequences match: {0}\", match); }//kotlinfun linq96() { val wordsa = arrayof(\"cherry\", \"apple\", \"blueberry\") val wordsb = arrayof(\"cherry\", \"apple\", \"blueberry\") val match = arrays.equals(wordsa, wordsb) log.d(\" sequences match: $match\")}output sequences match: truelinq97: equalall - 2//c#public void linq97() { var wordsa = string[] { \"cherry\", \"apple\", \"blueberry\" }; var wordsb = string[] { \"apple\", \"blueberry\", \"cherry\" }; bool match = wordsa.sequenceequal(wordsb); console.writeline(\" sequences match: {0}\", match); }//kotlinfun linq97() { val wordsa = arrayof(\"cherry\", \"apple\", \"blueberry\") val wordsb = arrayof(\"cherry\", \"blueberry\", \"cherry\") val match = arrays.equals(wordsa, wordsb) log.d(\" sequences match: $match\")}output sequences match: falselinq - query executionlinq99: deferred execution//c#public void linq99() { // sequence operators form -class queries // are executed until enumerate them. int[] numbers = int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int = 0; var q = n numbers select ++; // note, local variable '' is incremented // until each element is evaluated ( a side-effect): foreach (var v q) { console.writeline(\"v = {0}, = {1}\", v, ); } }//kotlinfun linq099() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) var = 0 val q = numbers.map { { ++ } } for (f q) { val v = f() log.d(\"v = $v, = $i\") }}outputv = 1, = 1v = 2, = 2v = 3, = 3v = 4, = 4v = 5, = 5v = 6, = 6v = 7, = 7v = 8, = 8v = 9, = 9v = 10, = 10linq100: immediate execution//c#public void linq100() { // methods tolist() cause query be // executed immediately, caching results. int[] numbers = int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int = 0; var q = ( n numbers select ++) .tolist(); // local variable has already been fully // incremented before iterate results: foreach (var v q) { console.writeline(\"v = {0}, = {1}\", v, ); } } //kotlinfun linq100() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) var = 0 val q = numbers.map { ++ } q.foreach { v -> log.d(\"v = $v, = $i\") }}outputv = 1, = 10v = 2, = 10v = 3, = 10v = 4, = 10v = 5, = 10v = 6, = 10v = 7, = 10v = 8, = 10v = 9, = 10v = 10, = 10linq101: query reuse//c#public void linq101() { // deferred execution lets define query once // then reuse later data changes. int[] numbers = int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; var lownumbers = n numbers where n <= 3 select n; console.writeline(\" run numbers <= 3:\"); foreach (int n lownumbers) { console.writeline(n); } (int = 0; < 10; ++) { numbers[] = -numbers[]; } // during second run, same query object, // lownumbers, be iterating the state // numbers[], producing different results: console.writeline(\"second run numbers <= 3:\"); foreach (int n lownumbers) { console.writeline(n); } } //kotlinfun linq101() { val numbers = intarrayof(5, 4, 1, 3, 9, 8, 6, 7, 2, 0) val lownumbers = { numbers.filter { n -> n <= 3 } } log.d(\" run numbers <= 3:\") lownumbers().foreach { log.d() } for ( in 0..9) { numbers[] = -numbers[] } log.d(\"second run numbers <= 3:\") lownumbers().foreach { log.d() }}output run numbers <= 3:1320second run numbers <= 3:-5-4-1-3-9-8-6-7-20linq - join operatorslinq102: cross join//c#public void linq102() { string[] categories = string[]{ \"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\" }; list<product> products = getproductlist(); var q = c categories join p products c equals p.category select { category = c, p.productname }; foreach (var v q) { console.writeline(v.productname + \": \" + v.category); } }//kotlinfun linq102() { val categories = listof(\"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\") val q = join(categories, products) { c, p -> c == p.category } .map { pair(.a, .b.productname) } q.foreach { log.d(\"${.first}: ${.second}\") }}outputbeverages: chaibeverages: changbeverages: guaraná fantásticabeverages: sasquatch alebeverages: steeleye stoutbeverages: côte de blayebeverages: chartreuse vertebeverages: ipoh coffee...linq103: group join//c#public void linq103() { string[] categories = string[]{ \"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\" }; list<product> products = getproductlist(); var q = c categories join p products c equals p.category ps select { category = c, products = ps }; foreach (var v q) { console.writeline(v.category + \":\"); foreach (var p v.products) { console.writeline(\" \" + p.productname); } } }//kotlinfun linq103() { val categories = listof(\"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\") val q = joingroup(categories, products) { c, p -> c == p.category } .map { pair(.key, .items.map { .b }) } q.foreach { log.d(\"${.first}:\") .second.foreach { p -> log.d(\" ${p.productname}\") } }}outputbeverages: chai chang guaraná fantástica sasquatch ale steeleye stout côte de blaye chartreuse verte ipoh coffee laughing lumberjack lager outback lager rhönbräu klosterbier lakkalikööriseafood: ikura konbu carnarvon tigers nord-ost matjeshering inlagd sill gravad lax boston crab meat jack's england clam chowder rogede sild spegesild escargots de bourgogne röd kaviar...linq104: cross join group join//c#public void linq104() { string[] categories = string[]{ \"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\" }; list<product> products = getproductlist(); var q = c categories join p products c equals p.category ps p ps select { category = c, p.productname }; foreach (var v q) { console.writeline(v.productname + \": \" + v.category); } }//kotlinfun linq104() { val categories = listof(\"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\") val q = joingroup(categories, products) { c, p -> c == p.category } .flatmap { j -> j.items.map { .b }.map { pair(j.key, .productname) } } q.foreach { log.d(\"${.second}: ${.first}\") }}outputchai: beverageschang: beveragesguaraná fantástica: beveragessasquatch ale: beveragessteeleye stout: beveragescôte de blaye: beverageschartreuse verte: beveragesipoh coffee: beverageslaughing lumberjack lager: beveragesoutback lager: beveragesrhönbräu klosterbier: beverageslakkalikööri: beveragesikura: seafoodkonbu: seafoodcarnarvon tigers: seafood...linq105: left outer join//c#public void linq105() { string[] categories = string[]{ \"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\" }; list<product> products = getproductlist(); var q = c categories join p products c equals p.category ps p ps.defaultifempty() select { category = c, productname = p == null ? \"( products)\" : p.productname }; foreach (var v q) { console.writeline(v.productname + \": \" + v.category); } }//kotlinfun linq105() { val categories = listof(\"beverages\", \"condiments\", \"vegetables\", \"dairy products\", \"seafood\") val q = categories.flatmap { c -> val catproducts = products.filter { c == .category } (catproducts.isempty()) listof(pair(c, \"( products)\")) else catproducts.map { pair(c, .productname) } } q.foreach { log.d(\"${.second}: ${.first}\") }}outputchai: beverageschang: beveragesguaraná fantástica: beveragessasquatch ale: beveragessteeleye stout: beveragescôte de blaye: beverageschartreuse verte: beveragesipoh coffee: beverageslaughing lumberjack lager: beveragesoutback lager: beveragesrhönbräu klosterbier: beverageslakkalikööri: beveragesaniseed syrup: condimentschef anton's cajun seasoning: condimentschef anton's gumbo mix: condimentsgrandma's boysenberry spread: condimentsnorthwoods cranberry sauce: condimentsgenen shouyu: condimentsgula malacca: condimentssirop d'érable: condimentsvegie-spread: condimentslouisiana fiery hot pepper sauce: condimentslouisiana hot spiced okra: condimentsoriginal frankfurter grüne ße: condiments( products): vegetables...contributorsmythz (demis bellot)"
}