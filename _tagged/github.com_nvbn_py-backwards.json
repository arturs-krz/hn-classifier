{
	"_id": "14211724",
	"site": "https://github.com/nvbn/py-backwards",
	"title": " Python-to-Python compiler for some 3.6 features in older versions",
	"author": "nvbn",
	"date": "2017-06-13T13:33:03.774Z",
	"tags": {
		"categories": [
			"opensource",
			"python",
			"compiler"
		],
		"languages": [
			"python"
		]
	},
	"content": "readme.md py-backwards python python compiler allows to some python 3.6 features older versions, can try in online demo.requires python 3.3+ run, compile down 2.7.supported featurestarget 3.5:formatted string literals f'hi {x}'variables annotations x: int = 10 x: intunderscores numeric literals 1_000_000 (works automatically)target 3.4:starred unpacking [*range(1, 5), *range(10, 15)] print(*[1, 2], 3, *[4, 5])dict unpacking {1: 2, **{3: 4}}target 3.3:import pathlib2 instead pathlibtarget 3.2:yield return generatortarget 2.7:functions annotations def fn(: int) -> strimports __future__super without argumentsclasses without base class : passimports six movesmetaclassstring/unicode literals (works automatically)str unicodedefine encoding ( transformer)dbm => anydbm dbm.ndbm => dbm example, you some python 3.6 code, :def returning_range(x: int): yield range(x) return xdef x_printer(x): val: int val = yield returning_range(x) print(f'val {val}')def formatter(x: int) -> dict: items: list = [*x_printer(x), x] print(*items, *items) return {'items': items}result = {'x': 10, **formatter(10)}print(result)class numbermanager: def ten(self): return 10 @classmethod def eleven(cls): return 11class importantnumbermanager(numbermanager): def ten(self): return super().ten() @classmethod def eleven(cls): return super().eleven()print(importantnumbermanager().ten())print(importantnumbermanager.eleven()) can compile for python 2.7 : py-backwards - input.py -o output.py -t 2.7got ugly code ensure it works: python3.6 input.pyval 100 1 2 3 4 5 6 7 8 9 10 0 1 2 3 4 5 6 7 8 9 10{'x': 10, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}1011 python2 output.py val 100 1 2 3 4 5 6 7 8 9 10 0 1 2 3 4 5 6 7 8 9 10{'x': 10, 'items': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}1011usageinstallation:pip install py-backwardscompile code:py-backwards - src -o compiled -t 2.7testing compiled code testing compiled code each supported python version can tox tox-py-backwards. need install :pip install tox tox-py-backwardsfill tox.ini (py_backwards = true testenv section enables py-backwards), :[tox]envlist = py27,py33,py34,py35,py36[testenv]deps = pytestcommands = py.testpy_backwards = true run tests :toxdistributing compiled code distributing packages compiled py-backwards can py-backwards-packager.install with:pip install py-backwards-packager change setup import setup.py :try: py_backwards_packager import setupexcept importerror: setuptools import setup default targets enabled, you limit with:setup(..., py_backwards_targets=['2.7', '3.3']) that code be automatically compiled bdist bdist_wheel.running systems without python 3.3+ can docker running py-backwards systems without python 3.3+, example testing travis-ci python 2.7:docker run -v $(pwd):/data/ nvbn/py-backwards - example -o -t 2.7developmentsetup:pip install .python setup.py developpip install -r requirements.txtrun tests: py.test -vvvv --capture=sys --enable-functionalrun tests systems without docker: py.test -vvvvwriting code transformers of , you need inherit basetransformer, basenodetransformer ( you to nodetransfromer interface), baseimportrewrite ( you just change import). you basetransformer, override class method def transform(cls, tree: ast.ast) -> transformationresult, :from ..types import transformationresult .base import basetransformerclass mytransformer(basetransformer): @classmethod def transform(cls, tree: ast.ast) -> transformationresult: return transformationresult(tree=tree, tree_changed=true, dependencies=[]) you basenodetransformer, override visit_* methods, simplification class a whole tree self._tree, should set self._tree_changed = true the treewas changed: .base import basenodetransformerclass mytransformer(basenodetransformer): dependencies = [] # additional dependencies def visit_functiondef(self, node: ast.functiondef) -> ast.functiondef: self._tree_changed = true # mark transformer changed tree return self.generic_visit(node) you baseimportrewrite, override rewrites, :from .base import baseimportrewriteclass mytransformer(baseimportrewrite): dependencies = ['pathlib2'] rewrites = [('pathlib', 'pathlib2')] that need add transformer transformers.__init__.transformers.'s hard write code ast, of we snippets: ..utils.snippet import snippet, let, extend@snippetdef my_snippet(class_name, class_body): class class_name: # be replaced `class_name` extend(class_body) # body the class be extended `class_body` def fn(self): let(x) # x be replaced everywhere unique name, `_py_backwards_x_1` x = 10 return x you easily content snippet :my_snippet.get_body(class_name='myclass', class_body=[ast.expr(...), ...]) please at tree utils, contains such useful functions find, get_parent etc.related projectspy-backwards-astunparsetox-py-backwardspy-backwards-packagerpytest-docker-pexpectlicense mit"
}