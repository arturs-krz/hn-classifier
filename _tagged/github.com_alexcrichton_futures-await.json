{
	"_id": "14380829",
	"site": "https://github.com/alexcrichton/futures-await",
	"title": "Amazing project, now we can use await in Rust",
	"author": "ngaut",
	"date": "2017-06-13T13:57:07.249Z",
	"tags": {
		"categories": [
			"opensource",
			"rust",
			"async"
		],
		"languages": [
			"rust",
			"shell"
		]
	},
	"content": "readme.md futures-awaitasync/await syntax rust the futures crate is ?the primary of working futures today rust is through variouscombinators the future trait. is quite \"callback hell\" cansometimes feel it the rightward drift code increases each closure tack . the purpose async/await is provide much more\"synchronous\" feeling code while retaining the power asynchronouscode!here's small taste what crate does:#[async]fn fetch_rust_lang(client: hyper::client) -> io::result<string> { let response = await!(client.(\"https://www.rust-lang.org\"))?; !response.status().is_success() { return err(io::error::(io::errorkind::, \"request failed\")) } let body = await!(response.body().concat())?; let string = string::from_utf8(body)?; ok(string)} notable points here are:functions are tagged #[async], means they are asychronous return future called instead returning result listed. await! macro allows blocking a future completion. does actually block thread though, just \"blocks\" future returned fetch_rust_lang continuing. can of await! macro afunction a future its result, consuming future along way.error handling is much more natural here #[async] functions. get use ? operator well simple return err statements. thecombinators the futures crate is generally much more cumbersome. future returned fetch_rust_lang is actually state machinegenerated compile and does implicit memory allocation. isbuilt top generators, described below. can have async methods:impl foo { #[async] fn do_work(self) -> io::result<u32> { // ... }} can specify you actually prefer trait object is returnedinstead, e.g. box<future<item = i32, error = io::error>>#[async(boxed)]fn foo() -> io::result<i32> { // ...} finally can have \"async loops\" operate thestream trait:#[async] message stream { // ...} async loop propagate errors of function message has item type the stream passed . note async loops only used inside an #[async] function. do use ?this implementation is currently fundamentally built generators/coroutines. feature has landed the rust-lang/rust master branch the rustcompiler. work this repository currently 'll need build owncompiler this branch https://github.com/zoxc/rust/tree/gen.git clone https://github.com/zoxc/rust --branch gencd rust./x.py buildonce 's done can the compiler build/$target/stage2/bin/rustc. actually this crate use skeleton this:# your cargo.toml ...[dependencies]futures-await = { git = 'https://github.com/alexcrichton/futures-await' } then...#![feature(proc_macro, conservative_impl_trait, generators)]extern crate futures_await futures; futures::prelude::*;#[async]fn foo() -> result<i32, i32> { ok(1 + await!(bar())?)}#[async]fn bar() -> result<i32, i32> { ok(2)}fn main() { assert_eq!(foo().wait(), ok(3));} crate is intended \"masquerade\" the futures crate, reexporting entire hierarchy just augmenting with necessary runtime support, async attribute, the await! macro. imports are contained futures::prelude::* you import .for whole mess examples a whole mess code, can check theasync-await branch sccache is in-progress transition using async/await syntax many locations. 'll typically find thecode is much more readable afterwards, especially changes's next? crate is very much flux the moment due everything being superunstable nothing's in master branch rust-lang/rust. hope get more \"stable\" nightly least terms breaking less often well fixing bugs arise. the moment 's definitely recommended use in production all, you'd though please feel more welcome try out! you run any questions have issues, 're more welcome open issue!caveats can expected many nightly features, are number caveats be aware when working this project. main is this is earlystages . nothing is upstream yet. things break! being said bugreports are more welcome, always to what needs be rixedregardless!compiler errorscompiler error messages aren't best. right the proc-macro system the compiler attribute compiler errors a function the literal#[async] label. example code:#[async]fn foo() -> result<i32, i32> { ok(e)} is missing definition the variable e, when run through compiler error looks :error[e0425]: cannot find value `e` this scope --> examples/foo.rs:9:1 |9 | #[async] | ^^^^^^^^ found this scopeerror: aborting due previous error isn't a local problem, compiler errors spans wouldotherwise in async function are attributed the #[async] attribute. is unfortunately how procedural macros today, lots workis happening the compiler improve ! as soon that's available crate try help advantage it.borrowingborrowing doesn't really so today. compiler either rejectmany borrows there may some unsafety lurking the generators featureis being developed. example you a function such :#[async]fn foo(s: &str) -> io::result<()> { // ..} may compile! reason this is the returned futuretypically needs adhere the 'static bound. async functions currentlyexecute code called, only progress polled. means when call async function happens is creates future,packages the arguments, then returns to . in case 'd to return &str up, doesn't always the lifetimes out. example how get above function compiling be do:#[async]fn foo(s: string) -> io::result<()> { // ...} somehow otherwise an owned value instead a borrowed reference.note arguments are the point pain borrowing. examplecode this (or least shouldn't) compile today: line string.lines() { await!(process(line)); println!(\"processed: {}\", line);} problem here is line is borrowed value is alive across yieldpoint, namely call await!. means when future may return up stack was part the await! process 'd to restore line variable it reenters future. isn't really implemented may unsafe today. a rule thumb now 'll need only owned values ( borrowed internals) alive across calls await! duringasync loops.lots thought is being put to figure how alleviate restriction!borrowing is crux many ergonomic patterns rust, we'd this work! one final point, consequence the \" borrowed arguments\" today is function signatures :#[async]fn foo(&self) -> io::result<()> { // ...}unfortunately not . you'll either need take self value defer a different #[async] function.futures traitslet's you've got trait so:trait mystuff { fn do_async_task(??self) -> box<future<...>>;}'ll gloss the self details here a bit, in essence 've got function a trait tha twants return future. unfortunately 's actuallyquite difficult use ! right there's few caveats:ideally want tag #[async] this is () not implemented theprocedural macro right (it doesn't rewrite trait function declarations) also (b) doesn't because trait function returning impl futureis implemented the compiler today. 'm told this eventually, though!ok then next best thing is #[async(boxed)] return boxed traitobject instead impl future the meantime. still isn't actuallyimplemented the futures-await implementation #[async] ( doesn'trewrite trait functions) it's plausible! now brings to handling self. of limitations #[async] today only two options, self self: box<self>. former is unfortunately object safe ( we 't virtual dispatch this trait) the latter is typically wasteful (every invocation requires fresh allocation). ideally self: rc<self> is exactly we here! unfortunately isn't implemented the compiler basically summary 've got of options return futures traits today:trait mystuff { // trait is object safe of `self` can't virtual // dispatch, the allocation `box<..>` a return value is required // until compiler implements returning `impl future` traits. // // note the upside this approach, though, is `self` be // something `rc` have bunch fo `rc` inside `self`, this // be cheap call. fn do_async_task(self) -> box<future<...>>;} the alternative:trait mystuff { // above returned trait object here trait is indeed object // safe, allowing virtual dispatch. downside is we must a // `box` hand every we call function, may costly // some situations. fn do_async_task(self: box<self>) -> box<future<...>>;} ideal end goal futures--traits is :trait mystuff { #[async] fn do_async_task(self: rc<self>) -> result<i32, u32>;} this needs three pieces be implemented: compiler must accept trait functions returning impl trait compiler needs support self: rc<self>, basically object-safe customsmart pointers traits. finally, compiler needs support proc_macro_attribute expansion trait functions this, allowing #[async] implementation rewrite signature.licensefutures-await is primarily distributed under terms both mitlicense the apache license (version 2.0), portions covered variousbsd- licenses. license-apache, license-mit details."
}