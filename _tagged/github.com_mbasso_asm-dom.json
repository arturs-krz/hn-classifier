{
	"_id": "14381356",
	"site": "https://github.com/mbasso/asm-dom",
	"title": "Asm-Dom â€“ WebAssembly Virtual DOM",
	"author": "mbasso",
	"date": "2017-06-13T13:57:07.532Z",
	"tags": {
		"categories": [
			"opensource",
			"virtual-dom",
			"dom",
			"rendering",
			"virtual-dom-library",
			"webassembly",
			"wasm",
			"asmjs",
			"diffing",
			"asm-dom",
			"vdom"
		],
		"languages": [
			"javascript",
			"c++"
		]
	},
	"content": "readme.md asm-dom minimal webassembly virtual dom focused performancetable contentsinstallationmotivationinline exampleexamplesdocumentationimplementation performanceroadmapchange logauthorscopyright licenseinstallation can install asm-dom using npm:npm install --save asm-dom you are using library webpack also need install arraybuffer-loader:npm install --save-dev arraybuffer-loader add object your loaders:{ test: /\\.wasm$/, loaders: ['arraybuffer-loader'],}, if have problems fs, can add to webpack config:node: { fs: 'empty',},motivationasm-dom is minimal webassembly virtual dom focused performance. is born the idea test powerful webassembly a common case is gaming, vr, ar image / video editing. unfortunately, the moment, gc / dom / web api integration is future feature , , asm-dom isn't totally developed wasm. interactions the dom are written javascript. is big disadvantage of overhead the binding between js wasm, the future asm-dom be more powerful, anyway results are satisfying.last not least, project aims be example those want try webassembly emscripten!inline exampleimport init 'asm-dom';const asmdom = await init();// init().(asmdom => { ... });const { h, patch } = asmdom;const root = document.getelementbyid('root');const vnode = h('div', { raw: { onclick: () => console.log('clicked') }}, [ h('span', { style: 'font-weight: bold' }, ' is bold'), ' this is normal text', h('', { href: '/foo' }, '\\'ll you places!')]);// patch empty dom element modifies dom a side effectpatch(root, vnode);const newvnode = h('div', { raw: { onclick: () => console.log('another click') }}, [ h('span', { style: 'font-weight: normal; font-style: italic' }, ' is italic type'), ' this is normal text', h('', { href: '/bar' }, '\\'ll you places!')]);// second `patch` invocationpatch(vnode, newvnode); // asm-dom efficiently updates old view the stateexamplesexamples are available the examples folder., here is list the online demos:todo mvcdocumentationinit default asm-dom returns init function takes optional configuration object. represents module object passed emscripten 3 additional props:usewasm: true you to force usage webassemblyuseasmjs: true you to force usage asm.jsclearmemory: true default, set to false you to free memory manually, more information deletevnode.unsafepatch: false default, set to true you haven't single patch your application. allows to call patch an oldvnode hasn't been used previously. example, have enable option you to patch subtree your vdom then replacechild, more information patch. default asm-dom uses webassembly supported, otherwise asm.jsplease note this function creates module the time is called, next times returns promise resolve the same, cached object.import init 'asm-dom';// init returns promiseconst asmdom = await init();// const asmdom = await init({ useasmjs: true });// init().(asmdom => { ... });h can create vnodes using h function. h accepts tag/selector a string, optional data object an optional string array children. data object contains attributes a special raw prop can contains callbacks raw values applied the dom element the dot notation. should put raw properties value checked. returns memory address your virtual node.const { h } = asmdom;const vnode = h('div', { style: 'color: #000' }, [ h('h1', 'headline'), h('p', ' paragraph'),]);const vnode2 = h('div', { id: '-id', // node.setattribute('id', '-id') classname: 'foo', // classname is special attribute evaluated 'class' 'data-foo': 'bar', // dataset attribute raw: { onclick: (e) => console.log('clicked: ', e.target), foo: 'bar', // raw value: node.foo = 'bar' },});patch patch takes arguments, first is dom element a vnode representing current view. second is vnode representing new, updated view. patch succedeed, new vnode ( second parameter) is returned. a dom element is passed, newvnode be turned a dom node, the passed element be replaced the created dom node. an oldvnode is passed, asm-dom efficiently modify to match description the vnode. unsafepatch init is equal false, old vnode passed must the resulting vnode the previous call patch. otherwise, operation is performed undefined is returned.const { h, patch } = asmdom;const oldvnode = h('span', 'old node');const newvnode = h('span', ' node');patch(document.getelementbyid('root'), oldvnode);patch(oldvnode, newvnode);// unsafepatch = falseconst vnode = h('div');patch(oldvnode, vnode); // returns undefined, found oldvnode, expected newvnode unsafepatch = true can implement interesting mechanisms, example can something this:const oldvnode = h('span', 'old text');const vnode = h('div', [ h('span', ' is text'), oldvnode]);patch(document.getelementbyid('root'), vnode);const newvnode = h('span', ' text');// patch the childpatch(oldvnode, newvnode);// update treereplacechild(vnode, oldvnode, newvnode);deletevnode we said before h returns memory address. means this memory to deleted manually, we to in c++ example. default asm-dom automatically delete old vnode memory patch is called. however, you to create vnode is patched, if want manually manage aspect (setting clearmemory: false the init function), have delete manually. this reason have developed function allows to delete given vnode all children recursively:const vnode1 = h('div');const vnode2 = h('div', [ h('span',)]);patch(vnode1, vnode2); // vnode1 automatically deletedconst child1 = h('span', 'child 1');const child2 = h('span', 'child 2');const vnode = h('span', [ child1, child2,]);deletevnode(vnode); // manually delete vnode, child1 child2 memoryremovechildremove given child the given parent:const child = h('div');const parent = h('span', [ h('video'), child,]);removechild(parent, child); // parent = h('span', [h('video')]);deletevnode(child);replacechildreplace child another the given parent:const oldchild = h('div');const newchild = h('span');const parent = h('span', [ h('video'), oldchild,]);replacechild(parent, oldchild, newchild); // parent = h('span', [h('video'), h('span')]);deletevnode(oldchild);implementation performancehere can find paper explain we've written asm-dom ( you to experiment something webassembly, might a starting point) some considerations performances.please note this section is completed yet.before writing analysis the performance, 've decided develop first point the roadmap ( asm-dom usable directly c++ develop frontend). this we evaluate a better the cost js bindings make analysis better.consider that benchmarking library is easy, have reproduce real world situations big vnodes trees frequent updates. run single patch a sequence patch a -loop might produce results are attributable a real application. think this is better show numbers, can help people learn something , maybe, can some advice make asm-dom better.roadmap asm-dom usable directly c++ develop frontend (allow write entire apps webassembly) asm-dom aims be more powerful gc / dom / web api integration. unfortunately is future feature , , we to patient wait bit. the closure compiler (cause problems wasm, need update emscripten)change log project adheres semantic versioning.every release, along the migration instructions, is documented the github releases page.authorsmatteo bassogithub/mbasso@teo_bassocopyright licensecopyright portions project asm-dom are held simon friis vindum, 2015 part project snabbdom. other copyright project asm-dom are held matteo basso.copyright (c) 2016, matteo basso.asm-dom source code is licensed under mit license."
}