{
	"_id": "14132866",
	"site": "https://github.com/cretz/asmble",
	"title": " Asmble â€“ Compile WebAssembly to the JVM",
	"author": "kodablah",
	"date": "2017-06-13T13:35:12.635Z",
	"tags": {
		"categories": [
			"opensource",
			"jvm",
			"wasm",
			"webassembly"
		],
		"languages": [
			"kotlin",
			"java"
		]
	},
	"content": "readme.md asmbleasmble is compiler compiles webassembly code jvm bytecode. also containsutilities working wasm code the command line from jvm languages.quick startwebassembly itself does have routines printing stdout any external platform features. thisexample 'll the test harness used the spec. java 8 must installed.download latest tar/zip the releases area extract toasmble/.webassembly code is either a binary file (.e. .wasm files) atext file (.e. .wast files). following code imports printfunction the test harness. it creates function calling print the integer 70 sets to called module init:(module (import \"spectest\" \"print\" (func $print (param i32))) (func $print70 (call $print (i32.const 70))) (start $print70))save as print-70.wast. to run , execute:./asmble/bin/asmble run -testharness print-70.wast result be:70 : i32 is the test harness prints integer.cli usageassuming java 8 is installed, download latest release extract .the asmble command is present the asmble/bin folder. are multiple commands asmble can seen executing asmble no commands:usage: command options...commands: compile - compile webassembly class file help - show command help invoke - invoke webassembly function run - run webassembly script commands translate - translate webassembly one form another detailed command info, : help commandcompilingrunning asmble help compile:command: compiledescription: compile webassembly class fileusage: compile <infile> [-format <informat>] <outclass> [- <outfile>]args: <infile> - wast wasm webassembly file name. be '--' read stdin. required. -format <informat> - either 'wast' 'wasm' describe format. optional, default: < file extension> -log <loglevel> - of: trace, debug, info, warn, error, off. optional, default: warn <outclass> - fully qualified class name. required. - <outfile> - file name output . can '--' to write stdout. optional, default: <outclass.class> is used compile webassembly a class file. the compilation details details howwebassembly translates jvm bytecode. result be .class file containing jvm bytecode.note: is runtime required the class files. are self-contained.invokingrunning asmble help invoke:command: invokedescription: invoke webassembly functionusage: invoke [- <infile>]... [-reg <registration>]... [-mod <module>] [<export>] [<arg>]...args: <arg> - parameter the export export is present. multiple allowed. optional, default: <empty> -defmaxmempages <defaultmaxmempages> - maximum number memory pages a module doesn't . optional, default: 5 <export> - specific export function invoke. optional, default: <start-func> - <infile> - files add classpath. be wasm, wast, class file. named wasm/wast modules here are automatically registered unless -noreg is set. multiple allowed. optional, default: <empty> -log <loglevel> - of: trace, debug, info, warn, error, off. optional, default: warn -mod <module> - module name run. it's jvm class, must a -arg constructor. optional, default: <last--entry> -noreg - set, will auto-register modules names. optional. -reg <registration> - register class name a module name. format: modulename=classname. multiple allowed. optional, default: <empty> -res - there is result, print . optional. -testharness - set, registers spec test harness 'spectest'. optional. can run webassembly code including compiled .class files. example, put following webassembly add-20.wast:(module (func (export \"doadd\") (param $ i32) (result i32) (i32.add (get_local 0) (i32.const 20)) )) can invoked via following the result shown:asmble invoke -res - add-20.wast doadd 100 will print 120. however, can compiled like :asmble compile add-20.wast myclass there is file called myclass.class. since has no-arg constructor it doesn't import anything (compilation details below), can invoked well:asmble invoke -res - myclass.class -reg mymod=myclass -mod mymod doadd 100note, any java class be registered the part. just needs have no-arg consstructor anyreferenced functions need be public, non-static, with return/param types only int, long, float, double.running scripts webassembly spec has concept scripts testing purposes. running asmble help run:command: rundescription: run webassembly script commandsusage: run [- <infile>]... [-reg <registration>]... <scriptfile>args: -defmaxmempages <defaultmaxmempages> - maximum number memory pages a module doesn't . optional, default: 5 - <infile> - files add classpath. be wasm, wast, class file. named wasm/wast modules here are automatically registered unless -noreg is set. multiple allowed. optional, default: <empty> -log <loglevel> - of: trace, debug, info, warn, error, off. optional, default: warn -noreg - set, will auto-register modules names. optional. -reg <registration> - register class name a module name. format: modulename=classname. multiple allowed. optional, default: <empty> <scriptfile> - script file run commands . this be '--' stdin. must wast format. required. -testharness - set, registers spec test harness 'spectest'. optional. take something thestart.wasttest case the spec run with test harness:asmble run -testharness start.wast confirm returns expected output. comments concerning importing java classes \"invoke\" apply here too.translatingrunning asmble help translate:command: translatedescription: translate webassembly one form anotherusage: translate <infile> [- <informat>] [<outfile>] [- <outformat>]args: -compact - set wast format, be compacted. optional. <infile> - wast wasm webassembly file name. be '--' read stdin. required. - <informat> - either 'wast' 'wasm' describe format. optional, default: < file extension> -log <loglevel> - of: trace, debug, info, warn, error, off. optional, default: warn <outfile> - wast wasm webassembly file name. be '--' write stdout. optional, default: -- - <outformat> - either 'wast' 'wasm' describe format. optional, default: < file extension wast stdout>asmble translate .wasm files .wast vice versa. can translate .wast .wast has value it resolves names creates more raw yet deterministic sometimes more readable .wast. technically, can translate .wasm .wasm there is real benefit. asmble is doing internally here is converting a common ast regardless input writing out the desiredoutput.programmatic usageasmble is written kotlin since kotlin is thin layer traditional java, can used quite easily alljvm languages.getting latest tag be added your build script via jitpack. example,here are instructions using 0.1.0 release here are instructions the latest master.building testing manually build, clone repository:git clone --recursive https://github.com/cretz/asmble reason use recursive is clone spec submodule have embedded src/test/resources/spec. , withgradle installed, navigate the cloned repository create gradle wrapper viagradle wrapper. the gradlew command is available. build, run ./gradlew build. will run tests includes test suite the webassembly spec.running ./gradlew assembledist builds same zip tar files uploaded the releases area.library notes api documentation is yet available this early stage. as overview, here are interesting classes packages:asmble.ast.node - webassembly ast nodes static inner classes.asmble.cli - code the cli.asmble.compile.jvm.asttoasm - entry point go ast module asm classnode.asmble.compile.jvm.mem - interface can implemented change memory is handled. right bytebuffermem the same package is only implementation it emits bytebuffer.funcbuilder - where bulk the wasm-instruction--jvm-instruction translation happens.asmble.io - classes translating /from ast nodes, bytes (.e. wasm), sexprs (.e. wast), strings.asmble.run.jvm - tools running wasm code the jvm. specifically scriptcontext helps linking. for those reading code, here are interesting algorithms:asmble.compile.jvm.runtimehelpers#bootstrapindirect ( java, kotlin) - manipulating arguments essentiallychain methodhandle calls an invokedynamic bootstrap. is actually taken the compiled java class injected a synthetic method the module class needed.asmble.compile.jvm.insnreworker#addeagerlocalinitializers - backwards navigation the instruction list makesure a local is set before is .asmble.compile.jvm.insnreworker#injectneededstackvars - inject instructions certain places make sure havecertain items the stack we need .asmble.io.bytereader$inputstream - simple eof-peekable input stream reader.compilation detailsasmble does best compile wasm ops jvm bytecodes minimal overhead. below are details how each partis done. every module is represented a single class. section assumes familiarity webassembly concepts.constructorsasmble creates different constructors based the memory requirements. each constructor created contains imports parameters ( imports below) the module does define memory, single constructor is created accepts other imports. the module doesdefine memory, constructors are created: accepting memory instance, an overload instead accepts integer value max memory is used create memory instance before sending the one. the maximummemory is given the module, third constructor is created without memory parameters just calls maxmemory overload w/ given max memory value. three course other imports the rest the parameters. all constructor duties (described sections below), module's start function is called present.memorymemory is built accepted the constructor is stored a field. current implementation uses bytebuffer.since bytebuffers are dynamically growable, max memory is absolute max though is limit is adjusted grow_memory. data the memory is set the constructor.table the webassembly mvp table is a set function pointers. is stored a field an array methodhandle instances. elements the table are set the constructor.globalsglobals are stored fields the class. non-import global is simply field, an import global is methodhandle the getter ( would a methodhandle the setter mutable globals were supported). values the globals are set the constructor.imports constructor accepts imports params. memory is imported via bytebuffer param, functionimports methodhandle params, global imports methodhandle params, a methodhandle array param animported table. of values are set fields the constructor.exportsexports are exported public methods the class. export names are mangled conform java identifierrequirements. function exports are is whereas memory, global, table exports the name capitalized are prefixed \"get\" match java getter conventions.exports are always separate methods instead just changing name an existing method field. encapsulationallows things many exports a single item.typeswebassembly has 4 types: i32, i64, f32, f64. translate quite literally int, long, float, double respectively.control flow operationsoperations such unreachable ( throws) behave mostly expected. branching looping are handled jumps. problem occurs jumping is webassembly does require compiler writers clean their own stack.therefore, the wasm ops extra stack values, pop before jumping has performance implications notbig ones. most sane compilers, stack be managed stringently leftover stack items not present.luckily, br_table jumps translate literally jvm table switches makes very fast. is special set code handling really large tables ( of java's method limit) this is unlikely affect inpractice.call operationsnormal call operations different things depending upon whether is import not. it is import, methodhandle is retrieved a field called via invokeexact. otherwise, normal invokevirtual is done call local method. call_indirect is done via invokedynamic the jvm. specifically, invokedynamic specifies synthetic bootstrapmethod we create. does one- call that bootstrap method get methodhandle can called the future. wouldn't normally to invokedynamic we use index reference methodhandle the array field. however, webassembly, index is the parameters the call thestack manipulation would to would far too expensive. we need methodhandle takes params the target method, then index, make call. we need \"\" because is expected some point the future the table field be changed underneath we don't that field reference be cached via one- bootstrap call. do with synthetic bootstrapmethod uses methodhandle trickery manipulate the we . this makes indirect calls very fast,especially successive invocations.parametric operations drop translates literally a pop. select translates a conditional swap, a pop.variable accesslocal variable access translates fairly easily webassembly the jvm treat concept parameters theinitial locals similarly. granted jvm form has \"\" at slot 0. , webassembly doesn't treat 64-bit vars 2slots the jvm, some simple math is done it is the stack.webassembly requires locals assume are 0 whereas jvm requires locals set before . an algorithm asmble makes sure locals are set 0 before are fetched any situation where weren't explicitly set.global variable access depends whether 's import not. imports call getter methodhandles whereas non-importssimply normal field access.memory operationsmemory operations are done via bytebuffer methods a little-endian buffer. operations including unsignedoperations are tailored use specific existing java stdlib functions. a special optimization, put memory instance a local var it is accessed lot a function. ischeaper constantly fetching field.number operationsconstants are simply ldc bytecode ops the jvm. comparisons are done via specific bytecodes sometimes combined jvm calls things unsigned comparison. operators idiomatic jvm approaches well. webassembly spec requires runtime check overflow during trunc calls. is enabled default asmble. defers an internal synthetic method does overflow check. can programmatically disabled betterperformance.stackasmble maintains knowledge types the stack during compilation fails compilation any invalid stack items. includes somewhat complicated logic concerning unreachable code. several cases, asmble needs something the stack webassembly doesn't, such \"this\" before value aputfield call setting non-import global. order facilitate , asmble does preprocessing theinstructions. builds stack diffs injects needed items (e.g. reference the memory class a load) the right place the instruction list make sure are present needed. an unintended side effect this kind logic, turns that asmble never needs local variables beyond webassembly specifies. temp variables anything. could argued however the of temp locals might some the compilation logic less complicated could improve runtime performance places where overuse stack (e.g. places where do swap).caveatsbelow are performance implementation quirks where is bit an impedance mismatch between webassembly the jvm:webassembly has nice data section byte arrays whereas jvm does . right we build byte array a bunch consts runtime is multiple operations per byte. can bloat class file size, is quitefast compared alternatives such string constants. jvm makes guarantees trailing bits being preserved nan floating point representations webassemblydoes. causes mismatch webassembly tests depending how jvm \"feels\" ( haven't dug why bit patterns stay some don't nans are passed through methods). jvm requires strict stack management where compiler writer is expected pop off he doesn't beforeperforming unconditional jumps. webassembly requires runtime discard unused stack items before unconditionaljump we to handle . this cause performance issues essentially do \"pop-before-jump\" pops unneeded stack values before jumping. the target the jump expects fresh item the stack (.e. typed block) it gets worse we to pop we don't need except the last stack value leads a swap-pop--swap. hopefully real world , tools compile webassembly don't a bunch these cases. they , we may need look spilling temporary local vars.both memory tables \"max capacity\" \"initial capacity\". while memory uses bytebuffer has concepts (.e. \"capacity\" \"limit\"), tables an array only has \"initial capacity\". means tests check max capacity imports link do fail we don't store max capacity a table. is a real problem the mvp since table cannot grown. once can, may need considerbringing another int along us table max capacity ( at least it option).webassembly has concept \"unset max capacity\" means can theoretically an infinite capacity memoryinstance. bytebuffers not support , but care is taken allow link and runtime max memory setting give caller freedom.webassembly requires trunc calls do overflow checks, whereas jvm does . so example, webassemblyhas i32.trunc_s/f32 would usually a simple f2i jvm instruction, we to an overflow check the jvm does do. do via private static synthetic method the module. is too much going toinline in method if several functions need , it become hot jit'd. may an argument amore global set runtime helpers, we aim be runtime free. care was taken allow overflow checks beturned off programmatically.webassembly allows unsigned 32 bit int memory indices. bytebuffer has signed means value overflow. in order support larger sets memory, webassembly supports constant offsets are added the runtime indices. asmble eagerly fail compilation an offset is of range. at runtime don'tcheck default the overflow wrap around access wrong memory. is option do overflow check added the offset is disabled default. than there is nothing can easily.faqwhy? like writing compilers i needed sufficiently large project learn kotlin really to a reasonablejudgement it. also wanted become familiar w/ webassembly. don't really a business interest this therefore cannot promise will forever maintained. it on android? have investigated. i use invokedynamic methodhandle it need be modern version android. assume, , that both runtime compile- code might run . experiment feedback welcome. about jvm wasm?'ll watching gc approach taken then reevaluate options. everyone is focused targeting wasm severallanguages is missing big problem: lack a standard library. is a lot interoperability betweenwasm compiled rust, c, java, etc e.g. all their own of handling strings. someone needs build definition an importable set modules does of things, if 's webidl. dunno, maybe effort is already , i haven't really looked. i compile something c via emscripten have run the jvm this?yes, work is required. webassembly is lacking kind standard library. emscripten either embed orimport from platform ( sure /where, haven't investigated). might a worthwhile project build libc--sorts emscripten knows for jvm. granted is probably the logical approach run c thejvm compared direct llvm--jvm .debugging? yet, once source maps standardized may revisit.todoadd \"dump\" basically goes webassembly \"javap\" output details are clearexpose advanced compilation optionsadd \"link\" command will build entire jar of several webassembly files glue code between annotations make clear imports are expectedcompile js native kotlinadd javax.script ( can things a free repl w/ jrunscript)"
}