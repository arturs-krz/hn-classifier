{
	"_id": "14165214",
	"site": "https://github.com/jgaa/restc-cpp",
	"title": " Restc-cpp â€“ The magic that takes the pain out of JSON API's from C++",
	"author": "jgaa",
	"date": "2017-06-13T13:34:46.709Z",
	"tags": {
		"categories": [
			"opensource",
			"json-serialization",
			"asio",
			"rest-client",
			"coroutines",
			"c-plus-plus",
			"json",
			"http-client",
			"rest"
		],
		"languages": [
			"c++",
			"cmake",
			"other"
		]
	},
	"content": "readme.md introduction the restc-cpp c++ library magic takes pain of accessing json api's c++ it does: formulates http request a rest api server. , it transforms json formatted payload the reply a native c++ object ().it serialize native c++ object a container c++ objects a json payload send to rest api server (post, put). formulates http request the rest api without serializing data eitherdirection (typically delete). uploads stream data, a file, a http server. downloads stream data, a file an array json objects, a http server.'s basically . it does solve world hunger. make attempts be c++ framework. can it's single components, the powerful c++ http client send receive non-json data a native c++ replacement libcurl. can the template code transforms data between c++ json other purposes ( example a rest api server) - the libraryis designed implemented the single purpose using c++ interact efficiently effortless external rest api servers. library is written jarle (jgaa) aase, senior freelance c++ developer roughly 30 years experience software development.design goals design goal this project is make external rest api'ssimple safe use c++ projects, still fast memory efficient.another goal was use coroutines the application logic sends data orpulls data the rest api servers. makes code easy write understand, also simplifies debugging investigation core dumps. short; code executes asynchronously, there are visible callbacks completion functions. looks crystal clear,old fashion, single threaded sequential code (using modern c++ language). don't sacrifice code clearness achieve massive parallelism high performance. coroutines was strong motivation write newc++ http client scratch. see this actually works, please themodern async cpp example).finally, a world where internet is getting increasinglydangerous, all kind malicious parties, your own government international mafia( putin moscow the clown the white house, differences isblurring ), search vulnerabilities your software stack snoop, ddos,intercept blackmail and customers/users - have strong emphasis security all software projects 'm involved . i limited dependencies third party libraries much i (i still openssl is snakes nest of yet undisclosed vulnerabilities - as now are alternatives works of box boost::asio). have tried imagine possible a malicious api server try attack (by exploiting exceeding local resources - sending malicious compressed package expands a petabyte zeros) designed detect potential problems break of by throwing exception soon possible.why? the spring 2016 was asked implement sdk a rest api several languages. python, java ruby was trivial make simpleobject oriented implementation. i started planning c++ implementation thesdk, found suitable, free libraries. could even find proper http clientimplementation(!). could solved problem using qt - i found overkill use huge gui framework c++ code are likely run high performance servers - that may end in projects using otherc++ framework can't coexist qt.many years ago designed implemented c++ rest client an earlyversion amazon aws using libcurl - - well, had strong urge repeat experience. i spent few weeks creating own http client libraryusing boost::asio json serialization/deserialization.dependenciesrestc-cpp depends c++14 its standard libraries :boostrapidjson (mature, ultra-fast, json sax, header- library)lest (unit test header library) ( compiled testing enabled)openssl libressl ( compiled tls support)zlib ( compiled compression support)rapidjson lest is attached the project git sub-modules.licensemit license. is free. free in free beer. free in free air.examplesfetch raw data following code demonstrates to run simple http request asynchronously,using co-routine support boost::asio behind scenes.#include <iostream>#include \"restc-cpp/restc-cpp.h\"using namespace std;using namespace restc_cpp;void dosomethinginteresting(context& ctx) { // here are a co-routine, running a worker-thread. // asynchronously connect a server fetch data. auto reply = ctx.(\"http://jsonplaceholder.typicode.com/posts/1\"); // asynchronously fetch entire data-set return as string. auto json = reply->getbodyasstring(); // dump data. cout << \"received data: \" << json << endl;}int main() { auto rest_client = restclient::create(); // call dosomethinginteresting a co-routine a worker-thread. rest_client->process(dosomethinginteresting); // wait the coroutine finish, close client. rest_client->closewhenready(true);} here is output could expectreceived data: { \"userid\": 1, \"id\": 1, \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\", \"body\": \"quia et suscipitsuscipit recusandae consequuntur expedita et cumreprehenderit molestiae ut ut quas totamnostrum rerum est autem sunt rem eveniet architecto\"}fetch c++ object a server serialize jsonhere is sightly more interesting example, using jsonserialization, some modern c++ features.#include <iostream>#include <boost/lexical_cast.hpp>#include <boost/fusion/adapted.hpp>#include \"restc-cpp/restc-cpp.h\"#include \"restc-cpp/requestbuilder.h\"using namespace std;using namespace restc_cpp;// c++ structure match json entries received// http://jsonplaceholder.typicode.com/posts/{id}struct post { int userid = 0; int id = 0; string title; string body;};// since c++ does (yet) offer reflection, need tell library // to map json members a type. are doing by declaring // structs/classes boost_fusion_adapt_struct the boost libraries.// allows to convert c++ classes and json.boost_fusion_adapt_struct( post, (int, userid) (int, id) (string, title) (string, body))// c++ main function - place where adventure startsint main() { // create instantiate post data received the server. post my_post = restclient::create()->processwithpromiset<post>([&](context& ctx) { // is lambda co-routine, running a worker-thread // instantiate post structure. post post; // serialize asynchronously. asynchronously part does really matter // here, it may you receive huge data structures. serializefromjson(post, // construct request the server requestbuilder(ctx) .(\"http://jsonplaceholder.typicode.com/posts/1\") // add headers good taste .header(\"x-client\", \"restc_cpp\") .header(\"x-client-purpose\", \"testing\") // send request .execute()); // return post instance trough c++ future<> return post; }) // in main thread, the post instance the future<>, // any c++ exception thrown within lambda. .(); // print result everyone see. cout << \"received post# \" << my_post.id << \", title: \" << my_post.title;} code above should return something :received post# 1, title: sunt aut facere repellat provident occaecati excepturi optio reprehenderitplease refer the tutorial more examples.featureshigh level request builder interface (similar java http clients) convenience.low level interface create requests. network io operations are asynchronous trough boost::asio. your own asio io-serviceslet library create deal the asio io-services your own worker threadslet library create deal worker-threadsuses c++ / boost coroutines application logic.http redirects.http basic authentication.logging trough boost::log trough own log macros.connection pool fast re- of existing server connections.compression (gzip, deflate).json serialization and native c++ objects.optional mapping between c++ property names json ' the wire' names.option tag property names read- to filter out the c++ object is serialized transfer the server.filters empty c++ properties the c++ object is serialized transfer the server ( be disabled).iterator interface received json lists objects.memory constraint incoming objects ( limit damages rouge buggy rest servers).serialization directly std::istream c++ object.plain chunked outgoing http payloads.several strategies lazy data fetching outgoing requests.override requestbody let library pull data required.write directly the outgoing datawriter data is required. provide c++ object let library serialize directly the wire.current status project is maturing fast. are known bugs. project has been public beta since april 11th 2017.supported operating systems are operating systems test before releasing new version.debian stable (jessie)debian testingwindows 10 / microsoft visual studio 2015 2017, community version / professional version ( tests passes the latest release version docker windows)fedora 25ubuntu server ltsmacos sierra (os x)more informationgetting startedtutorialbuild linuxbuild macosbuild windowsrunning testsplanned"
}