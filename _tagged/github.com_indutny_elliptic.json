{
	"_id": "14438828",
	"site": "https://github.com/indutny/elliptic",
	"title": "Elliptic – Fast Elliptic Curve Cryptography in Plain JavaScript",
	"author": "sr2",
	"date": "2017-06-13T13:55:34.852Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript",
			"html"
		]
	},
	"content": "readme.md elliptic fast elliptic-curve cryptography a plain javascript implementation.note: please a at http://safecurves.cr.yp./ before choosing curve your cryptography operations.incentiveecc is much slower regular rsa cryptography, js implementations are more slower.benchmarks$ node benchmarks/index.jsbenchmarking: signelliptic#sign x 262 ops/sec ±0.51% (177 runs sampled)eccjs#sign x 55.91 ops/sec ±0.90% (144 runs sampled)------------------------fastest is elliptic#sign========================benchmarking: verifyelliptic#verify x 113 ops/sec ±0.50% (166 runs sampled)eccjs#verify x 48.56 ops/sec ±0.36% (125 runs sampled)------------------------fastest is elliptic#verify========================benchmarking: genelliptic#gen x 294 ops/sec ±0.43% (176 runs sampled)eccjs#gen x 62.25 ops/sec ±0.63% (129 runs sampled)------------------------fastest is elliptic#gen========================benchmarking: ecdhelliptic#ecdh x 136 ops/sec ±0.85% (156 runs sampled)------------------------fastest is elliptic#ecdh========================apiecdsavar ec = require('elliptic').ec;// create initialize ec context// (better it once reuse )var ec = ec('secp256k1');// generate keysvar key = ec.genkeypair();// sign message's hash (input must an array, a hex-string)var msghash = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];var signature = key.sign(msghash);// export der encoded signature arrayvar dersign = signature.toder();// verify signatureconsole.log(key.verify(msghash, dersign));// check no private keyvar pubpoint = key.getpublic();var x = pubpoint.getx();var y = pubpoint.gety();// public key must either:// 1) '04' + hex string x + hex string y; // 2) object two hex string properties (x y); // 3) object two buffer properties (x y)var pub = pubpoint.encode('hex'); // case 1var pub = { x: x.tostring('hex'), y: y.tostring('hex') }; // case 2var pub = { x: x.tobuffer(), y: y.tobuffer() }; // case 3var pub = { x: x.toarraylike(buffer), y: y.toarraylike(buffer) }; // case 3// import public keyvar key = ec.keyfrompublic(pub, 'hex');// signature must either:// 1) der-encoded signature hex-string; // 2) der-encoded signature buffer; // 3) object two hex-string properties (r s); // 4) object two buffer properties (r s)var signature = '3046022100...'; // case 1var signature = buffer('...'); // case 2var signature = { r: 'b1fc...', s: '9c42...' }; // case 3// verify signatureconsole.log(key.verify(msghash, signature));eddsavar eddsa = require('elliptic').eddsa;// create initialize eddsa context// (better it once reuse )var ec = eddsa('ed25519');// create key pair secretvar key = ec.keyfromsecret('693e3c...'); // hex string, array buffer// sign message's hash (input must an array, a hex-string)var msghash = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];var signature = key.sign(msghash).tohex();// verify signatureconsole.log(key.verify(msghash, signature));// check no private key// import public keyvar pub = '0a1af638...';var key = ec.keyfrompublic(pub, 'hex');// verify signaturevar signature = '70bed1...';console.log(key.verify(msghash, signature));ecdhvar ec = require('elliptic').ec;var ec = ec('curve25519');// generate keysvar key1 = ec.genkeypair();var key2 = ec.genkeypair();var shared1 = key1.derive(key2.getpublic());var shared2 = key2.derive(key1.getpublic());console.log('both shared secrets are bn instances');console.log(shared1.tostring(16));console.log(shared2.tostring(16));three more members:var ec = require('elliptic').ec;var ec = ec('curve25519');var = ec.genkeypair();var b = ec.genkeypair();var c = ec.genkeypair();var ab = .getpublic().mul(b.getprivate())var bc = b.getpublic().mul(c.getprivate())var ca = c.getpublic().mul(.getprivate())var abc = ab.mul(c.getprivate())var bca = bc.mul(.getprivate())var cab = ca.mul(b.getprivate())console.log(abc.getx().tostring(16))console.log(bca.getx().tostring(16))console.log(cab.getx().tostring(16))note: .derive() returns bn instance.supported curveselliptic.js support following curve types:short weierstrassmontgomeryedwardstwisted edwardsfollowing curve 'presets' are embedded the library:secp256k1p192p224p256p384p521curve25519ed25519note: curve25519 not used ecdsa, ed25519 instead.implementation detailsecdsa is using deterministic k value generation per rfc6979. of curve operations are performed non-affine coordinates (either projective extended), various windowing techniques are used different cases. operations are performed reduction context using bn.js, hashing isprovided hash.jsrelated projectseccrypto: isomorphic implementation ecdsa, ecdh ecies bothbrowserify node (uses elliptic browser secp256k1-node node)license software is licensed under mit license.copyright fedor indutny, 2014.permission is hereby granted, free charge, any person obtaining copy this software associated documentation files (\"software\"), deal the software without restriction, includingwithout limitation rights use, copy, modify, merge, publish,distribute, sublicense, /or sell copies the software, to permitpersons whom software is furnished do , subject thefollowing conditions: above copyright notice this permission notice shall included all copies substantial portions the software. software is provided \" is\", without warranty any kind, express implied, including not limited the warranties merchantability, fitness a particular purpose noninfringement. no event shall authors copyright holders liable any claim,damages other liability, whether an action contract, tort otherwise, arising , out or connection the software the or dealings the software."
}