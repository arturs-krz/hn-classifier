{
	"_id": "14530164",
	"site": "https://github.com/e-oj/Fawn",
	"title": "Transactions for MongoDB â€“ JavaScript",
	"author": "e_oj",
	"date": "2017-06-13T14:09:47.983Z",
	"tags": {
		"categories": [
			"opensource",
			"mongodb",
			"mongoose",
			"transaction"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md fawnpromise based library transactions mongodbfawn provides ability carry edits a mongodb database a series steps. an error occurs any the steps, database is returned it's initial state ('s state before transaction started).view githubgetting startedusageapimisc.testgetting started:install node.js mongodbstart mongodb a terminal: mongod:npm install fawnusage:var fawn = require(\"fawn\");examples you two bank accounts, belongs john smith the belongs broke ass. would to transfer $20 john smith broke ass. assuming first name last name pairs are unique, might like:var task = fawn.task()//assuming \"accounts\" is accounts collectiontask.update(\"accounts\", {firstname: \"john\", lastname: \"smith\"}, {$inc: {balance: -20}}) .update(\"accounts\", {firstname: \"broke\", lastname: \"ass\"}, {$inc: {balance: 20}}) .run() .(function(results){ //task is complete //mongoose result first operation var firstupdateresult = results[0]; //result second operation var secondupdateresult = results[1]; }) .catch(function(err){ // everything has been rolled . //log error caused failure console.log(err); }); you prefer to chain function calls, don't to. results also ignored:task.update(\"accounts\", {firstname: \"broke\", lastname: \"ass\"}, {$inc: {balance: -20}})task.update(\"accounts\", {firstname: \"coke\", lastname: \"dealer\"}, {$inc: {balance: 20}})task.run() .(function(){ //update is complete }) .catch(function(err){ // everything has been rolled . //log error caused failure console.log(err); }); server crash before task is complete, can the roller rollback incomplete transactions before starting server.// assuming fawn has been initialized. fawn.init belowvar roller = fawn.roller();roller.roll() .(function(){ // start server });apifawn.initfawn.tasktask.initmodeltask.savetask.updatetask.optionstask.removetask.runfawn.rollerroller.rollfawn.init(db, _collection, options): initialize fawndb (required): mongoose instance connection string_collection (optional): name collection used internally fawn store transactionsoptions (optional. lol): connection options. same mongoose connection options note: you're running multiple apps connected the same db, provide string value _collection 's unique each app. this avoid situation where app rolls the unfinished transaction(s) another app. you're using mongoose your project initialize fawn mongoose:var mongoose = require(\"mongoose\");mongoose.connect(\"mongodb://127.0.0.1:27017/testdb\");// remember, _collection is optionalfawn.init(mongoose, \"fawn_collection_name_if_you_want_to_specify\");without mongoose, initialze fawn so:// options object (http://mongoosejs.com/docs/connections.html#options)var options = { user: \"teh_huose_kat\", pass: \"teh_kitti_passwrod\"}var collection = \"fawn_collection_name_if_you_want_to_specify\";// remember, _collection options are optionalfawn.init(\"mongodb://127.0.0.1:27017/testdb\", collection || null, options || null);fawn.task(): create fawn taskreturns: new task intitializing fawn, create task so:var task = fawn.task();task.initmodel(modelname, schema): initialize model a schema.modelname (required): name the collection associated this modelschema (optional): same object passed mongoose schema. see validation you're using mongoose, define models mongoose wherever possible. the model has been defined mongoose before function is called, mongoose throw overwritemodelerror if was defined fawn, fawn throw error. models be defined once.var schema = { name: {type: string, required: true} , specials: [{title: string, : number}]}task.initmodel(\"comedians\", schema);save operations the \"comedians\" model validate against schema;task.save(model, doc): save documentmodel (required): name the collection 're saving or mongoose model a mongoose documentdoc (optional): object save a mongoose document are valid:var cars = mongoose.model(\"cars\", schema({: string, : number}));var toyota = cars({: \"toyota\", : 2015});task.save(\"cars\", {: \"toyota\", : 2015});task.save(cars, {: \"toyota\", : 2015});task.save(\"cars\", toyota);task.save(cars, toyota);task.save(toyota);note: changes be made to database until call task.run() task.update(model, condition, data): update documentmodel (required): name the collection 're updating a mongoose model a mongoose documentcondition (required): same in mongoose mongodbdata (optional): data update same in mongoose mongodb are validvar cars = mongoose.model(\"cars\", schema({: string, : number}));task.update(\"cars\", {: \"toyota\"}, {: 2016});task.update(cars, {: \"toyota\"}, {: 2016});cars.findone({: \"toyota\"}, function(toyota){ task.update(toyota, {: 2016});});note: changes be made to database until call task.run() task.options(options): add options an update task.options (required): update options - same in mongoose attach update call showntask.update(\"cars\", {: \"toyota\"}, {: 2016}) .options({multi: true});// validtask.update(\"cars\", {: \"ford\"}, {: 2016});task.options({multi: true});note: changes be made to database until call task.run() task.remove(model, condition): remove document(s) a collectionmodel (required): name the collection 're deleting or mongoose model a mongoose documentcondition (optional): same in mongoose are validvar cars = mongoose.model(\"cars\", schema({: string, : number}));// removes cars year === 2015task.remove(\"cars\", {: 2015});task.remove(cars, {: 2015});cars.findone({: 2015}, function(car){ // remove this car task.remove(car);})note: changes be made to database until call task.run() task.run(): run task.returns: promise the database changes occur, must call task.run(). function returns promise. success, promise is resolved an array containing mongoose result each operation sequence. an error occurs, promise is rejected the error caused failure.task.update(\"accounts\", {firstname: \"john\", lastname: \"smith\"}, {$inc: {balance: -20}}) .update(\"accounts\", {firstname: \"broke\", lastname: \"ass\"}, {$inc: {balance: 20}}) .run() .(function(results){ //task is complete //mongoose result first operation var firstupdateresult = results[0]; //result second operation var secondupdateresult = results[1]; }) .catch(function(err){ // everything has been rolled . //log error caused failure console.log(err); }); fawn.roller(): the roller object.returns: roller object initializing fawn, the roller so:var roller = fawn.roller(); roller.roll(): roll all incomplete transcationsreturns the documents affected incomplete transactions their original state. should be used no tasks are progress, usually server startup.var roller = fawn.roller();roller.roll() .(function(){ // start server });miscellaneoususing result previous steps subsequent steps might to the result a previous step a subsequent step. can this using object the key \"$ojfuture\". syntax: {$ojfuture: \"indexofstep.resultproperty1.property2.-----.propertyn\"}. here's :task.save(\"kids\", {name: {full: \"brody obi\"}}) //result be {_id: somemongoid, name: {full: \"brody obi\"}} .update(\"parents\", {_id: parentid}, {firstchild: {id: {$ojfuture: \"0._id\"} , fullname: {$ojfuture: \"0.name.full\"}}) .run() .(function(){ // task is complete }); use feature need know exact format the step's result. reference: result a save is saved object result a remove update is raw response mongodbtest test module, start mongodb a terminalmongod cd the project directory runnpm test"
}