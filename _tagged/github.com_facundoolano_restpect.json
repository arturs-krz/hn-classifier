{
	"_id": "14130635",
	"site": "https://github.com/facundoolano/restpect",
	"title": " Restpect â€“ succint and readable integration tests over RESTful APIs",
	"author": "facundo_olano",
	"date": "2017-06-13T13:35:12.455Z",
	"tags": {
		"categories": [
			"opensource",
			"rest",
			"rest-api",
			"http-requests",
			"testing"
		],
		"languages": [
			"clojure"
		]
	},
	"content": "readme.md restpectrestpect is small clojure library provides set functions write succint readableintegration tests restful apis.(require '[restpect.core :refer [created ok -found]] '[restpect.json :refer [ put delete]] '[clojure.test :refer [deftest]])(deftest create--and-delete-user ;; expect 201 status response body containing :user-id integer (created (put \"http://example.com/api/v1/users/john\" {:email \"john@example.com\"}) {:user-id integer?}) ;; expect 200 status body containing :user-id :email (ok ( \"http://example.com/api/v1/users/john\") {:user-id integer? :email \"john@example.com\"}) ;; expect response body be collection contains least ;; element has :user-id integer the given :email (ok ( \"http://example.com/api/v1/users/\") #{{:user-id integer? :email \"john@example.com\"}}) (ok (delete \"http://example.com/api/v1/users/john\")) ;; expect 404 status a body a :message string contains \" found\" (-found ( \"http://example.com/api/v1/users/john\") {:message #\" found\"}))installationadd following your project :dependencies:[restpect \"0.2.1\"]referencerequest helpers restpect.json namespace provides wrappers around clj-httprequest functions sane defaults json api requests (coerce request response json, don't throw exceptions 4xx 5xx responses, etc.). these functions the following signature:(post url)(post url body)(post url body extras) body is passed clj-http the :form-params post, put, patch delete, as :query-params get, head options.extras is map overrides passed the clj-http call.assertion functionsexpect main assertion function is restpect.core/expect:(expect response spec) first argument (usually clj-http response map, although can any value), be compared against given spec the following criteria: maps, compare value each key the spec the value the same key the response, using expect recursively. sets, check each element the spec matches element the response,comparing expect recursively. is useful look an element somewhere a list, regardless the position. other collections, compare each element the spec the same element thesame position the response, using expect recursively. functions, pass value the response the spec function expecting truthy result. regular expressions match spec the actual value (using re-find). the rest the values, expect spec the response values be equal.example:(expect ( url) {:status 404 :body [{:result nil? :code 125 :message #\" found\"}]}) assertion is equivalent the following:(let [res ( url)] (is (= 404 (:status res))) (is (nil? (-in res [:body 0 :result]))) (is (= 125 (-in res [:body 0 :code]))) (is (re-find #\" found\" (-in res [:body 0 :message])))) seen the example, expect is opinionated the sense it makes simple test values conditions specific fields the reponsesrather doing exact comparison the payloads.status shorthandsrestpect.core provides set wrappers around expect thenames the different http response status codes: ok, created, bad-request,-found, etc. helpers implicitly validate :status value the given response map, can optionally a second argument will compared against response body.using status shorthands, example the previous section becomes:(-found ( url) [{:result nil? :code 125 :message #\" found\"}])another example:(deftest create--delete-user (created (put \"http://example.com/api/v1/users/john\" {:email \"john@example.com\"})) (ok ( \"http://example.com/api/v1/users/john\")) (ok (delete \"http://example.com/api/v1/users/john\")) (-found ( \"http://example.com/api/v1/users/john\")))test reporterrestpect provides custom test reporter adds request responseinformation failure messages (provided expect) does formatting: report multimethod be found restpect.report/report can used plugins allow override test reporter, eftest lein-test-refresh:;; project.clj:eftest {:report restpect.report/report}:test-refresh {:report restpect.report/report} you already with custom reporter just to add request/reponse data its output, consider adding defmethod :type :response, example:(require '[restpect.report :refer [print-response]] '[eftest.report.progress : eftest] '[clojure.test :refer [-test-]])(defmulti report :type)(defmethod report :default [m] (eftest/report m))(defmethod report :response [m] (-test- (println \"\" (repeat 80 \" \") \"\\033[f\" \"\\033[f\") (print-response (:response m))))"
}