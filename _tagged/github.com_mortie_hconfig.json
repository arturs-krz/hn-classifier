{
	"_id": "14434417",
	"site": "https://github.com/mortie/hconfig",
	"title": " HConfig, a human friendly config file for Node.js applications",
	"author": "mort96",
	"date": "2017-06-13T13:06:18.823Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript",
			"vim script"
		]
	},
	"content": "readme.md hconfigbetter config files node.js.usageunix style config filesapihconfig.parsefile(filename, includeroot)hconfig.parsestring(string, includeroot)hconfig.parseconffile(file, sections)hconfig.parseconfstring(string, sections)error handlingvalidationsyntaxstringsnumbersbooleans nullobjectsarrayssectionsincludecommentshconfig is configuration file parser json- syntax without thecruft. 's intended be used communication between computers, rather be written humans.warning: hconfig expects input be a trusted source. while 's extremely serious stuff remote code execution, hconfig exposeinformation your system an attacker through expanding environmentvariables.here's example config file an imaginary web server:conf.hcnf:general {port 8080host localhostindex [ .html .htm ]}# is where host cat picturesvirtual-host cats.example.com {webroot /var/www/mycats}# srs bsnsvirtual-host resume.example.com {webroot /var/www/resume}parse with line:hconfig.parseconffile(\"conf.hcnf\",{ general: \"once\", \"virtual-host\": \"many\" }); it returns object:{\"general\": {\"port\": 8080,\"host\": \"localhost\",\"index\": [ \".html\", \".htm\" ]},\"virtual-host\": [{ \"name\": \"cats.example.com\", \"webroot\": \"/var/www/mycats\" },{ \"name\": \"resume.example.com\", \"webroot\": \"/var/www/resume\" }]}general is object, becasue specified it exists once.virtual-host is array, we specified it exist many times.usageinstall:npm install hconfig:var hconfig = require(\"hconfig\");hconfig.parsefile(filename);// hconfig.parsestring(string);// hconfig.parseconffile(filename);// hconfig.parseconfstring(string); run tests (requires mocha):npm testunix style config files are many json- configuration formats a prettier syntax there, however those aren't really suitable a lot configuration files. config files unix-style tools (e.g rc files, web servers, texteditors) let include files, is incredibly important manysituations, neither json nor json replacements there are reallybuilt that mind. hconfig, can create files, foo.hcnf bar.hcnf, this:foo.hcnf:virtual-host http://cats.example.com {webroot /var/www/mycats}virtual-host http://resume.example.com {webroot /var/www/resume}include bar.hcnfbar.hcnf:virtual-host https://webmail.example.com {webroot /var/www/webmailssl-cert /etc/ssl/example.com.pemssl-key /etc/ssl/example.com.key} our imaginary web server runs hcnf.parseconffile(\"foo.hcnf\"), will a data structure looks this:{\"virtual-host\": [{\"name\": \"http://cats.example.com\",\"webroot\": \"/var/www/mycats\"}, {\"name\": \"http://resume.example.com\",\"webroot\": \"/var/www/resume\"}, {\"name\": \"https://webmail.example.com\",\"webroot\": \"/var/www/webmail\",\"ssl-cert\": \"/etc/ssl/example.com.pem\",\"ssl-key\": \"/etc/ssl/example.co.key\"}]} you imagine, is very useful a lot general configurationstuff; 's reason almost every traditional linux unix program has feature including configuration files.apihconfig.parsefile(filename, includeroot)parse file, the simple json.parse-style .by default, will parse file if was inside object literal, without braces, return object. however, includeroot is set true, will parse value; {foo 10} be object {foo: 10}, \"hello world\" be string, etc.hconfig.parsestring(string, includeroot) parsefile, with string instead a file.hconfig.parseconffile(file, sections)parse file the mode detailed under \"unix style config files\" heading. the sections parameter is object, will act a whitelist, an error be thrown the config file contains sections in object. will throw error, example:hconfig.parseconffile(\"foo.hcnf\", { \"virtual-host\": \"many\" });foo.hcnf:virtual-hots example.com { webroot /var/www } can specify a section should exist once. will thusthrow error:hconfig.parseconffile(\"foo.hcnf\", { \"general\": \"once\" });foo.hcnf:general { port 8080}general {port 8081}hconfig.parseconfstring(string, sections) parseconffile, with string instead a file.error handling the parser encounters problem the file 's parsing, willthrow instance the error object. differentiate parse errors bugs hconfig, hconfigparseerror property is set true. would suggesthandling errors something this:let data;try {data = hconfig.parsefile(\"conf.hcnf\");} catch (err) { (err.hconfigparseerror) {console.error(err.message);process.exit(1);} else {throw err;}}validation's useful the user get error messages whenever 've configuredsomething incorrectly, hconfig has built- way specify structure your config files give useful error messages.available types: string, number, array, object, bool, null, .note a type specified null be either null undefined.hconfig.parseconffile(\"foo.hcnf\", {general: {count: \"once\",props: {port: \"number\",host: \"string\",index: [ \"array\", \"string\" ]}},\"virtual-host\": {count: \"many\",props: {webroot: \"string\",\"ssl-cert\": \"string\",\"ssl-key\": \"string\"}}}); can validate name property ( value between section name the section block) any , but unlike properties, defaults [ \"string\", \"null\" ]. if manually set , it be typeexcept objects ( that syntax just confusing). let's you to allow to an array hostnames virtual-host ( not allow to unspecified):hconfig.parseconffile(\"foo.hcnf\", {\"virtual-host\": {count: \"many\",props: {name: [ \"string\", \"array\" ],webroot: \"string\"}}});foo.hcnf:virtual-host [ www.example.com example.com] {webroot /var/www/example.com} can specify default validation properties using *. unless default is specified, unknown properties result an error.here allow unknown properties be anything:hconfig.parseconffile(\"foo.hcnf\", {general: {props: {\"*\": \"\"}}})syntaxhconfig contains basic javascript data types; strings, numbers, objects,arrays, booleans, null. addition, has concept sections,though those exist using parseconffile parseconfstring.strings quoted string starts a \", continues until next \".$(foo) expands the environment variable foo\\\\ => \\\\\" => \"\\b => backspace\\f => formfeed => newline => carriage return\\t => tab\\uxxxx => unicode character quoted string also start a '. then continues until next'. type string doesn't expand escape sequences environmentvariables. unquoted string is sequence any characters than whitespace,[, ], [, }, and doesn't match other syntax.numbers javascript's numbers. allows exponents e e.booleans nulltrue is boolean true, false is boolean false, null is null.objects object starts a {, followed any number key/value pairs, is terminated }.a key value pair is string followed a value. is separatorbetween pairs, nor symbol between key value, than whitespace.{ port 8080 host example.com } => { port: 8080, host: \"example.com\" }arrays array starts a [, followed any number values, isterminated ].like objects, is separator between values.[ 10 20 50 ] => [ 10, 20 50 ]sections \"section\" exists parsed parseconffile parseconfstring. root the file is whitespace separated list sections. start a mandatory string ( section name), followed anoptional string ( name property), followed an object.virtual-host example.com { foo 10 }virtual-host blog.example.com { foo 15 }becomes:{\"virtual-host\": [{ \"name\": \"example.com\", \"foo\": 10 },{ \"name\": \"blog.example.com\", \"foo\": 15 }]}include include is unquoted string include, followed another string, the root the file (e.g inside section).'s valid parsed parseconffile parseconfstring.includes file the specified path, can relative absolute.relative paths are relative the file, the current directory parsed parseconfstring.commentscomments start a #.everything # to end the line is comment, thus ignored."
}