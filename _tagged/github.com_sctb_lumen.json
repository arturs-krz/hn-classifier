{
	"_id": "14372002",
	"site": "https://github.com/sctb/lumen",
	"title": "A Lisp for Lua and JavaScript",
	"author": "tosh",
	"date": "2017-06-13T13:57:06.843Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript",
			"common lisp",
			"lua",
			"other"
		]
	},
	"content": "readme.md lumenlumen is very small, self-hosted lisp lua javascript. provides flexible compilation environment an extensible reader, macros, extensible special forms, otherwise attempts match target runtime environment closely possible. can started running bin/lumen a machine node.js, lua, luajit installed.introductionevery piece code lumen is expression, expressions be evaluated give values. lumen has few kinds expressions evaluate themselves:> 1717> -5e4-5000> truetrue> falsefalsestrings are enclosed quotation marks, may contain newlines. special characters are escaped using backslash:> \"hi \"\"hi \"> \"one\"\"onetwo\"> \"\\\"b\"\"\\\"b\"nil represents nothingness, it isn't printed at command line:> nil>comments start ; and continue through rest the line:> 7 ; everyone's favourite7lists contain values, are written enclosing expressions parentheses. operators are called placing at beginning a list expression, list values be constructed using list operator:> (+ 10 2)12> (abs -10)10> (/ 128 2 2 2)16> (list 1 2 3 4)(1 2 3 4)lists contain values are identified their position, well values are identified the list a name:> (list 1 2 3)(1 2 3)> (list 1 2 : 10 b: 20)(1 2 b: 20 : 10)note values identified name, known keys, don't show in particular order.positional values be gotten of lists using at operator, keys using get operator:> ( (list 1 2 3) 1)2> ( (list : 10 b: 20) \"b\")20 shortcut a key whose value is true looks this, called flag:> (list :yes)(yes: true)variablesvariables are declared using define define-global. variables declared define are available use anywhere subsequent expressions the same scope, define-global makes globally available.> (define-global zzz \"ho\")> zzz\"ho\"> ( (define x 10) (+ x 9))19 evaluates multiple expressions, itself evaluates the value the last expression.variables a limited scope are introduced using let:> (let (x 10 y 20) (+ x y))30> (let x 41 (+ x 1))42> (let x 1 (let x 2 (print x)) (print x))21 can that let accepts list names values, called bindings, it work a single binding. more one expression follow bindings, works do:> (let (x 10 y 20) (print x) (+ x y))1030> (let x 9 (print \"hi\") (let y (+ x 1) y))hi10assignmentvariables list values be updated using set, evaluates the value it updated:> (let x 10 (set x 15))15> (let x 10 (set x 20) (+ x 5))25> (let (list 1 2 3) (set ( a 1) \"b\") )(1 \"b\" 3)> (let (list foo: 17) (set ( a \"foo\") 19) )(foo: 19)conditionalsconditional evaluation is done using if expression. value an expression is of branch whose condition evaluated true:> ( true 10 20)10> ( false 10 20)20> (+ ( false 10 20) 5)25 expressions have number branches:> ( true 10)10> ( false 10)>> ( false 1 false 2 false 3 true 10)10> ( false 1 false 2 false 3 10)10> ( true 9 ( (print 10) 11))9> ( false 9 ( (print 10) 11))1011comparing values is done using = operator:> (= 10 10)true> ( (= 10 10) \"yes\")\"yes\"> ( (= 10 \"\") \"yes\")>lists are values have unique identity, two separate lists happen contain same values are the same:> (= (list 1 2 3) (list 1 2 3))falsefunctionsfunctions lumen are values, like numbers strings. expressions start fn evaluate functions:> (fn () 10)functionfunctions be called placing first a list expression. list appears the name fn identifies function's parameters:> (fn () (+ a 10))function> ((fn () (+ a 10)) 20)30> ((fn () 42))42> ((fn ( b) (+ b)) 10 20)30 functions are values, can variables name . the same rules apply calling function named a variable:> (let f (fn () 42) (f))42> (let plus (fn ( b) (+ b)) (plus 10 20))30 most common shortcut defining functions is use define define-global the following :> (define-global f (n) (* n 10))> (f 3)30> ( (define f (n) (* n 10)) (print (f 3)) (print (f 4)) (f 2.5))304025 function's parameter list contain both positional key parameters, where key's value is name bind:> (let f (fn ( b: -b) (+ my-b)) (f 13 b: 2))15 the key's value is true, same name the key is used bind parameter's value. makes easy define named parameters flags:> (let f (fn ( b: true) (+ b)) (f 1 b: 2))3> (let f (fn ( :b) (+ b)) ; a flag (f 10 b: 20))30parameters lumen are always optional, those without supplied argument the value nil:> (let f (fn () a) (f))>> (let f (fn (:b) ( (= b nil) 10 20)) (f : 99))10functions also a variable number arguments either specifying single parameter instead a list, by using rest key:> (let f (fn xs (last xs)) (f 1 2 3))3> (let f (fn ( rest: ) (+ a (last ))) (f 10 11 12 13))23destructuringvariables be bound values a list certain positions key:> (let (( b c) (list 1 2 3)) b)2> ((fn (( b c)) c) (list 1 2 3))3> (let (( b: -b) (list 1 b: 2)) -b)2> ((fn (( b: -b)) (list my-b)) (list 1 b: 2))(1 2)> (let (( :b) (list 1 b: 2)) b)2 rest key works destructuring it does function parameters, binds remainder the list:> (let (( rest: ) (list 1 2 3)) (list as))(1 (2 3))> (let (( :rest) (list 1 2 3)) (list rest))(1 (2 3))iteration are several iteration mechanisms lumen. simplest is while loop:> (let 3 (while (> 0) (print (dec ))))210 shorthand iterating 0 n is :> (for 3 (print ))012 can enumerate keys values a list each:> (each (k v) (list 1 2 : 10 b: 20) (print (cat k \" \" v)))1 12 2b 20 10> (each v (list 1 2 : 10 b: 20) ; values (print v))122010> (each (k ( b)) ; destructuring (list (list 10 20) bar: (list \"\" \"b\")) (print (cat k \" \" \" \" b)))1 10 20bar beach bind keys values any order. you only positional values a list, can enumerate in order using step:> (step x (list 1 2 3) (print x))123> (step ( b) (list (list 1 2) (list 10 20)) ; destructuring (print ) (print b))121020quotationexpressions be prevented being evaluated using quote operator:> (quote (1 2 3))(1 2 3)expressions evaluate themselves are unaffected quotation:> (quote 10)10> (quote false)falsequoting names strings results strings would evaluate the quoted expression:> (quote )\"a\"> (quote \"hereanother\")\"\\\"hereanother\\\"\"> (quote \"lines\")\"\\\"\\lines\\\"\" is true expressions inside lists:> (quote ( b c))(\"\" \"b\" \"c\")> (quote (1 2 b: baz z: \"frob\"))(1 2 b: \"baz\" z: \"\\\"frob\\\"\") shorthand quotation is a single quote:> '1717> '(1 2 3)(1 2 3)> '( b c)(\"\" \"b\" \"c\")another to write many strings is simply quote name:> '\"a\"> (let x '(: 10 b: 20) ( x '))10 you to quote parts an expression, want parts be evaluated, quasiquote unquote:> (let x 10 (quasiquote (1 5 (unquote x))))(1 5 10) shorthand quasiquotation is ` quasiquote , for unquote:> (let x 10 `(1 5 ,x))(1 5 10) different to unquote expressions is unquote-splicing, takes values contained a nested list places in enclosing :> (let '(1 2 3) (quasiquote (9 8 (unquote-splicing ))))(9 8 1 2 3) shorthand unquote-splicing is ,@:> (let '(1 2 3) `(9 8 ,@))(9 8 1 2 3)macrosmacros allow to write functions manipulate expressions before have been evaluated. macros expressions parameters return expression:> (define-macro (condition rest: body) `( ,condition ( ,@body)))(macro: function)> ( true (print 'hi) (+ 10 20))hi30acknowledgementslumen was conceived designed daniel gackle, many fixes improvements been contributed shawn presser."
}