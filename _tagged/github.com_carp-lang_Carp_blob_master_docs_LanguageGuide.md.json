{
	"_id": "14404708",
	"site": "https://github.com/carp-lang/Carp/blob/master/docs/LanguageGuide.md",
	"title": "Carp â€“ A type inferred Lisp with Rust style memory management",
	"author": "jlturner",
	"date": "2017-06-13T13:56:41.891Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": []
	},
	"content": "languagecarp borrows looks clojure the runtime semantics are much closer those ml rust. here's sample program:(defn -hi (text) (while true ( (< (strlen text) 10) (println \"too short!\") (println text)))) compiles the following c program:void say_hi(string text) { bool while_expr_1 = 1; while(while_expr_1) { int strlen_result_2 = strlen(text); bool if_expr_3 = strlen_result_2 < 10; (if_expr_3) { println(\"too short!\"); } else { println(text); } while_expr_1 = 1; }}-statements are kind tricky regards memory management:(defn -what (text) (let [manage- (string-copy text)] ( (< (strlen text) 10) (string-copy \"too short\") manage-)))the 'manage-' variable is return value the second branch, should freed \"too short\" is returned. output is somewhat noisy (working it!) c program:string say_what(string text) { string _let_result_0; { string _result_0 = string_copy(text); string manage_me = _result_0; int _result_1 = strlen(text); string _if_result_0; (_result_1 < 10) { string _result_2 = string_copy(\"too short\"); free(manage_me); _if_result_0 = _result_2; } else { _if_result_0 = manage_me; } _let_result_0 = _if_result_0; } string _final_result_0 = _let_result_0; return _final_result_0;} most important thing carp is work arrays data. here's example how looks:(defn weird-sum (nums) (reduce + 0 (map inc (filter ? nums)))) the array modification functions 'map', 'filter', etc. c-style mutation the array return same data structure afterwards, allocation deallocation needed. lifetime analyzer (\"borrow checker\" rust parlance) makes sure the same data structure isn't used several places. know whether function takes the responsibility freeing memory (through args) generates new memory the caller has handle (through return value), look the type the (compiled) function. type signature be found (signature ...). the value is simple type :string, :vector3, similar, means the memory ownership gets handed . if 's ref signature, meaning it's list starting :ref (.e. '(:ref :string)'), memory is temporarily lended and someone else make sure gets deleted. interoping existing c code 's probably useful send data structures c refs, keeping memory management inside carp section the program.data literals100 ; int3.14f ; float10.0 ; doubletrue ; bool\"hello\" ; string\\e ; char[1 2 3] ; arraydynamic- data literalsright the following data types are available manipulation non-compiled code.(1 2 3) ; listfoo ; symbol:blergh ; keyword{: 10 :b 20} ; dictionaryspecial forms(def variable-name value)(defn function-name (arg1 arg2 ...) (function-body ...))(let [var1 expr1, var2 expr2, ...] body)( expr1 expr2 ...)( expression true-branch false-branch)(while expression body)(ref x) ;; turns owned value an unowned (reset! variable value)reader macros&x ; same (ref x)@x ; same (copy x)dynamic- special forms(quote x)(match x pattern-1 expr-1, pattern-2 expr-2, ...)structs(defstruct vector2 [x :float, y :float])(def -pos (vector2 102.2f 210.3f));; 'lens' is automatically generated each member:(-x -pos) ;; => 102.2f(set-x -pos 3.0f) ;; => (vector2 10.2f 3.0f)(update-x -pos inc) ;; => (vector2 10.2f 4.0f)structs also contain members one more generic types:(defstruct pair [ \"t\" b \"t\"])(defstruct tuple [ \"a\" b \"b\"])algebraic data types ( implemented)(defdata color rgb [r :float, g :float, b :float] grayscale [amount :float])(def color (grayscale 50.0f))omit name tag create data constructor the same name the type:(defdata vector3 [x :double, y :double, z :double])(def position (vector3 4.0 5.0 -2.0))(def x-position (.x position)c interop(def blah (load-dylib \"./libs/blah.\"))(register blah \"foo\" (:int :int) :string) ;; register function 'foo' the dynamic library 'blah' takes ints returns stringtype annotations should never a need explicit type annotations carp. still, can useful show intent make sure the compiler does thing were planning it do. type annotations are added using meta data ('ann' stands 'annotation') the function form, this:^ann '(:fn ((:ref :ship)) :void)(defn draw-ship [ship] (let [pos (-shippos ship)] (draw-rect (-x pos) (-y pos) 10f 10f)))"
}