{
	"_id": "14390384",
	"site": "https://github.com/vozlt/nginx-module-vts/blob/master/README.md",
	"title": " Nginx virtual host traffic status module â€“ supports html/json output",
	"author": "vozlt",
	"date": "2017-06-13T13:07:23.476Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": []
	},
	"content": "nginx virtual host traffic status modulenginx virtual host traffic status moduletable contentsversiondependenciescompatibilityscreenshotsinstallationsynopsisdescriptioncalculations intervalscontrol get status traffic zones the fly get fully zones get group zones get each zones reset traffic zones the fly reset fully zones reset group zones reset each zones delete traffic zones the fly delete fully zones delete group zones delete each zonessetjsonjson used statusjson used controlvariableslimit limit traffic server limit traffic filter limit traffic upstream cases calculate traffic individual country using geoip calculate traffic individual storage volume calculate traffic individual user agent calculate traffic dynamic dns calculate traffic except status page maintain statistics data permanentlycustomizing customize the module installed customize before module installeddirectivesvhost_traffic_statusvhost_traffic_status_zonevhost_traffic_status_dumpvhost_traffic_status_displayvhost_traffic_status_display_formatvhost_traffic_status_display_jsonpvhost_traffic_status_display_sum_keyvhost_traffic_status_filtervhost_traffic_status_filter_by_hostvhost_traffic_status_filter_by_set_keyvhost_traffic_status_filter_check_duplicatevhost_traffic_status_limitvhost_traffic_status_limit_trafficvhost_traffic_status_limit_traffic_by_set_keyvhost_traffic_status_limit_check_duplicatevhost_traffic_status_set_by_filtervhost_traffic_status_average_methodvhost_traffic_status_bypass_limitvhost_traffic_status_bypass_stats alsotododonationauthorversion document describes nginx-module-vts v0.1.15 released 3 apr 2017.dependenciesnginxcompatibilitynginx1.11.x (last tested: 1.11.10)1.10.x (last tested: 1.10.3)1.8.x (last tested: 1.8.0)1.6.x (last tested: 1.6.3)1.4.x (last tested: 1.4.7)earlier versions is tested.screenshotsinstallationclone git repository.shell> git clone git://github.com/vozlt/nginx-module-vts.gitadd module the build configuration adding--add-module=/path//nginx-module-vtsbuild nginx binary.install nginx binary.synopsishttp { vhost_traffic_status_zone; ... server { ... location /status { vhost_traffic_status_display; vhost_traffic_status_display_format html; } }}description is nginx module provides access virtual host status information. contains current status such servers, upstreams, caches. is similar the live activity monitoring nginx plus. built- html is taken the demo page old version. of , the directive vhost_traffic_status_zone is required, then the directive vhost_traffic_status_display is set, be access as follows:/status/format/json/status/format/html/status/format/jsonp/status/control you request /status/format/json, respond a json document containing current activity data using live dashboards third-party monitoring tools. you request /status/format/html, respond the built- live dashboard html requests internally /status/format/json. you request /status/format/jsonp, respond a jsonp callback function containing current activity data using live dashboards third-party monitoring tools. you request /status/control, respond a json document it reset delete zones through query string. the control.json document contains follows:{ \"hostname\": ..., \"nginxversion\": ..., \"loadmsec\": ..., \"nowmsec\": ..., \"connections\": { \"active\":..., \"reading\":..., \"writing\":..., \"waiting\":..., \"accepted\":..., \"handled\":..., \"requests\":... }, \"sharedzones\": { \"name\":..., \"maxsize\":..., \"usedsize\":..., \"usednode\":... }, \"serverzones\": { \"...\":{ \"requestcounter\":..., \"inbytes\":..., \"outbytes\":..., \"responses\":{ \"1xx\":..., \"2xx\":..., \"3xx\":..., \"4xx\":..., \"5xx\":..., \"miss\":..., \"bypass\":..., \"expired\":..., \"stale\":..., \"updating\":..., \"revalidated\":..., \"hit\":..., \"scarce\":... }, \"requestmsec\":..., \"requestmsecs\":{ \"times\":[...], \"msecs\":[...] }, } ... }, \"filterzones\": { \"...\":{ \"...\":{ \"requestcounter\":..., \"inbytes\":..., \"outbytes\":..., \"responses\":{ \"1xx\":..., \"2xx\":..., \"3xx\":..., \"4xx\":..., \"5xx\":..., \"miss\":..., \"bypass\":..., \"expired\":..., \"stale\":..., \"updating\":..., \"revalidated\":..., \"hit\":..., \"scarce\":... }, \"requestmsec\":..., \"requestmsecs\":{ \"times\":[...], \"msecs\":[...] }, }, ... }, ... }, \"upstreamzones\": { \"...\":[ { \"server\":..., \"requestcounter\":..., \"inbytes\":..., \"outbytes\":..., \"responses\":{ \"1xx\":..., \"2xx\":..., \"3xx\":..., \"4xx\":..., \"5xx\":... }, \"requestmsec\":..., \"requestmsecs\":{ \"times\":[...], \"msecs\":[...] }, \"responsemsec\":..., \"responsemsecs\":{ \"times\":[...], \"msecs\":[...] }, \"weight\":..., \"maxfails\":..., \"failtimeout\":..., \"backup\":..., \"down\":... } ... ], ... } \"cachezones\": { \"...\":{ \"maxsize\":..., \"usedsize\":..., \"inbytes\":..., \"outbytes\":..., \"responses\":{ \"miss\":..., \"bypass\":..., \"expired\":..., \"stale\":..., \"updating\":..., \"revalidated\":..., \"hit\":..., \"scarce\":... } }, ... }}mainbasic version, uptime((nowmsec - loadmsec)/1000)nowmsec, loadmsec is millisecond.connectionstotal connections requests(same stub_status_module nginx)sharedzones shared memory information using nginx-module-vts.serverzonestraffic(/out) request response counts cache hit ratio per each server zonetotal traffic(/out) request response counts( zone name is *) hit ratiofilterzonestraffic(/out) request response counts cache hit ratio per each server zone filtered through vhost_traffic_status_filter_by_set_key directivetotal traffic(/out) request response counts( zone name is *) hit ratio filtered through vhost_traffic_status_filter_by_set_key directiveupstreamzonestraffic(/out) request response counts per server each upstream groupcurrent settings(weight, maxfails, failtimeout...) nginx.confcachezonestraffic(/out) size(capacity/used) hit ratio per each cache zone using proxy_cache directive. directive vhost_traffic_status_display_format sets default ouput format is of json html. (default: json)traffic calculation follows:serverzones += requested_bytes += sent_bytesfilterzones += requested_bytes via filter += sent_bytes via filterupstreamzones += requested_bytes via serverzones += sent_bytes via serverzonescachezones += requested_bytes via serverzones += sent_bytes via serverzones calculations are working log processing phase nginx.internal redirects(x-accel-redirect error_page) does calculate the upstreamzones.caveats: module relies nginx logging system(ngx_http_log_phase:last phase the nginx http), the traffic may in certain cirumstances different real bandwidth traffic.websocket, canceled downloads may cause inaccuracies. working the module doesn't matter all whether access_log directive \"\" or \"off\".again, module works on \"access_log off\". using several domains sets be domain(left) server_name directive. you don't it, the vhost_traffic_status_filter_by_host, vhost_traffic_status_filter_by_set_key directive. the following modules the stream traffic statistics:nginx-module-stsnginx-module-stream-stscalculations intervalsaverages averages are currently calculated amm(arithmetic mean) the last 64 values.control is able reset delete traffic zones through query string. request responds a json document.uri syntax/{status_uri}/control?cmd={command}&group={group}&zone={name}http { geoip_country /usr/share/geoip/geoip.dat; vhost_traffic_status_zone; vhost_traffic_status_filter_by_set_key $geoip_country_code country::*; ... server { server_name example.org; ... vhost_traffic_status_filter_by_set_key $geoip_country_code country::$server_name; location /status { vhost_traffic_status_display; vhost_traffic_status_display_format html; } }} it set above, the control uri is example.org/status/control. available request arguments are follows:cmd=<status|reset|delete>status returns status traffic zones json format status/format/json.reset reset traffic zones without deleting nodes shared memory.(= init 0)delete delete traffic zones shared memory. re-request recreated.group=<server|filter|upstream@alone|upstream@group|cache|*>serverfilterupstream@aloneupstream@groupcache*zone=nameservernamefilterfilter_group@nameupstream@groupupstream_group@nameupstream@alone@namecachename get status traffic zones the fly is similar the status/format/json except it get each zones. get fully zones is exactly same the status/format/json./status/control?cmd=status&group=* get group zonesmainzones/status/control?cmd=status&group=server&zone=::mainserverzones/status/control?cmd=status&group=server&zone=*filterzones/status/control?cmd=status&group=filter&zone=*upstreamzones/status/control?cmd=status&group=upstream@group&zone=*upstreamzones::nogroups/status/control?cmd=status&group=upstream@alone&zone=*cachezones/status/control?cmd=status&group=cache&zone=* mainzones values are default status values including hostname, nginxversion, loadmsec, nowmsec, connections. get each zonessingle zone serverzones/status/control?cmd=status&group=server&zone=namesingle zone filterzones/status/control?cmd=status&group=filter&zone=filter_group@namesingle zone upstreamzones/status/control?cmd=status&group=upstream@group&zone=upstream_group@namesingle zone upstreamzones::nogroups/status/control?cmd=status&group=upstream@alone&zone=namesingle zone cachezones/status/control?cmd=status&group=cache&zone=name reset traffic zones the fly reset values specified zones 0. reset fully zones/status/control?cmd=reset&group=* reset group zonesserverzones/status/control?cmd=reset&group=server&zone=*filterzones/status/control?cmd=reset&group=filter&zone=*upstreamzones/status/control?cmd=reset&group=upstream@group&zone=*upstreamzones::nogroups/status/control?cmd=reset&group=upstream@alone&zone=*cachezones/status/control?cmd=reset&group=cache&zone=* reset each zonessingle zone serverzones/status/control?cmd=reset&group=server&zone=namesingle zone filterzones/status/control?cmd=reset&group=filter&zone=filter_group@namesingle zone upstreamzones/status/control?cmd=reset&group=upstream@group&zone=upstream_group@namesingle zone upstreamzones::nogroups/status/control?cmd=reset&group=upstream@alone&zone=namesingle zone cachezones/status/control?cmd=reset&group=cache&zone=name delete traffic zones the fly delete specified zones shared memory. delete fully zones/status/control?cmd=delete&group=* delete group zonesserverzones/status/control?cmd=delete&group=server&zone=*filterzones/status/control?cmd=delete&group=filter&zone=*upstreamzones/status/control?cmd=delete&group=upstream@group&zone=*upstreamzones::nogroups/status/control?cmd=delete&group=upstream@alone&zone=*cachezones/status/control?cmd=delete&group=cache&zone=* delete each zonessingle zone serverzones/status/control?cmd=delete&group=server&zone=namesingle zone filterzones/status/control?cmd=delete&group=filter&zone=filter_group@namesingle zone upstreamzones/status/control?cmd=delete&group=upstream@group&zone=upstream_group@namesingle zone upstreamzones::nogroups/status/control?cmd=delete&group=upstream@alone&zone=namesingle zone cachezones/status/control?cmd=delete&group=cache&zone=nameset can the status values nginx configuration separately using vhost_traffic_status_set_by_filter directive. can acquire almost status values the obtained value is stored user-defined-variable is argument.directive syntaxvhost_traffic_status_set_by_filter $variable group/zone/namehttp { geoip_country /usr/share/geoip/geoip.dat; vhost_traffic_status_zone; vhost_traffic_status_filter_by_set_key $geoip_country_code country::*; ... upstream backend { 10.10.10.11:80; 10.10.10.12:80; } server { server_name example.org; ... vhost_traffic_status_filter_by_set_key $geoip_country_code country::$server_name; vhost_traffic_status_set_by_filter $requestcounter server/example.org/requestcounter; vhost_traffic_status_set_by_filter $requestcounterkr filter/country::example.org@kr/requestcounter; location /backend { vhost_traffic_status_set_by_filter $requestcounterb1 upstream@group/backend@10.10.10.11:80/requestcounter; proxy_pass http://backend; } }} above settings are follows:$requestcounterserverzones -> example.org -> requestcounter$requestcounterkrfilterzones -> country::example.org -> kr -> requestcounter$requestcounterb1upstreamzones -> backend -> 10.0.10.11:80 -> requestcounterplease the vhost_traffic_status_set_by_filter directive detailed usage.json following status information is provided the json format:json used status/{status_uri}/format/json/{status_uri}/control?cmd=status&...hostnamehost name.nginxversionversion the provided.loadmsecloaded process in milliseconds.nowmseccurrent in millisecondsconnectionsactive current number active client connections.reading total number reading client connections.writing total number writing client connections.waiting total number wating client connections.accepted total number accepted client connections.handled total number handled client connections.requests total number requested client connections.sharedzonesname name shared memory specified the configuration.(default: vhost_traffic_status)maxsize limit the maximum size the shared memory specified the configuration.usedsize current size the shared memory.usednode current number node using shared memory. can an approximate size one node the following formula: (usedsize / usednode)serverzonesrequestcounter total number client requests received clients.inbytes total number bytes received clients.outbytes total number bytes sent clients.responses1xx, 2xx, 3xx, 4xx, 5xx number responses status codes 1xx, 2xx, 3xx, 4xx, 5xx.miss number cache miss.bypass number cache bypass.expired number cache expired.stale number cache stale.updating number cache updating.revalidated number cache revalidated.hit number cache hit.scarce number cache scare.requestmsec average request processing times milliseconds.requestmsecstimes times milliseconds request processing times.msecs request processing times milliseconds.filterzones provides same fields serverzones except it included group names.upstreamzonesserver address the server.requestcounter total number client connections forwarded this server.inbytes total number bytes received this server.outbytes total number bytes sent this server.responses1xx, 2xx, 3xx, 4xx, 5xx number responses status codes 1xx, 2xx, 3xx, 4xx, 5xx.requestmsec average request processing times including upstream milliseconds.requestmsecstimes times milliseconds request processing times.msecs request processing times including upstream milliseconds.responsemsec average only upstream response processing times milliseconds.responsemsecstimes times milliseconds request processing times.msecs only upstream response processing times milliseconds.weightcurrent weight setting the server.maxfailscurrent max_fails setting the server.failtimeoutcurrent fail_timeout setting the server.backupcurrent backup setting the server.downcurrent down setting the server.cachezonesmaxsize limit the maximum size the cache specified the configuration.usedsize current size the cache.inbytes total number bytes received the cache.outbytes total number bytes sent the cache.responsesmiss number cache miss.bypass number cache bypass.expired number cache expired.stale number cache stale.updating number cache updating.revalidated number cache revalidated.hit number cache hit.scarce number cache scare.json used control/{status_uri}/control?cmd=reset&.../{status_uri}/control?cmd=delete&...processingreturn result true false.processingcommandstring requested command string.processinggroupstring requested group string.processingzonestring requested zone string.processingcounts actual processing number.variables following embedded variables are provided:$vts_request_counter total number client requests received clients.$vts_in_bytes total number bytes received clients.$vts_out_bytes total number bytes sent clients.$vts_1xx_counter number responses status codes 1xx.$vts_2xx_counter number responses status codes 2xx.$vts_3xx_counter number responses status codes 3xx.$vts_4xx_counter number responses status codes 4xx.$vts_5xx_counter number responses status codes 5xx.$vts_cache_miss_counter number cache miss.$vts_cache_bypass_counter number cache bypass.$vts_cache_expired_counter number cache expired.$vts_cache_stale_counter number cache stale.$vts_cache_updating_counter number cache updating.$vts_cache_revalidated_counter number cache revalidated.$vts_cache_hit_counter number cache hit.$vts_cache_scarce_counter number cache scare.$vts_request_time average request processing times.limit is able limit total traffic per each host using directivevhost_traffic_status_limit_traffic. also is able limit traffic using directivevhost_traffic_status_limit_traffic_by_set_key. the limit is exceeded, server return 503(service temporarily unavailable) error reply a request. return code be changeable. limit traffic serverhttp { vhost_traffic_status_zone; ... server { server_name *.example.org; vhost_traffic_status_limit_traffic :64g; vhost_traffic_status_limit_traffic :1024g; ... }}limit /out total traffic the *.example.org 64g 1024g respectively. works individually per each domain vhost_traffic_status_filter_by_host directive is enabled. limit traffic filterhttp { geoip_country /usr/share/geoip/geoip.dat; vhost_traffic_status_zone; ... server { server_name example.org; vhost_traffic_status_filter_by_set_key $geoip_country_code country::$server_name; vhost_traffic_status_limit_traffic_by_set_key fg@country::$server_name@ out:1024g; vhost_traffic_status_limit_traffic_by_set_key fg@country::$server_name@cn :2048g; ... }}limit total traffic going us cn the example.org 1024g 2048g respectively. limit traffic upstreamhttp { vhost_traffic_status_zone; ... upstream backend { server 10.10.10.17:80; server 10.10.10.18:80; } server { server_name example.org; location /backend { vhost_traffic_status_limit_traffic_by_set_key ug@backend@10.10.10.17:80 :512g; vhost_traffic_status_limit_traffic_by_set_key ug@backend@10.10.10.18:80 :1024g; proxy_pass http://backend; } ... }}limit total traffic going upstream backend the example.org 512g 1024g per each peer.caveats: traffic is cumulative transfer counter, a bandwidth. cases is able calculate user defined individual stats using directive vhost_traffic_status_filter_by_set_key. calculate traffic individual country using geoiphttp { geoip_country /usr/share/geoip/geoip.dat; vhost_traffic_status_zone; vhost_traffic_status_filter_by_set_key $geoip_country_code country::*; ... server { ... vhost_traffic_status_filter_by_set_key $geoip_country_code country::$server_name; location /status { vhost_traffic_status_display; vhost_traffic_status_display_format html; } }}calculate traffic individual country total server groups.calculate traffic individual country each server groups.basically, country flags image is built- in html. country flags image is enabled the country string is included group name is second argument vhost_traffic_status_filter_by_set_key directive. calculate traffic individual storage volumehttp { vhost_traffic_status_zone; ... server { ... location ~ ^/storage/(.+)/.*$ { set $volume $1; vhost_traffic_status_filter_by_set_key $volume storage::$server_name; } location /status { vhost_traffic_status_display; vhost_traffic_status_display_format html; } }}calculate traffic individual storage volume matched regular expression location directive. calculate traffic individual user agenthttp { vhost_traffic_status_zone; map $http_user_agent $filter_user_agent { default 'unknown'; ~iphone ios; ~android android; ~(msie|mozilla) windows; } vhost_traffic_status_filter_by_set_key $filter_user_agent agent::*; ... server { ... vhost_traffic_status_filter_by_set_key $filter_user_agent agent::$server_name; location /status { vhost_traffic_status_display; vhost_traffic_status_display_format html; } }}calculate traffic individual http_user_agent calculate traffic dynamic dns the domain has multiple dns records, can calculate traffic individual ips the domain using filter feature a variable proxy_pass.http { vhost_traffic_status_zone; upstream backend { elb.example.org:80; } ... server { ... location /backend { vhost_traffic_status_filter_by_set_key $upstream_addr upstream::backend; proxy_pass backend; } }}calculate traffic individual ips the domain elb.example.org. elb.example.org has multiple dns records, be display ips filterzones. the above settings, nginx starts or reloads configuration, queries dns server resolve domain dns records is cached memory.therefore dns records are changed memory ifdns records are chagned dns administrator unless nginx re-starts or reloads.http { vhost_traffic_status_zone; resolver 10.10.10.53 valid=10s ... server { ... location /backend { set $backend_server elb.example.org; proxy_pass http://$backend_server; } }}calculate traffic individual ips the domain elb.example.org. elb.example.org's dns record is changed, be display both old ip the ip ::nogroups.unlike first upstream group setting, second setting works even dns records are chagned dns administrator.caveats: please more details nginx dns thedns-service-discovery-nginx-plus. calculate traffic except status pagehttp { vhost_traffic_status_zone; ... server { ... location /status { vhost_traffic_status_bypass_limit ; vhost_traffic_status_bypass_stats ; vhost_traffic_status_display; vhost_traffic_status_display_format html; } }} /status uri is excluded the status traffic calculation limit feature. the following directives:vhost_traffic_status_bypass_limitvhost_traffic_status_bypass_stats maintain statistics data permanentlyhttp { vhost_traffic_status_zone; vhost_traffic_status_dump /var/log/nginx/vts.db; ... server { ... }} vhost_traffic_status_dump directive maintains statistics data permanently if system has been rebooted nginx has been restarted.please the vhost_traffic_status_dump directive detailed usage.customizing customize the module installed need change {{uri}} string your status uri status.template.html follows:shell> vi share/status.template.htmlvar vtsstatusuri = \"yourstatusuri/format/json\", vtsupdateinterval = 1000; then, customizing copy status.template.html server root directory follows:shell> cp share/status.template.html /usr/share/nginx/html/status.htmlconfigure nginx.conf server { server_name example.org; root /usr/share/nginx/html; # redirect requests / to /status.html location = / { return 301 /status.html; } location = /status.html {} # everything beginning /status (except /status.html) is # processed the status handler location /status { vhost_traffic_status_display; vhost_traffic_status_display_format json; } }access your html.http://example.org/status.html customize before module installedmodify share/status.template.html ( not change {{uri}} string)recreate ngx_http_vhost_traffic_status_module_html.h follows:shell> cd utilshell> ./tpltodefine.sh ../share/status.template.html > ../src/ngx_http_vhost_traffic_status_module_html.hadd module the build configuration adding--add-module=/path//nginx-module-vtsbuild nginx binary.install nginx binary.directivesvhost_traffic_status--syntaxvhost_traffic_status <|off>defaultoffcontexthttp, server, locationdescription: enables disables module working. you set vhost_traffic_status_zone directive, is automatically enabled.vhost_traffic_status_zone--syntaxvhost_traffic_status_zone [shared:name:size]defaultshared:vhost_traffic_status:1mcontexthttpdescription: sets parameters a shared memory zone will keep states various keys. cache is shared between worker processes.vhost_traffic_status_dump--syntaxvhost_traffic_status_dump path [period]default-contexthttpdescription: enables statistics data dump restore. path is location dump statistics data.(e.g. /var/log/nginx/vts.db) period is backup cycle .(default: 60s) is backed immediately regardless the backup cycle nginx is exited signal(sigkill).vhost_traffic_status_display--syntaxvhost_traffic_status_displaydefault-contexthttp, server, locationdescription: enables disables module display handler.vhost_traffic_status_display_format--syntaxvhost_traffic_status_display_format <json|html|jsonp>defaultjsoncontexthttp, server, locationdescription: sets display handler's output format. you set json, respond a json document. you set html, respond the built- live dashboard html. you set jsonp, respond a jsonp callback function(default: ngx_http_vhost_traffic_status_jsonp_callback).vhost_traffic_status_display_jsonp--syntaxvhost_traffic_status_display_jsonp callbackdefaultngx_http_vhost_traffic_status_jsonp_callbackcontexthttp, server, locationdescription: sets callback name the jsonp.vhost_traffic_status_display_sum_key--syntaxvhost_traffic_status_display_sum_key namedefault*contexthttp, server, locationdescription: sets sum key string serverzones field's json. default sum key string is \"*\".vhost_traffic_status_filter--syntaxvhost_traffic_status_filter <|off>defaultcontexthttp, server, locationdescription: enables disables filter features.vhost_traffic_status_filter_by_host--syntaxvhost_traffic_status_filter_by_host <|off>defaultoffcontexthttp, server, locationdescription: enables disables keys host header field. you set and nginx's server_name directive set several wildcard name starting an asterisk, e.g. *.example.org requested server hostname such (a|b|c).example.org *.example.org json serverzones is printed follows:server { server_name *.example.org; vhost_traffic_status_filter_by_host ; ...} ... \"serverzones\": { \".example.org\": { ... }, \"b.example.org\": { ... }, \"c.example.org\": { ... } ... }, ... provides same function set vhost_traffic_status_filter_by_set_key $host.vhost_traffic_status_filter_by_set_key--syntaxvhost_traffic_status_filter_by_set_key key [name]default-contexthttp, server, locationdescription: enables keys user defined variable. key is key string calculate traffic. name is group string calculate traffic. key name contain variables such $host, $server_name. name's group belongs filterzones specified. key's group belongs serverzones not specified second argument name. example geoip module is follows:server { server_name example.org; vhost_traffic_status_filter_by_set_key $geoip_country_code country::$server_name; ...} ... \"serverzones\": { ... }, \"filterzones\": { \"country::example.org\": { \"kr\": { \"requestcounter\":..., \"inbytes\":..., \"outbytes\":..., \"responses\":{ \"1xx\":..., \"2xx\":..., \"3xx\":..., \"4xx\":..., \"5xx\":..., \"miss\":..., \"bypass\":..., \"expired\":..., \"stale\":..., \"updating\":..., \"revalidated\":..., \"hit\":..., \"scarce\":... }, \"requestmsec\":... }, \"\": { ... }, ... }, ... }, ...vhost_traffic_status_filter_check_duplicate--syntaxvhost_traffic_status_filter_check_duplicate <|off>defaultcontexthttp, server, locationdescription: enables disables deduplication vhost_traffic_status_filter_by_set_key. is processed one duplicate values(key + name) each directives(http, server, location) this option is enabled.vhost_traffic_status_limit--syntaxvhost_traffic_status_limit <|off>defaultcontexthttp, server, locationdescription: enables disables limit features.vhost_traffic_status_limit_traffic--syntaxvhost_traffic_status_limit_traffic member:size [code]default-contexthttp, server, locationdescription: enables traffic limit specified member. member is member string limit traffic. size is size(k/m/g) limit traffic. code is code return response rejected requests.(default: 503) available member strings are follows:request total number client requests received clients.the total number bytes received clients.the total number bytes sent clients.1xx number responses status codes 1xx.2xx number responses status codes 2xx.3xx number responses status codes 3xx.4xx number responses status codes 4xx.5xx number responses status codes 5xx.cache_miss number cache miss.cache_bypass number cache bypass.cache_expired number cache expired.cache_stale number cache stale.cache_updating number cache updating.cache_revalidated number cache revalidated.cache_hit number cache hit.cache_scarce number cache scare.vhost_traffic_status_limit_traffic_by_set_key--syntaxvhost_traffic_status_limit_traffic_by_set_key key member:size [code]default-contexthttp, server, locationdescription: enables traffic limit specified key member. key is key string limit traffic. member is member string limit traffic. size is size(k/m/g) limit traffic. code is code return response rejected requests.(default: 503) key syntax is follows:group@[subgroup@]name available group strings are follows:the group server.ua group upstream alone.ug group upstream group.( subgroup)cc group cache.fg group filter.( subgroup) available member strings are follows:request total number client requests received clients.the total number bytes received clients.the total number bytes sent clients.1xx number responses status codes 1xx.2xx number responses status codes 2xx.3xx number responses status codes 3xx.4xx number responses status codes 4xx.5xx number responses status codes 5xx.cache_miss number cache miss.cache_bypass number cache bypass.cache_expired number cache expired.cache_stale number cache stale.cache_updating number cache updating.cache_revalidated number cache revalidated.cache_hit number cache hit.cache_scarce number cache scare. member is same vhost_traffic_status_limit_traffic directive.vhost_traffic_status_limit_check_duplicate--syntaxvhost_traffic_status_limit_check_duplicate <|off>defaultcontexthttp, server, locationdescription: enables disables deduplication vhost_traffic_status_limit_by_set_key. is processed one duplicate values(member | key + member) each directives(http, server, location) this option is enabled.vhost_traffic_status_set_by_filter--syntaxvhost_traffic_status_set_by_filter $variable group/zone/namedefault-contexthttp, server, location, description: the specified status value stored shared memory. can acquire almost status values the obtained value is stored $variable is argument.groupserverfilterupstream@aloneupstream@groupcachezoneservernamefilterfilter_group@nameupstream@groupupstream_group@nameupstream@alone@namecachenamenamerequestcounter total number client requests received clients.requestmsec average request processing times milliseconds.responsemsec average only upstream response processing times milliseconds.inbytes total number bytes received clients.outbytes total number bytes sent clients.1xx, 2xx, 3xx, 4xx, 5xx number responses status codes 1xx, 2xx, 3xx, 4xx, 5xx.cachemaxsize limit the maximum size the cache specified the configuration.cacheusedsize current size the cache.cachemiss number cache miss.cachebypass number cache bypass.cacheexpired number cache expired.cachestale number cache stale.cacheupdating number cache updating.cacherevalidated number cache revalidated.cachehit number cache hit.cachescarce number cache scare.weightcurrent weight setting the server.maxfailscurrent max_fails setting the server.failtimeoutcurrent fail_timeout setting the server.backupcurrent backup setting the server.(0|1)downcurrent down setting the server.(0|1)caveats: name is case sensitive. return values the integer type. examples:requestcounter serverzonesvhost_traffic_status_set_by_filter $requestcounter server/example.org/requestcounterrequestcounter filterzonesvhost_traffic_status_set_by_filter $requestcounter filter/country::example.org@kr/requestcounterrequestcounter upstreamzonesvhost_traffic_status_set_by_filter $requestcounter upstream@group/backend@10.10.10.11:80/requestcounterrequestcounter upstreamzones::nogroupsvhost_traffic_status_set_by_filter $requestcounter upstream@alone/10.10.10.11:80/requestcountercachehit cachezonesvhost_traffic_status_set_by_filter $cachehit cache/my_cache_name/cachehitvhost_traffic_status_average_method--syntaxvhost_traffic_status_average_method <amm|wma> [period]defaultamm 60scontexthttp, server, locationdescription: sets method is formula calculate average response processing times. period is effective of values used the average calculation.(default: 60s) period set 0, effective is ignored. this case, last average value is displayed if is reqeusts after elapse time. corresponding values are requestmsec responsemsec json.amm amm is arithmetic mean.wma wma is weighted moving average.vhost_traffic_status_bypass_limit--syntaxvhost_traffic_status_bypass_limit <|off>defaultoffcontexthttp, server, locationdescription: enables disables bypass vhost_traffic_status_limit directives. limit features is bypassed this option is enabled. is mostly useful you to connect status web page /status regardless vhost_traffic_status_limit directives follows:http { vhost_traffic_status_zone; ... server { ... location /status { vhost_traffic_status_bypass_limit ; vhost_traffic_status_display; vhost_traffic_status_display_format html; } }}vhost_traffic_status_bypass_stats--syntaxvhost_traffic_status_bypass_stats <|off>defaultoffcontexthttp, server, locationdescription: enables disables bypass vhost_traffic_status. traffic status stats features is bypassed this option is enabled. other words, is excluded the traffic status stats. is mostly useful you to ignore request status web page /status follows:http { vhost_traffic_status_zone; ... server { ... location /status { vhost_traffic_status_bypass_stats ; vhost_traffic_status_display; vhost_traffic_status_display_format html; } }} alsostream traffic statusnginx-module-stsnginx-module-stream-stsprometheusnginx-vts-exportersystem protectionnginx-module-sysguardtodoadd support implementing data restore.donationauthoryoungjoo.kim() [vozltx@gmail.com]"
}