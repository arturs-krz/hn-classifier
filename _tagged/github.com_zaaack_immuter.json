{
	"_id": "14450655",
	"site": "https://github.com/zaaack/immuter",
	"title": "Immuter: A new way to update deeply nested immutable state in react/redux",
	"author": "zaaack",
	"date": "2017-06-13T13:55:21.485Z",
	"tags": {
		"categories": [
			"opensource",
			"immutable",
			"dot-prop",
			"seamless-immutable",
			"react",
			"redux"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md immuter immutable react/redux state update helper, easily handle nested state object less code. whyfacebook's immutable.js is too heavy, seamless-immutable is lite simple, backwards-compatible normal arrays objects. the to update is friendly enough me, have write too much code updating state. also tried something dot-prop-immutable, object-path-immutable, timm, updeep, update-immutable, etc. all are , but neither them's dx is enough me, i create one based all benefits these.installnpm immuter# yarn add immuterdemosimpleimport immuter 'immuter'// import { bindobj, bincomp, , set, update, del } 'immuter'const book = { title: { zh: '·', en: 'harry potter the philosopher\\'s stone', }, author: 'j. k. rowling', tags: ['novel', 'magic'],}let titleenlet booklitelet newbook = book// the english titletitleen = immuter.(book, 'title.en')// titleen = immuter.(book, ['title', 'en'])// return: harry potter the philosopher\\'s stone// multiple booklite = immuter.(book, { 'title': 'title.en', 'author': 'author',}, { 'type': 'book',})// return {// title: 'harry potter the philosopher\\'s stone',// author: 'j. k. rowling',// type: 'book'// }// set english titlenewbook = immuter.set(newbook, 'title.zh', '!')// newbook = immuter.set(newbook, ['title', 'en'], ' title!')// return: {// title: {// zh: '!',// en: ' title!',// },// author: 'j. k. rowling',// tags: ['novel', 'magic'],// }// set array itemnewbook = immuter.set(newbook, 'tags[0]', ' tag')// update array, update is almost the set, except value is function update value,// note function should pure!newbook = immuter.update(book, 'tags', tags => tags.concat(['uk']))// return: {// title: {// zh: '!',// en: ' title!',// },// author: 'j. k. rowling',// tags: [' tag', 'magic', 'uk'],// }// multiple setnewbook = immuter.set(newbook, { 'title.en': ' title!', 'author': ' author!'})// multiple updatenewbook = immuter.update(newbook, { 'title.en': title => title + ' (original edition)', 'author': author => author.touppercase(), 'tags': tags => tags.concat(['uk']),})// multiple deletenewbook = immuter.delete(newbook, { 'title.zh': true, // would removed 'author': false, // won't 'tags': false, // won't, too})advancebindobjimport immuter 'immuter'const book = { title: { zh: '·', en: 'harry potter the philosopher\\'s stone', }, author: 'j. k. rowling', tags: ['novel', 'magic'],}let newbook = bookconst immubook = immuter.bindobj(newbook)const titleen = immubook.('title.en')newbook = immubook.set('title.en', ' title!')immubook.set('author', 'j.k')newbook = immubook.getobj()bindcompusing bindcomp decorator bind react component, flowtype.import { component } 'react'import immuter 'immuter'import type { immuterget, immuterset, immuterupdate, immuterdel } 'immuter'type state = { title: { zh: string, en: string, }, author: string, tags: array<string>,}@immuter.bindcomp()class compa extends component { : immuterget<state> set: immuterset<state> update: immuterupdate<state> del: immuterdel<state> delete: immuterdel<state> state: state = { title: { zh: '·', en: 'harry potter the philosopher\\'s stone', }, author: 'j. k. rowling', tags: ['novel', 'magic'], } componentdidmount() { .update('title.en', title => title + ' (original edition)') .((state) => { // what want setstate callback }) }}apiimmuter.: <t: object>(obj: t, string | array, defaults: ) => any a deep property dot path array pathnote: wouldn't deep clone result performance issues, make sure your modify operations are using immuter :).immuter.<t: object>(obj: t, path: { [string]: string | array }, defaults: { [string]: }) => { [string]: }get deep properties an object custom key.immuter.set<t: object>(obj: t, string | array, value: ) => tset deep property dot path array pathimmuter.set<t: object>(obj: t, pathvaluemap: { [string | array]: }) => tset deep properties an object path keyimmuter.update<t: object>(obj: t, string | array, updater: (val: ) => any) => tmostly set, except passing function update valueimmuter.update<t: object>(obj: t, pathupdatermap: { [string | array]: (val: ) => any }) => tmulti update an path: updater mapimmuter.bindobj<t: object>(obj: t, chain: boolean = false): immuterwrapper function return immuterwrapper instance all functions above it's methods, bind obj inside, you don't need pass obj.chain: default false, modify method return modified object directly, otherwise return for chained calls.immuter.bindcomp<t: object>(ns: string | boolean=false, includes?: ?array, excludes: array = ['bindobj', 'bindcomp']) function bind immuter functions react component instance, can , set, delete update component state directly instance method , set, delete update.ns: whether using namespace, defaults is false, means immuter functions mount component instance, can call .get('title.en'), .set('title.en', ' title'), etc. your component. using special object mount, e.g ns='immter', you should call this: .get('title.en'), .set('title.en', ' title')includes: array include methods, defaults is .excludes: array exclude methods, defaults is ['bindobj', 'bindcomp']. methods auto update state this.setstate, you need using setstate's callback feature, don't worry, modify methods return promise, you even using async/await it!exported flow types bindcompexport type immuterget = (path: getpath, defaults: *) => *export type immuterset = <state>(path: setpath, value: *) => stateexport type immuterupdate = <state>(path: updatepath, fn?: updater) => stateexport type immuterdel = <state>(path: delpath) => statelicence mit"
}