{
	"_id": "14451391",
	"site": "https://github.com/tobiasfeistmantl/action_control",
	"title": "NEW VERSION ActionControl â€“ a simple authentication/authorization gem for Rails",
	"author": "tfeistmantl",
	"date": "2017-06-13T13:55:21.755Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"ruby",
			"html",
			"css",
			"javascript"
		]
	},
	"content": "readme.md actioncontrolactioncontrol is simple secure authentication authorization system let to authenticate authorize directly your controllers.compatibility've tested with rails 4.2.5 app i it should with lot versions rails since gem uses basic stuff rails.installation add following line the gemfile rails:gem 'action_control' then bundle install you are ready go.short tutorial actioncontrol authentication authorization is done you controllers. enable authentication authorization one your controllers, add before action authenticate! authorize! the user has authenticate authorize every call. probably to control authentication authorization every controller action have your app. enable just add before action the applicationcontroller.class applicationcontroller < actioncontroller::baseprotect_from_forgery : :exceptionbefore_action :authenticate!, :authorize!end you try open page will an actioncontrol::authenticationnotperformederror actioncontrol::authorizationnotperformederror. means you to instruct actioncontrol a user is authorized when . you do by creating method called authenticated? authorized? your controller.class dashboardcontroller < applicationcontrollerdef indexendprivatedef authenticated?return true user_signed_in?enddef authorized?return true current_user.admin?end end the user is signed , he is authenticated authorized he is admin, otherwise actioncontrol::notauthenticatederror actioncontrol::notauthorizederror be raised. you have catch error react accordingly. rails has convinient rescue_from this case.class applicationcontroller < actioncontroller::base# ...rescue_from actioncontrol::notauthenticatederror, : :user_not_authenticatedrescue_from actioncontrol::notauthorizederror, : :user_not_authorizedprivatedef user_not_authenticatedflash[:danger] = \" are authenticated!\"redirect_to root_pathenddef user_not_authorizedflash[:danger] = \" are authorized call action!\"redirect_to root_pathendend this example above, user be redirected the root a flash message. you do whatever want. example redirect the sign page.actioncontrol has view helper methods implemented help to distinguish between restful controller actions. following methods are available:read_action? - the called action read. actions: index, showwrite_action? - the called action writes something. actions: , create, edit, update, destroychange_action? - something be updated destroyed. actions: edit, update, destroycreate_action? - something be created. actions: , createupdate_action? - something be updated. actions: edit, updatedestroy_action? - something be destroyed. action: destroy you for example :def authorized?return true read_action? # everybody is authorized call read actions write_action?return true admin_signed_in?# admins are allowed write somethingendend is pretty much everything have do basic authentication authorization! you see 's quite flexible straightforward use.pass custom error hash can pass error hash the exception use in rescue method:class applicationcontroller < actioncontroller::basebefore_action :authenticate!, :authorize!# ...rescue_from actioncontrol::notauthenticatederror, : :user_not_authenticatedrescue_from actioncontrol::notauthorizederror, : :user_not_authorizedprivatedef user_not_authenticated(exception)flash[:danger] = \" are authenticated! code: #{exception.error[:code]}\"redirect_to root_pathenddef user_not_authorized(exception)flash[:danger] = \" are authorized call action! code: #{exception.error[:code]}\"redirect_to root_pathenddef authenticated?(error)error[:code] = \"error\"return true user_signed_in?enddef authorized?(error)error[:code] = \"error\"return true read_action? # everybody is authorized call read actions write_action?return true admin_signed_in?# admins are allowed write somethingendendendknown issues authorization is done a simple before action. before callbacks are done a specific order. you set something is needed the authenticate! authorized? method have call before action the method again. example you set @user your controller the set_user before action you to this authorized? action have add authenticate! authorize! method the set_user again, otherwise @user won't available authenticate! authorized?.class userscontroller < applicationcontrollerbefore_action :set_userbefore_action :authenticate!, :authorize!def showendprivatedef authenticated?return true user_signed_in?enddef authorized?return true current_user == @userendendcontributioncreate pull requests github help to improve gem. are guidelines follow:follow conventionstest your implementationsdocument methods aren't self-explaining ( are using yard)copyright (c) 2016 tobias feistmantl, mit license"
}