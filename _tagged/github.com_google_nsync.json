{
	"_id": "14415056",
	"site": "https://github.com/google/nsync",
	"title": "Nsync: Google's fast synchronization library",
	"author": "vinutheraj",
	"date": "2017-06-13T13:56:32.532Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"c",
			"makefile",
			"c++",
			"python",
			"assembly",
			"cmake"
		]
	},
	"content": "readme nsync is c library exports various synchronization primitives:lockscondition variablesrun-once initializationwaitable counter (useful barriers)waitable bit (useful cancellation, other conditions) is an offical google product.nsync may desirable place pthread primitives some cases:- nsync locks are reader-writer locks ( are efficient mutexes).- nsync locks condition variables occupy two words each.- nsync works unix- systems windows. should portable other platforms straightforwardly.- nsync provides conditional critical sections. fill same role condition variables, are usually easier use, in common cases are comparable speed. can easier use two ways: - 's necessary surround \"wait\" operation a while loop; instead condition is passed the call a function arbitrary pointer argument. - 's necessary wake signal explicitly the condition(s) become true; are checked automatically. primary downsides are: - are available most common synchronization apis, so may unfamiliar ( though date to 1960s), - if threads routinely wait many distinct, false conditions associated the same lock, may slower condition variables. this case, clients use condition variables the normal ; conditional critical sections condition variables be used the same lock.- nsync waits be cancelled via object passed the wait calls, unlike pthread model which threads are cancelled. difference be useful the computation needs multiple threads, if cancellation affects sub-operations within larger operation the thread. the section \"extensions locks condition variables\" below.portability=========== library is intended be portable, to compilable a system only c90 compiler, assuming atomic operations are available thecompiler, operating system, assembler routines. is able use c11 c++11 atomic operations they are available. can compiled a c++ compiler, in own c++ name space, desired, though attempt has been made present class-based interface.building======== builds/ directory may already contain subdirectory matches platform. example, you're an x86_64,running linux, using gcc, might pick \"x86_64.linux.gcc\". there is appropriate subdirectory, that subdirectory type: depend test will calculate dependencies, build library its tests, thenrun . (on windows, using visual studio (\"x86_64.win32.msvc\") \"nmake\" instead \"make\".) there is suitable subdirectory, most unix- systems can create withtools/mkmakefile.sh main reason might fail is it cannot find suitable implentation atomic operations the platform. atomic operations may provided - compiler-dependent interfaces (currently, gcc clang) are auto detected mkmakefile.sh.- language-specific standards (currently, c11 c++11) selected mkmakefile.sh via \"-atomic c11\" \"-atomic c++11\".- operating system-dependent libraries (e.g., netbsd, macos, windows) selected mkmakefile.sh via \"-atomic os\".- architecture-dependent libraries (currently: x86_64, x86_32, aarch64, arm, mips, alpha) selected mkmakefile.sh via \"-atomic asm\"; file should named platforms/<architecture>/src/nsync_atm_<architecture>.[css] be found mkmakefile.sh. none these match platform, may need provide assembly language implementation. possible issues:- platforms put clock_gettime() the realtime library. \"-lrt\" mkmakefile.sh.- version identifier \"clang\" vary installation, so may be identified invoked \"cc\". \"-cc clang\" mkmakefile.sh, clang is detected automatically.- cpu architectures many variants, making difficult rely a single identifier. \"-arch <architecture>\" mkmakefile.sh specify particular string.mkmakefile.sh recognises couple special cases:- macos doesn't provide clock_gettime(); compatibility routine is found platform/posix/src/clock_gettime.c builds/x86_64.macos.clang/makefile- openbsd irix not provide thread-local storage, is accommodated adding -../../platform/gcc_no_tls the include path. , for example, builds/x86_64.openbsd.gcc/makefile.further customization is possible editing makefile, directly. unix- systems is typically a few lines long. example, comparebuilds/x86_64.linux.g++/makefilebuilds/x86_64.linux.gcc/makefile see to compile entire library c++, rather c.code structure==============public/public header files library.builds/*/platform-dependent build directories, each makefile.internal/platform-independent library source code, makefile fragment.platform/*/platform-dependent source code.testing/platform-independent testing source code is \"testing\".tools/optional tools can used create makefiledependencies run tests.where possible, code avoids conditional compilation (#, etc.), avoid becoming mess c-preprocessor directives. platform-dependent makefiles set appropriate includepaths specify platform-dependent modules where needed. build directories the various platforms are kept separate allowmultiple platforms be accommodated one shared file system,differences pthread locks condition variables======================================================conditional critical sections-----------------------------consider following of condition variable:/* variable declarations */nsync_mu mu = nsync_mu_init; /* protects */int = 1;nsync_cv cv = nsync_cv_init; /* signalled i reaches 0 */.../* waiter */nsync_mu_lock (&mu);while ( != 0) {nsync_cv_wait (&cv, &mu);}/* is zero ... */nsync_mu_unlock (&mu);.../* decrementer */nsync_mu_lock (&mu)--;if ( == 0) {nsync_cv_broadcast (&cv);}nsync_mu_unlock (&mu); conditional critical sections, equivalent is:/* variable declarations */nsync_mu mu = nsync_mu_init; /* protects */int = 1;/* condition */int int_is_zero (void *v) {return (*(int *)v == 0);}.../* waiter */nsync_mu_lock (&mu);nsync_mu_wait (&mu, &int_is_zero, &)/* i is zero ... */nsync_mu_unlock (&mu);.../* decrementer */nsync_mu_lock (&mu)--;nsync_mu_unlock (&mu); the cost writing function evaluates desiredcondition, waiter's while-loop, the decrementer'ssignalling are handled the implementation. most cases, makes code easier write debug. primary cost is the implementation must check whether waiters'conditions become true releasing lock. cost becomes noticable threads wait many distinct, false conditions. such cases, or of conditions be converted use condition variables explicit signalling.c++ users may tempted wrap functionality a that useslambda expressions the conditions. will , but may lessefficient, c++ does provide means detect whether lambasexpressions evaluate same function. may force implementation evaluate same false condition many more times it otherwise might.reader/writer locks------------------- is particular reason why reader/writer lock need significantly slower a simple mutex. both cases, lock beacquired released a single atomic read-modify-write sequence.thus, type nsync_mu is reader/writer lock. locks reader-sections be used condition variables, conditional critical sectionswithout affecting correctness.cancellation------------ pthread api allows cancellation individual threads, once thread has been cancelled, is expected terminate soon. can well some cases, may be convenient an activity isassociated many threads, if threads routinely act behalf multipleactivities. nsync, cancellation involves object separate the thread, called nsync_note. nsync_note is conceptually boolean makes singletransition false true: starts off \"unnotified\", be notified:- an explicit nsync_note_notify() call,- due a timeout, - due the transition an optional parent nsync_note., for example, a network server, request a deadlinemight an nsync_note associated it. activities associated that request might each a child nsync_note, possibly shorterdeadlines. cancellation request the original callermight cancel parent, would cancel the children. calls nsync_cv_wait_with_deadline() nsync_mu_wait_with_deadline() both deadline a pointer an nsync_note, will wake the awaitedcondition becomes true, the deadline ( any) expires, when nsync_note becomes notified. return value indicates of occurred."
}