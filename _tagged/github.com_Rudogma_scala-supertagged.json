{
	"_id": "14490148",
	"site": "https://github.com/Rudogma/scala-supertagged",
	"title": " Better (multi-nested-)tagged types for Scala",
	"author": "folex",
	"date": "2017-06-13T13:04:45.075Z",
	"tags": {
		"categories": [
			"opensource",
			"scala",
			"tagged",
			"tagged-types",
			"scalajs",
			"type-tagging",
			"newtype",
			"types",
			"tagging"
		],
		"languages": [
			"scala"
		]
	},
	"content": "readme.md supertagged scalabetter (multi-nested-)tagged types scala, intellij idea autocomplete features working pretty fine.zero-dependcy 1 file, tests included.sbtscala: 2.11.11, 2.12.1, 2.12.2librarydependencies += \"org.rudogma\" %% \"supertagged\" % \"1.1\"scalajs (compiled 0.6.16)librarydependencies += \"org.rudogma\" %%% \"supertagged\" % \"1.1\"usagecheck tests all examplesclassic original idea miles sabin.similar implementations are available shapeless scalaz.import supertagged.@@sealed trait widthval value = @@[width](5) // value is `int @@ width` wayconceptsoriginal idea use base trait + companion type is alexander semenov https://github.com/treev-io/tagged-types/object width extends taggedtype[int]type width = width.typeunified syntax@@ - adds more tag existing tags ( no tags adds )!@@ - replaces existing tags 1 (if tags adds )untag - removing concrete tagauto tagging any nested level matter many levels, will stop automatically appropriate (top level, middle tail nested) ( fail u used inappropriate types)widths @@ ( width @@ array(array(array(array(array(1,2,3)))))) // result: `array_5lvl_ofwidth: array[array[array[array[array[int @@ width] @@ widths]]]]]`taggingfilewithmodels.scalaimport supertagged.taggedtypeobject width extends taggedtype[int]type width = width.typeobject widths extends taggedtype[array[width]]type widths = widths.type// boundeddef offsets[t] = taggedtype[array[t]]type offsets[t] = taggedtype[t]#typeprogram.scala// don't need import from supertagged use defined tagsimport filewithmodels._// u use defined type `width` without boilerplate `int @@ width`.// all methods waiting raw int are applicable any tagged value based int,// method `width:width` deny raw intdef methodraw(width:int):unit = {}def method(width:width):unit = {}val width = width @@ 5 // width(5). result: `width:int @@ width`//tagged values not loose raw typesmethodraw(width)method(width)val arrayofwidth = width @@ array(1,2,3) // result: `arrayofwidth: array[int @@ width]`// matter many levels, will stop automatically appropriate ( fail no)val array_5lvl_ofwidth = width @@ array(array(array(array(array(1,2,3))))) // result: `array_5lvl_ofwidth: array[array[array[array[array[int @@ width]`// `widths @@ array(1,2,3)` - fail compile, widths is `taggedtype[array[width]]` we try tag `array[int]`val widths = widths @@ arrayofwidth // widths @@ (width @@ array(array(array(1,2,3)))) // result: `widths: array[array[array[int @@ width] @@ widths]]`// containers f[_]val anycontainers = width @@ list(array(list(array(1,2,3)))) // result: `anycontainers: list[array[list[array[int @@ width]]]]`// bounded && plain. combine allval offsetsint = offsets[width] @@ (width @@ array(1,2,3)) // result: `array[int @@ width] @@ offsets[width]`def testoffsets(offsets:offsets[width]):unit = {}// methods one name? add dummyimplicit( imports required) compiler do restdef testoffsets(offsets:offsets[height])(implicit d:dummyimplicit):unit = {}multitaggingval value = width @@ (height @@ 5)) // result: `int @@ (height width)`takewidth(value)takeheight(value)def takewidth(width:width):unit = {}def takeheight(height:height):unit = {}val nested = width @@ (height @@ array(array(array(5)))) // result: `array[array[array[int @@ (height width)]]]`postfix syntax//required postfix syntax!import supertagged._value @@ widthvalue !@@ widthvalue untag widthimplicit serializer casepreparingtrait serializer[t] { def serialize(t: t): string}def serialize[t](t: t)(implicit serializer: serializer[t]): string = serializer.serialize(t)implicit val longserializer: serializer[long] = serializer[long] {def serialize(t: long): string = \"long number: \" + t}trait useridexample 1:import supertagged._implicit val lifter = lifterf[serializer] // `import supertagged._` + `implicit val lifter` auto lift serializer[t] serializer[t @@ whattagimplicitneeds]val longnumber = 30lval id = tag[userid](longnumber)serialize(id) // `val longserializer:serializer[long]` be lifted `serializer[long @@ userid]`example 2:import supertagged.liftanyf // lift f[t] f[t @@ whattagimplicitneeds] neededval longnumber = 30lval id = tag[userid](longnumber)serialize(id)orderingsince taggedtype[t] already contains implicit def ordering[u](implicit origin:ordering[t]):ordering[t @@ u] = cast(origin), is need import anything. implicit ordering[raw] be used implicitly sorting tagged raw @@ taggedtype[raw].tag.import models.counterval arr = counter @@ array(3,10,1,2,11)val arrsorted = arr.sortedarrsorted.mkstring(\",\") shouldbe \"1,2,3,10,11\" // okspecific scalac bug /** * very attentive */ { //scalac bug is here. doesn't compile - it is bug illtyped(\"\"\"test(counter @@ array(1,2,3))\"\"\",\"polymorphic expression cannot instantiated expected type;.+\") illtyped(\"\"\"test(counters @@ (counter @@ array(1,2,3)))\"\"\",\"polymorphic expression cannot instantiated expected type;.+\") } { // can overcome using outer variable val v = counter @@ array(1,2,3) test(v) shouldbe 1 } { // adding more tag parameter test2(counters @@ (counter @@ array(1,2,3))) shouldbe 1 } /** * note: change list adding inline conversion, tagging nested array( outer collection is array) - everything compiles ok. */ { testlist(counter @@ list(1,2,3)) shouldbe 1 test( (counter @@ list(1,2,3)).toarray ) shouldbe 1 testnested( counter @@ list(array(1,2,3))) shouldbe 1 } } object counter extends taggedtype[int] type counter = counter.type object counters extends taggedtype[array[counter]] type counters = counters.type def test(counters:array[counter]):counter = counters.head def test2(counters:counters):counter = counters.head def testnested(counters:list[array[counter]]):counter = counters.head.head //(0) // 'jvm feature block' def testlist(counters:list[counter]):counter = counters.head"
}