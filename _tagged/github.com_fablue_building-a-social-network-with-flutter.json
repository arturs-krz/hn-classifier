{
	"_id": "14426485",
	"site": "https://github.com/fablue/building-a-social-network-with-flutter",
	"title": "Building a social network with flutter",
	"author": "grey-area",
	"date": "2017-06-13T13:56:32.509Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"shell"
		]
	},
	"content": "readme.md i built social network instagram a few lines code using flutter why fell love it advance: feel free ask any kind flutter related questions! open issue i wanted build why tried flutter of last i had very fun building own little social network called lime. far can post images text messages lime, posts \"like\" comment/chat them. clue: messages are tightly bound the location where was posted. means are able see posts have been created a maximum radius 30km. here is it currently looks :gif: lime native android appscreenshot: lime native android app the app had big problem: didn't develop ios version( far)! because do own apple computer nor i own iphone decided look any coolframework would allow to develop lime both platforms. way would able build debug on linux machine my android smartphone, sounded great me .since am great fan dart a programming language, found flutter. hell: remember seeing first codeexample a layout immediately leaving website shaking head. visited the , well known, frameworks xamarin, reactnative nativescript those are great frameworks nothing catch entirely. the end cloned flutter, gave a chance reading docs tried building first layouts quickly fell love it why did try flutter my impression wasn't great all? there are many reasons: of i dart i prefer much javascript since am used writing java codesecondly intellij is ide choice the game-changer ( me): flutter runs inside vm draws everything itself. should bring performance a whole lot possibilities the framework. yep: was right!since started building lime flutter took around 10 hours work (reading docs included) built following here is its done.gif: lime flutter versionscreenshot: lime flutter versiondisclaimer: assume, you already how setup flutter that have very basic understanding how framework works. is lot great stuff read you https://flutter.io we need dostep 1: build basic layout will rebuild basic layout lime including viewpager the bottom navigation.step 2: build list supports pagination data loadingsince lime includes multiple lists, displaying large data-sets, should implement way handle data loading pagination logic a somewhat elegant . i show i did . you judge if want step 3: build layout a post will rebuild layout a post. will how easy non-trivial layouts be built using flutter how fast is done.step 4: build fading images want images fade loading. will show you use flutters modular system widgets build such behaviour very few lines codestep 5: integrate interaction: a post \"likeable\" animate action.once user hits little ghost post is liked. will show to execute simple rest-api call, how animate state change. will learn callbacks handle state changes parent widgets.step 6: profit. didn't figure one , yet step 1: build basic layout first step is done rebuilding basic layout lime. can obviously that app consists :a toolbar ( we miss this article since did build yet viewpager(android)/pageview(flutter) containing three pages navigation bar the bottom the app controlling viewpager/pageviewluckily flutter provides very useful skeleton building type layout:scaffold first things :a materialapp widgetshould the root our application provide material design all love class limeapp extends statelesswidget { @override widget build(buildcontext context) { return materialapp( title: 'lime', home: mainpage(), ); } }limeapp be entry point our application we wont touch far. lets a how should build mainpage look feel we it have.since have do controlling inside mainpage will declare asstatefulwidgetclass mainpage extends statefulwidget { @override state<statefulwidget> createstate() { return _mainpagestate(); }} we should talk the _mainpagestate. written somewhere above:please sure know widgets their states are how basically build layouts using flutter!1.1 creating pageview three children app has display three different pages the user: trends, feed community. will a pageview place placeholders inside for .class _mainpagestate extends state<mainpage> { @override widget build(buildcontext context) { return scaffold( body: pageview( children: [ container(color: colors.red), container(color: colors.blue), container(color: colors.grey) ] ) ); } } can replace simple colored containers later our more sophisticated widgets. is the app should like right .screenshot: building pageview1.2 creating bottom navigationcreating bottom navigation is amazingly simple using scaffold we to is provide bottomnavigationbar. there is flame/fire icon the standard icon set are using something else now.don't worry getting different icons is pretty simple, wont covered this article.here is it looks :class _mainpagestate extends state<mainpage> { @override widget build(buildcontext context) { return scaffold( body: pageview( children: [ container(color: colors.red), container(color: colors.blue), container(color: colors.grey) ] ), bottomnavigationbar: bottomnavigationbar( items: [ bottomnavigationbaritem( icon: icon(icons.add), title: text(\"trends\") ), bottomnavigationbaritem( icon: icon(icons.location_on), title: text(\"feed\") ), bottomnavigationbaritem( icon: icon(icons.), title: text(\"community\") ) ] ) ); }}screenshot: building bottom navigation was extremely simple, wasn't ? but we to provide controlling the navigation we to is using pagecontrollerclass _mainpagestate extends state<mainpage> { /// controller be used programmatically /// set current displayed page pagecontroller _pagecontroller; @override widget build(buildcontext context) { return scaffold( body: pageview( children: [ ... ], /// specify page controller controller: _pagecontroller ), bottomnavigationbar: bottomnavigationbar( items: [ ... ], /// be used scroll the next page /// using _pagecontroller ontap: navigationtapped, ) ); } /// called the user presses of /// [bottomnavigationbaritem] corresponding /// page index void navigationtapped(int page){ // animating the page. // can whatever duration curve like _pagecontroller.animatetopage( page, duration: const duration(milliseconds: 300), curve: curves.ease ); } @override void initstate() { super.initstate(); _pagecontroller = pagecontroller(); } @override void dispose(){ super.dispose(); _pagecontroller.dispose(); }} you easily controlling pageview is simple fun! here is we did:create pagecontroller inside .initstate()delegate controller the pageview paramhandle ontap event bottomnavigationbaranimate the page want using custom duration a custom curvecall .dispose() the pagecontroller once state gets disposed! we are facing last problem: updating bottom navigation indicate correct page. therefore simple integer is introduced the _mainpagestate indicating page is currently displayed.class _mainpagestate extends state<mainpage> { /// controller be used programmatically /// set current displayed page pagecontroller _pagecontroller; /// indicating current displayed page /// 0: trends /// 1: feed /// 2: community int _page = 0; ... implement information the view have simply update bottomnavigationbar the following bottomnavigationbar: bottomnavigationbar( items: [ ... ], /// be used scroll the next page /// using _pagecontroller ontap: navigationtapped, currentindex: _page )last step: listen the page changes call .setstate(). will start creating new method called onpagechanged(int page) inside _mainpagestate void onpagechanged(int page){ setstate((){ ._page = page; }); } make sure, this method gets called, add as callback the pageview: pageview( children: [ container(color: colors.red), container(color: colors.blue), container(color: colors.grey) ], /// specify page controller controller: _pagecontroller, onpagechanged: onpagechanged )'s : basic layout is done. everything looks we it be. here is we so far:resume: basic layout far, good import 'package:flutter/material.dart';import 'package:flutter/widgets.dart';void main() { runapp( limeapp());}class limeapp extends statelesswidget { @override widget build(buildcontext context) { return materialapp( title: 'lime', home: mainpage(), ); }}class mainpage extends statefulwidget { @override state<statefulwidget> createstate() { return _mainpagestate(); }}class _mainpagestate extends state<mainpage> { /// controller be used programmatically /// set current displayed page pagecontroller _pagecontroller; /// indicating current displayed page /// 0: trends /// 1: feed /// 2: community int _page = 0; @override widget build(buildcontext context) { return scaffold( body: pageview( children: [ container(color: colors.red), container(color: colors.blue), container(color: colors.grey) ], /// specify page controller controller: _pagecontroller, onpagechanged: onpagechanged ), bottomnavigationbar: bottomnavigationbar( items: [ bottomnavigationbaritem( icon: icon(icons.add), title: text(\"trends\") ), bottomnavigationbaritem( icon: icon(icons.location_on), title: text(\"feed\") ), bottomnavigationbaritem( icon: icon(icons.), title: text(\"community\") ) ], /// be used scroll the next page /// using _pagecontroller ontap: navigationtapped, currentindex: _page ) ); } /// called the user presses of /// [bottomnavigationbaritem] corresponding /// page index void navigationtapped(int page){ // animating the page. // can whatever duration curve like _pagecontroller.animatetopage( page, duration: const duration(milliseconds: 300), curve: curves.ease ); } void onpagechanged(int page){ setstate((){ ._page = page; }); } @override void initstate() { super.initstate(); _pagecontroller = pagecontroller(); } @override void dispose(){ super.dispose(); _pagecontroller.dispose(); }}gif: basic layoutstep 2: build list supports pagination data loading of lime's three pages (trends, feed community) is displaying almost endless scrolling list. plan is build basic layout handles data loading, pagination refresh us. should a generic interface function load specific data one adapt widget given loaded data.here is it looks :typedef future<list<t>> pagerequest<t> (int page, int pagesize);typedef widget widgetadapter<t>(t t);pagerequest given pagerequest takes page pagesize arguments, while page represents page index (0 page, 1 second page, ...) pagesize exact count items load, returns list generic items asynchronously.widgetadapteronce loadinglistview ( is i called ) successfully loaded items using kind pagerequest, widgetadapter is used build widgets a generic item needed.providing implementations those type definitions our loadinglistview give the freedom reuse loadinglistview almost anything needed lime lets build ! the loadinglistview should pretty straight forward.class loadinglistview<t> extends statefulwidget { /// abstraction loading data. /// can anything: api-call, /// loading data a certain file database, /// etc. will deliver list objects ( type t) final pagerequest<t> pagerequest; /// used building widgets of /// fetched data final widgetadapter<t> widgetadapter; /// number elements requested each page final int pagesize; /// number \"left \" elements list /// will trigger loading next page final int pagethreshold; /// [pageview.reverse] final bool reverse; final indexer<t> indexer; loadinglistview(.pagerequest, { .pagesize: 50, .pagethreshold:10, @required .widgetadapter, .reverse: false, .indexer }); @override state<statefulwidget> createstate() { return _loadinglistviewstate(); }} we : its about state!obviously need hold kind reference the fetched objects we are going display using standard listviewclass _loadinglistviewstate<t> extends state<loadinglistview<t>> { /// contains fetched elements ready display! list<t> objects = []; @override widget build(buildcontext context) { listview listview = listview.builder( itembuilder: itembuilder, itemcount: objects.length, reverse: widget.reverse ); return listview; }}looks pretty nice far, how does itembuilder like what does do? widget itembuilder(buildcontext context, int index) { return widget.widgetadapter != null ? widget.widgetadapter(objects[index]) : container(); } basically builds widgets the fetched data! i : the null-check is unnecessary, cares!loading data will introduce methods the data-loading logicloadnext()lockedloadnext() you see why chose using methods.loadnext()future loadnext() async { int page = (objects.length / widget.pagesize).floor(); list<t> fetched = await widget.pagerequest(page, widget.pagesize); (mounted) { .setstate(() { objects.addall(fetched); }); } } happens step step?step 1: figure which page index should loaded nextstep 2: the pagerequest provided the widget load datastep 3: add fetched objects the list use .setstate notify underlying listviewlockedloadnext() what i need second method ?calling async method loadnext() immediately return future object runs io-operation thebackground. will to introduce kind locking mechanism prevent multiple requests running the same !i decided use future object returned loadnext() an indicator any running background request.class _loadinglistviewstateo<t> extends state<loadinglistview<t>> { list<t> objects = []; /// future returned loadnext() there /// is currently request running /// null, no request is performed. future request; here lockedloadnext() will care the newly introduced \"request\" reference void lockedloadnext() { (this.request == null) { .request = loadnext().((x) { .request = null; }); } }again - step step:step 1: check there is request currently running? skip entire method this.request ist nullstep 2: indicate a request is currently running assigning future returned .loadnext() requeststep 3: sure un-reference once request has finished.initial loading paginationsince now built data loading logic, need call !initial loading will .initstate perform trigger data loading the time: @override void initstate() { super.initstate(); .lockedloadnext(); }pagination how we when have trigger loading next page? way, worked me, is abusing itembuilder introduced earlier, since know it build widgets a certain index the list. widget itembuilder(buildcontext context, int index) { /// here go: once are entering threshold zone, loadlockednext() /// is triggered. (index + widget.pagethreshold > objects.length) { loadlockednext(); } return widget.widgetadapter != null ? widget.widgetadapter(objects[index]) : container(); }implement refresh mechanismdata might change. want build kind swipe refresh mechanism refetching first page!using flutters refreshindicator makes task incredibly easy! pass listview child the refreshindicator inside build method: @override widget build(buildcontext context) { listview listview = listview.builder( itembuilder: itembuilder, itemcount: objects.length, reverse: widget.reverse ); return refreshindicator( onrefresh: onrefresh, child: listview ); }last thing do: implement onrefresh future onrefresh() async { .request?.timeout(const duration()); list<t> fetched = await widget.pagerequest(0, widget.pagesize); setstate(() { .objects = fetched; }); return true; }step step:step 1: cancel currently running requeststep 2: pagerequest directly fetch first pagestep 3: set display fetched data"
}