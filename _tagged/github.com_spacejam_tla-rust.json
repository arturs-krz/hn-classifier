{
	"_id": "14373359",
	"site": "https://github.com/spacejam/tla-rust",
	"title": "Writing correct lock-free and distributed stateful systems in Rust, with TLA+",
	"author": "guifortaine",
	"date": "2017-06-13T13:57:07.629Z",
	"tags": {
		"categories": [
			"opensource",
			"tla",
			"rust",
			"model-checking",
			"lock-free",
			"distributed"
		],
		"languages": [
			"tla",
			"makefile"
		]
	},
	"content": "readme.md tla+rust stable stateful systems through modeling, linear types simulation. like use things wake up 4am rarely possible.unfortunately, infrastructure vendors don't focus reliability. if company gives reliability lip service, 's unlikely they techniques modeling simulation create rock-solid core.let's build open-source distributed store takes correctnessseriously the local storage, sharding, distributed transactional layers. goal: verify core lock-free distributed algorithms use rsdb rasputin tla+. write implementation rust. quickcheck abstracted rpc/clocks simulate partitions test correctness under failure conditions.table contentsmotivations doing at what the words \"simulate\" \"model\" mean this context? why rust? why model? why simulate?introductions tla+, pluscal, quickcheck intro: specifying concurrent processes pluscal useful primitives modeling concurrent distributed algorithmslock-free algorithms efficient local storage lock-free ring buffer lock-free list lock-free stack lock-free radix tree lock-free io buffer lock-free epoch-based garbage collector lock-free pagecache lock-free treeconsensus within shard harpoon consensus protocolsharding operations shard splitting shard mergingdistributed transactions lock-free distributed transaction protocolmotivationsterminologysimulation, this context, refers writing tests exercise rpc-relatedcode simulating buggy network time, partitions all. many morefailures may tested per unit compute using simulation compared black-box fault injection something namazu, jepsen, blockade.modeling, this context, refers the of tla+ model checker ensure correctness our lock-free distributed algorithms.why rust?rust is new systems programming language emphasizes memory safety. is notable its compiler, is able make several types common memory corruption bugs ( attack vectors exploits) impossible create default, without relying gc. is mozilla project, as this writing, is starting be included their firefoxweb browser. uses \"ownership\" system ensures object'sdestructor run exactly once, preventing double-frees, dangling pointers,various null pointer related bugs, etc... an object is created inside function's scope, exists the property that scope. object's lifetime is same the lifetime the scope created .when lifetime an object is , the object's destructor is run. you pass object a function an argument, object becomes property the called function, when called functionreturns, objects its posession be destroyed unless functionis returning . objects returned a function become property the calling scope. order pass object several functions, may instead pass reference. passing reference, object remains property thecurrent scope. is possible create references imply sole ownership,called mutable references, may used , you guessed , mutate object being referred . this is useful using object a function will mutate , without object becoming property that function, allowing object outlive mutating function.while a single mutable reference may created, infinite immutablereferences may created, long they not outlive object the reference points .rust does use gc default. however, does severalcontainer types rely reference counting preventing object's destructor being called multiple times. are useful sharing things multiple scopes multiple threads. objects are generally rare compared the total number objectscreated a typical rust program. lack gc every object may a compelling feature those creatinghigh-performance systems. many such systems are currently written c c++, have long track record buggy insecurecode, when written security-conscious life-long practitioners.rust has potential make high-performance, widely-deployedsystems much more secure crash less frequently. means webbrowsers, ssl libraries, operating systems, networking stacks,toasters many vital systems are much harder hack morerobust against common bugs. databases, memory safety benefits are wonderful, i'm betting being able achieve faster long-term iteration not spending much chasing down memory-related bugs. however, needs benoted when creating lock-free high-performance algorithms, are going need sidestep safety guarantees the compiler. goal is create data structures are mutated using atomiccompare--swap (cas) operations multiple threads simultaneously, also supporting reads the same . we choose to sacrificeperformance using mutexes. means using rust'sbox::into_raw/from_raw, atomicptr, unsafe pointers mem::forget. are giving a significant benefit rust certain veryhigh-performance chunks this system. place rust's compiler, use tla+ model checker gain confidence the correctness our system!why model?tla+ allows to specify verify algorithms very few lines, compared the programming language we use implement test .it is tool is frequently mentioned engineers statefuldistributed systems, it has been used relatively few, has reputation being overkill. believe this reputation isunfounded this type work.many systems are well understood their creators the start theproject, leads architectural strain assumptions are invalidated the project continues grow time.small projects are often cheaper complete using approach, an incorrect initial assumption may a lower long-term impact.stateful distributed systems tend have significant costs associated unanticipated changes architecture: reliability, iteration ,and performance be expected take hits. our system, willspecify core algorithms before implementing , which allow to catch mistakes before result bugs outages.why simulate? want make sure our implementation is robust againstnetwork partitions, disk failures, ntp issues, etc..., why run namazu, jepsen, blockade? have great success finding bugs databases! however, is far slower perform black-boxfault injection simulation. simulator artificially advance clocks a system induce leader election, while \"real\" clusterhas wait real to trigger certain logic. also takes lot time deploy code a \"real\" cluster, it is cumbersome introspect.simulation is a replacement black-box testing.simulation be biased, it's to implementor the simulator ensure all sources time, ipc, otherinteraction are sufficiently encapsulated the artificial andinteraction logic.simulation allow contributor working a more resource-constrainedsystem test locally, running through thousands millions failure situations the that takes create rpm/container is fed a black-box fault injection system. ci/cd pipeline get far more test coverage per unit compute using simulation with black-box fault injection.both simulation black-box fault injection be constrained complete a certain amount time, simulation likely find lot more bugs per unit compute . simulationtests may a reasonable thing expect pass most pullrequests, since can achieve high bug:compute ratio.however, black box fault injection is still important, willprobably catch bugs arising the bias the simulation authors. will use black-box testing, we spend less talking it due its decent existing coverage.introductions want use tla+ model find bugs things :cas operations lists, ring buffers, radix trees lock-free local systemspaxos- consensus leadership, replication shard management systemslock-free distributed transactionsdistributed concurrent algorithms many similarities, there are key differences the primitives we build in work.concurrent algorithms rely atomic cas primitives, achieving sequentiallyconsistent access semantics is fairly understood implemented this point. distributed systems world has many databases provide strongordering semantics, it doesn't such reliable, standard primitive cas we simply assume be present. we need initially in terms the \"asynchronous communication model\" which messages between two processes be reordered arbitrarily delayed, droppedaltogether. we proved own model achieving consistency, will build it later higher-level models describe particularlyinteresting functionality such lock-free distributed transactions. our tla+ models, can simply a fairly short labeled block performs duties compare swap ( another atomic operation) shared state describing concurrent algorithm, we need build completereplicated log primitive before can at similar level abstraction our models distributed algorithms., let's learn to describe of primitives invariants!here go... jumping pluscal is summary an example a wonderful primer tla+... first thing know is there are languages play: pluscal tla. test models using tlc, understands of tla ( infinite sets, maybe stuff). tla started a specification language, tlc came along later actually test , and pluscal is simpler language can transpiled tla. pluscal has forms, c p. are functionally identical, c form uses braces p form uses begin end statements can alittle easier spot errors , in opinion.'re writing pluscal a tla comment (block comments are written (* <comment text> *)), when run translator pcal2tla will insert tla the comment, the same file.------------------------------- module pcal_intro -------------------------------extends naturals, tlc(* --algorithm transfervariables alice_account = 10, bob_account = 10, account_total = alice_account + bob_accountprocess transproc \\ 1..2 variables money \\ 1..20;begin transfer: alice_account >= money a: alice_account := alice_account - money; b: bob_account := bob_account + money; end ;c: assert alice_account >= 0;end processend algorithm *)\\* is tla comment. pcal2tla insert transpiled tla heremoneyinvariant == alice_account + bob_account = account_total============================================================================= code specifies 3 global variables, alice_account, bob_account, account_total. specifies, using process <name> \\ 1..2 it run two concurrent processes.each concurrent process has local state, money, may any initial value 1 20, inclusive. defines steps transfer, , b c are evaluated atomic units, although will tested against possible interleavings execution. possible values be tested.let's save above example pcal_intro.tla, transpile pluscal comment tla, run with tlc! ( you to name something else, update modulespecification the top)pcal2tla pcal_intro.tlatlc pcal_intro.tlaboom! blows because transaction code sucks, big :the argument assert evaluated false; second argument was:\"failure assertion line 16, column 4.\"error: behavior to point is:state 1: <initial predicate>/\\ bob_account = 10/\\ money = <<1, 10>>/\\ alice_account = 10/\\ pc = <<\"transfer\", \"transfer\">>/\\ account_total = 20state 2: <action line 35, col 19 line 40, col 42 module pcal_intro>/\\ bob_account = 10/\\ money = <<1, 10>>/\\ alice_account = 10/\\ pc = <<\"\", \"transfer\">>/\\ account_total = 20state 3: <action line 35, col 19 line 40, col 42 module pcal_intro>/\\ bob_account = 10/\\ money = <<1, 10>>/\\ alice_account = 10/\\ pc = <<\"\", \"a\">>/\\ account_total = 20state 4: <action line 42, col 12 line 45, col 63 module pcal_intro>/\\ bob_account = 10/\\ money = <<1, 10>>/\\ alice_account = 9/\\ pc = <<\"b\", \"\">>/\\ account_total = 20state 5: <action line 47, col 12 line 50, col 65 module pcal_intro>/\\ bob_account = 11/\\ money = <<1, 10>>/\\ alice_account = 9/\\ pc = <<\"c\", \"\">>/\\ account_total = 20state 6: <action line 42, col 12 line 45, col 63 module pcal_intro>/\\ bob_account = 11/\\ money = <<1, 10>>/\\ alice_account = -1/\\ pc = <<\"c\", \"b\">>/\\ account_total = 20error: error occurred tlc was evaluating nestedexpressions the following positions:0. line 52, column 15 line 52, column 28 pcal_intro1. line 53, column 15 line 54, column 66 pcal_intro9097 states generated, 6164 distinct states found, 999 states left queue. depth the complete state graph search is 7.looking the trace tlc outputs, shows how alice's account may becomenegative. processes 1 2 execute steps sequentially withdifferent interleavings, algorithm check alice_account >= moneybefore trying transfer to bob. the one process subtracts money alice, however, other process may already done . we specify these steps checks happen atomically changing: transfer: alice_account >= money a: alice_account := alice_account - money; b: bob_account := bob_account + money; end ;to transfer: alice_account >= money \\* remove labels : and b: alice_account := alice_account - money; bob_account := bob_account + money; end ;which means the entire transfer step is atomic. reality, maybe is done punting atomicity requirement a database transaction. re-running tlc shouldproduce errors , because both processes atomically check + deduct + add balances the bank accounts without violating assertion. invariant, moneyinvariant, the bottom is actually being checked yet.invariants are specified tla, in pluscal comment. can checked creating pcal_intro.cfg file ( replace one auto-generated pcal2tla) the following content:specification specinvariant moneyinvariantuseful primitives, we've seen to create labels, processes, invariants. here are otheruseful primitives:awaitbagsextends naturals, finitesets, sequences, integers, tlc a more -depth tla+ introduction, refer the tutorial thiswas summarized and manual.lock-free algorithms efficient local storage the interests achieving price-performance is compelling, need make thing sympathetic modern hardware. check dmitry's wonderful blog a fast overview the important ideas writing scalable code.lock-free ring buffer ring buffer is the heart several systems our local storage system. serves the core our concurrent persistent log io buffer theepoch-based garbage collector our logical page id allocator.lock-free list list allows to cas partial update a page a chain, avoiding work rewriting entire page. read page, traverse listuntil learn what sought. eventually, need compact list partial updates improve locality, probably around 4-8.lock-free stack stack allows to maintain free list page identifiers. radixtree needs be very densely populated achieve favorable data pointer ratio, by reusing page identifiers they are freed, are able keep dense. hence stack. we free page, push identifier this stack reuse.lock-free radix tree use radix tree maintaining in-memory mapping logicalpage id its list partial updates. well-built radix tree achieve .92 total size:data ratio densely populated using contiguous key range. is better what get b+ trees, max between .5-.6. downside is with low-density get extremely poor data:pointer ratios a radix tree.lock-free io buffer use ring buffer hold buffers writing data onto disk, along associated metadata where disk buffer end .this is fraught peril. need avoid aba problems the cas claims particular buffer, later relies a particular log offset. also need avoid creating stall all available buffers areclaimed, a write depends flushing end the buffer before beginning is free. possible ways avoiding: fail reservation attempts the buffer is full claims, support growing buffer necessary.bandaid: don't seal entire buffer during commit reservation.lock-free epoch-based gc basic idea epoch-based gc is in lock-free structures, may end making certain data inaccessible via cas a node somewhere, that doesn't mean there isn't already thread is operating it. use epochs track a structure is marked inaccessible, well when threads begin end operating shared state. beforereading mutating shared state, thread \"enrolls\" an epoch. the thread makes state inaccessible, adds to current epoch's free list. current epoch may later theepoch the thread initially enrolled . the state is droppeduntil are threads epochs before at epoch where state was marked free. a thread stops reading mutating shared state, leaves epoch it enrolled .lock-free pagecachemaintains radix tree mapping logical page id a list page updates,terminated a base page. uses epoch-based gc safely making logical id'savailable a stack. facilitates atomic splits merges pages.lock-free treeuses pagecache store b+ tree pages.consensus within shard use consensus protocol the basis our replication across shard.consensus notes:support oltp small replication batch sizesupport batch loading analytical jobs large replication batch size max throughput a single shard, send disparate 1/n the batch each node, then them forward chunk everybody else this adds complexity, if each node has several shards, are alreadyspreading io around, we just pick latency-minimizing simplebroadcast where leader sends full batches all followers.tcp is already replicated log, hint hintudp may nice receiving acks, it doesn't in surprising number dcsharpoon consensussimilar raft, uses leader leases instead a paxos register. paxosregister preemptable election raft is vulnerable livelock the -unusualcase a network partition between leader another node, triggers dueling candidate situation. using leases allows to progress long anode has connectivity a majority its quorum, regardless interfering nodes. addition, node cannot reach leader may subscribe the replication log any node has seen more successful log entries.sharding operationssharding has ideals:avoid unnecessary data movement (wait time before replacing failed node) multiple nodes fail simultaneously, minimize chances dataloss (chainsets)minimize mttr a node fails (lots shards per machine, reduce membership overlap)ideals 2 3 are someone tension, there is goldilocks zone.sharding introduces question \"who manages mapping?\" is sometimes punted an external consensus-backed system. will initially create by punting metadata problem such system. eventually, will single-binary something the following: we treat shard metadata just another range, do preventsplit brain?general initialization key metadata:nodes are configured a set \"seed nodes\" initially connect cluster is initialized some node is explicitly given permission do , eithervia argv, env var, conf file admin rest api request designated node creates initial range an underreplicated state metadata range contains mapping range current assigned members this node learns others via seeds, assigns peers the initial range the metadata range ( any range) loses quorum, particular minority survivor be manually chosen a seed fresh replication. admin api also triggerbackup dumps a range, restoration a range a backup file.nodes each maintain own monotonic counters, publish few basic stats their ranges utilization using shared orswotshard splittingsplit algorithm: operations happen a range, keep track the max min keys, keep running average the position between max min inserts. then choose split point around . if keys are always added one end, split should occur the end.record split intent watched meta range the desired pointrecord split intent the replicated log the range members the replica set split metadata they the split intent their replicated log half the split point contains less density is migrated changing consensus participants node a .once two halves a balanced placement, split intent is removedshard mergingmerge algorithm:merge intent written metadata range smaller half is move the larger's servers direction is marked the of intent, prevent flappingonce ranges are colocated, the larger range's replicated log,write merge intent, causes to accept keys the rangewrite merge intent the less frequently accessed range's replicatedlog causes to redirect reads writes the larger range.update metadata range reflect mergeremove handlers metadata old rangedistributed transactionscross-shard lock-free transactionsrelatively simple lock-free distributed transactions:read involved datacreate txn object somewherecas involved data refer the txn object the conditionally mutated statecas txn object successful( crash here the txn is still valid)cas affected data replace value, remove txn referencereaders any point cas txn object aborted they encounter in-progresstxn something are reading. the txn object is successful, reader needs cas object's conditionally mutated state be present state, nuke txn reference, before continuing. can relaxed just intended writers, then isolation level goes ssi si we are vulnerable write skew.invariants:must never any intermediate states, transaction must entirelycommitted entirely invisible."
}