{
	"_id": "14202058",
	"site": "https://github.com/mkdoc/mkcli",
	"title": " Markdown command line interface definition",
	"author": "tmpfs",
	"date": "2017-06-13T13:33:07.297Z",
	"tags": {
		"categories": [
			"opensource",
			"markdown",
			"cli"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md command line interfacedefine command line interfaces markdowndescribe command line interface an easy read man-style markdown document compile to program descriptor; json program descriptor then used the program implementation parse validate arguments. markdown program definitions be converted man pages, help files shell completion scripts.encourages document approach writing command line interfaces a fluid natural language writing style.installnpm mkcli --save the command line interface install mkdoc globally (npm -g mkdoc).installexampleguidedefining programsnamesynopsisdescriptionargumentsflagsoptionsrequiredmultipletype infodefault valuecommandsidentifiersmanual sectionssynopsis expansionflagsoptionsexclusive optionsexpansion examplecompiling programscreating documentationhelp styleshelp sectionscompletionactionssynopsis completionspecification completioncommand completionhelpapisrccompilerdestoptionsloadrunlicenseexample compile output types the same directory the input file:mkcli program.mdcompile output types a specific directory:mkcli program.md -o buildcompile specific output type:mkcli -t man program.mdcompile specific output type a particular directory:mkcli -t zsh program.md --zsh build/zsh you a lot programs pass directory all markdown documents the directory are compiled:mkcli doc/cli -o build may pipe input more control the output; set man page title:mkcat program.md | mkcli -t man | mkman --title program > program.1 help more options.example files a simple working program are doc/example:program definitionprogram descriptorhelp fileman pagezsh completionprogram implementationminimal executableevery program the mkdoc toolkit is compiled using library:definitionscompiled descriptorshelp filesman pageszsh completionprogram implementationsexecutablesguidedefining programs markdown document defines sections start a level heading continue until next level heading the end file is reached. sections have special meaning the compiler are name, synopsis, description, commands options. is considered best practice declare sections the order listed. other sections are deemed be man page sections are ignored help output default ( may included compile ) and are always included generating man pages.section headings are case-sensitive you use upper case, title case lower case they must match exactly.name man pages name section is required it must include brief summary the program the program name. delimit program name the short summary using hyphen surrounded spaces shown below. name section must the section the file otherwise compiler error. program name summary is extracted the paragraph under name heading:# nameprg - short program summary subcommands define parent names a command using whitespace between words:# nameprg list - perform list actionadd list a program have multiple names:# nameprg - short program summary+ prg-aliassynopsis program synopsis is created all code block elements under synopsis heading:# nameprg - short program summary# synopsis [options] [file...] is compiler error any type is declared the synopsis section.description program description is created all block level elements under description heading:# nameprg - short program summary# description extended description can include paragraphs, lists, code blocks other block level elements.note the help output includes paragraphs some meaning may lost you include lists, code blocks block quotes. this reason is recommended the description section contain paragraphs. you mix content the description section can the -d, --desc option generating help file restrict number paragraphs included the help output.consider example:# nameprg - short program summary# descriptionsimple program.run : cat file.md | prgcontext be lost the second paragraph the code block not included the help output, whilst would perfect sense the man output. prevent loss context include first paragraph the help output:mkcat program.md | mkcli --desc 1 | mktextargumentsprogram arguments are declared a heading options a list following heading.note list bullet character + is preferred it creates more idiomatic listing generated man pages.# nameprg - short program summary# options+ `-, --input [file...]` input files+ `-o, --output [file]` output file argument is declared a list item whose child is inline code element defines specification. specification is parsed an object representing argument may of type flag, option command. remaining list item content the specification is treated a description the argument.flags argument specification no value is treated a flag option:+ `-v, --verbose` print more informationoptions create option argument specify value either [] <>:+ `-o, --output [file]` output filerequired the <> notation is used indicates that option is required:+ `-t, --type <type>` output format parsed option have required flag set.multiple signify an option argument is repeatable include ellipsis:+ `-, --input [file...]` input files parsed option have multiple flag set.type info can associate type information the {} notation:+ `-, --indent [num] {number}` amount indentation parsed option have kind property set number. can delimit multiple types | and kind is expanded an array. is useful indicate argument may of multiple types if want treat argument value an enum:+ `-t, --type [val] {json|help|man}` renderer typedefault value specify default value the option the = operator the type:+ `-, --indent [num] {number=2}` amount indentation parsed option have kind property set number the value property set 2. can specify default value using:+ `-, --indent [num] {=2}` amount indentation which case kind property be undefined the value property is set 2.commandscommands are declared the same as program arguments under commands heading:# nameprg - short program summary# commands+ `ls, list` list tasks+ `, info` print task information allow to create complex programs options specific a command.command files are loaded compiled automatically following naming convention. using above example define list command create file named prg-list.md:# namelist - list tasks# options+ `-, --all` list tasks+ `-t=[type...]` list tasks type result the compiled tree containing options specific the list command.identifiers a program is created a source markdown document each argument command is given key the resulting map. key is generated automatically using longest argument ( command) name converting to camel case. you wish use fixed key can add identifier followed a colon (:) the beginning the specification:# nameprg - short program summary# commands+ `tasks: ls, list` list tasks# options+ `verbose: -v` print more informationmanual sections heading is matched any the rules above is treated a manual section:# nameprg - short program summary# environment environment variable foo changes behaviour `bar`. section ends the next level heading is encountered the end the file is reached.synopsis expansionunless disabled synopsis declaration is expanded the man help output types.flags the notation [flags] ( <flags>) the synopsis it be replaced all short form (single character) flag options ( example: -xvf).options the notation [options] ( <options>) the synopsis it be replaced all option names are declared the synopsis were expanded using [flags] notation.exclusive options should indicate mutually exclusive options using vertical bar between option names. compiling json synopsis is parsed any mutually exclusive declarations are added the output using target option keys. is compiler error the target option is declared.expansion examplegiven definition such :# nameprg - short program summary# synopsis [flags] [options] [--xml|--html] <file...># options+ `-x, --xml` print xml+ `-h, --html` print html+ `-v` print more information+ `-h, --help` display help exit+ `--version` print version exit synopsis is expanded :prg [-xhvh] [--help] [--version] [--xml|--html] <file...>compiling programs compile markdown document a json program descriptor run:mkcli -t json program.md you a json document describes program commands options.creating documentationonce have defined program will to generate man page some help text. create help text run:mkcli -t help program.md a man page run:mkcli -t man program.mdhelp styles default column help style (col) should suit purposes however other styles be useful. list style renders list the commands options is designed when have very long argument names a few arguments require long descriptions. cmd style is list command names (options are printed) designed be used a program has lots commands a command is required. typically program show help page no command was specified indicate the user command is required.sometimes may very minimal help output just includes usage synopsis which case the usage style.help sectionssometimes creating help files may to include section the manual, possibly want include environment section show environment variables program recognises.pass regular expression patterns using --section option if match section heading section be included the help the commands options. include environment section could :mkcli -t help -s env program.md include environment bugs sections could :mkcli -t help -s env -s bug program.md if prefer:mkcli -t help -s '(env|bug)' program.md the help more options available creating help man pages.completioncompletion scripts are currently available zsh. install completion script a program copy script a directory $fpath modify ~/.zshrc autoload directory containing completion script:fpath=(/path//completion $fpath) full working completion example is notes test fixture.sometimes may wish reload completion testing purposes:unfunction _notes && autoload -u _notesactions option value specifications map zsh completion functions:user: :user:_usersgroup: :group:_groupshost: :host:_hostsdomain: :domain:_domainsfile: :file:_filesdir: :directory:_directoriesurl: :url:_urlssuch an option specification such :+ `-i, --input [file...]` input files+ `-o, --output <dir>` output directory result the _files completion function being called complete file paths the --input option the _directories function the --output option. note the ellipsis (...) multiple flag is respected --input be completed multiple times whilst --output only complete once. options specify list types _values completion function is called.+ `-t, --type=[type] {json|yaml}` output typeresults automatic completion the --type option one json yaml.actions are enclosed double quotes (\") you may single quotes paired double quotes not single double quote will generate unmatched \" zsh error.synopsis completion program synopsis section is inspected will completion functions a match is available, a synopsis such :[options] [files...] result the _files completion function called, above the list matches completion functions.sometimes may need create custom completion list; can set info string fenced code blocks the synopsis section inject scripts. value may either zsh-locals inject code the beginning the body the generated completion function zsh add the list completion actions. real-world example is mk (program definition compiled completion script) completes the available task names.specification completion may wish change zsh action taken per option, can done appending colon the zsh action an option specification:+ `-p, --package=[file] :file:_files -g '+.json'` package descriptor will complete files a .json extension the --package option.command completioncommands are recursively added the completion script; are completed using following rules:required commands (<command> the synopsis) not list options default.command options inherit the global options.command options cascade child options.rest pattern matches (*: :file:_files example) are respected. is recommended use program synopsis the command :# synopsis <command> [options] [files...] if command is required:# synopsis [command] [options] [files...] is command completion is terminated an option is intermingled the command hierarchy. consider program has command structure notes > list > bug|todo|feature you present command line such :notes list --privatecompletion no longer attempted the list sub-commands. put another commands must consecutive command completion occur.helpusage: mkcli [-frrchfnph] [--full] [--recursive] [--raw-synopsis] [--colon] [--header] [--footer] [--newline] [--preserve] [--help] [--version] [--package=<file>] [--type=<type>] [--style=<val>] [--cols=<num>] [--split=<num>] [--desc=<num>] [--indent=<num>] [--align=<type>] [--usage=<val>] [--section=<ptn...>] [--json=<dir>] [--text=<dir>] [--man=<dir>] [--zsh=<dir>] [--output=<dir>] [files...] compiles markdown cli definitions.options -p, --package=[file] package descriptor -t, --type=[type] output renderer type (json|help|man) -y, --style=[val] help output style (col|list|cmd|usage) -c, --cols=[num] wrap help output num (default: 80) -s, --split=[num] split help columns num (default: 26) -d, --desc=[num] number description paragraphs help output -, --indent=[num] number spaces help indentation (default: 2) -, --align=[type] alignment first help column (left|right) -u, --usage=[val] set usage message help synopsis (default: usage:) -f, --full not compact compiled descriptor -r, --recursive recursively load command definitions -r, --raw-synopsis not expand synopsis -c, --colon append colon headings help output -s, --section=[ptn...] include sections matching patterns help output -h, --header include default header help output -f, --footer include default footer help output -n, --newline print leading newline no header -p, --preserve not upper case headings man output -j, --json=[dir] set output directory json files -t, --text=[dir] set output directory help text files -m, --man=[dir] set output directory man pages -z, --zsh=[dir] set output directory zsh completion -o, --output=[dir] set output directory all types -h, --help display help exit --version print version exitmkcli@1.0.32 https://github.com/mkdoc/mkcliapisrcsrc([opts])gets source parser stream transforms incoming tree nodes parser state information.returns parser stream.opts object parser options.compilercompiler([opts])gets compiler stream transforms parser state information a program definition.returns compiler stream.opts object compiler options.destdest([opts])gets destination renderer stream. no type is specified json renderer is assumed.returns renderer stream the specified type.opts object renderer options.optionstype string=json renderer type.loadload(def[, opts])load program definition a program assigning definitionproperties the program.properties are passed reference if modify definition program is modified.returns new program.def object program definition.opts object program options.runrun(src, argv[, runtime], cb)load program definition a program assigning definitionproperties the program.properties are passed reference if modify definition program is modified. callback function signature is function(err, req) where req is request object contains state information program execution.plugins may decorate request object pertinent information does affect target object receives parsed arguments.returns new program.src object source program definition.argv array program arguments.runtime object runtime configuration.cb function callback function.licensemitcreated mkdoc april 26, 2017"
}