{
	"_id": "14480634",
	"site": "https://github.com/mreithub/goref",
	"title": " GoRef â€“ slim profiler for Go applications",
	"author": "mreithub",
	"date": "2017-06-13T13:04:45.674Z",
	"tags": {
		"categories": [
			"opensource",
			"golang",
			"profiler"
		],
		"languages": [
			"go"
		]
	},
	"content": "readme.md goref - simple ( fast) -style invocation trackergoref is small package implements simple key-basedmethod invocation counter timing profiler. can used :track execution of functions/goroutinesfind bottlenecks your codecheck your goroutines exit properlytrack calls your http endpoints ( their execution ) - see below access internal profiling data, getsnapshot().'ll ask worker goroutine create deep copy the goref's instance current state.goref's code is thread safe. uses messaging channel read a single worker goroutine does heavy lifting.calls ref() deref() are asynchronous( asynchronousity doesn't affect measurement though).getting starteddownload package, e.g.: get github.com/mreithub/gorefadd following snippet each function ( goroutine) want track( replace 'foo' your own key names).ref := goref.ref(\"foo\"); defer ref.deref() above snippet uses goref singleton mode. you also create own goref instances ( e.g. different ones different parts yourapplication):g := goref.newgoref()// then instead the above snippet:ref := g.ref(\"foo\"); defer ref.deref() any point time can call getsnapshot() obtain deep copy the measurements.scoped measurementsgoref only supports independent goref instances also has scope hierarchy ( tree structure you ).with goref.getinstance(path ...string) can a specific child the global singleton instance. example case be seperate, possibly nested instances different parts your application(e.g. goref.getinstance(\"http\") http endpoint handlers, goref.getinstance(\"dao\", \"psql\") the postgresql based dao, ...) can a simple example goref scopes action the gorilla-mux example below ( in examples/gorillamux/ directory)example (excerpt webserver.):this example shows to goref your web applications.here tracks web handler invocations. a at usage documentation godoc.org.func indexhtml(w http.responsewriter, r *http.request) {ref := goref.ref(\"/\")defer ref.deref()w.write([]byte(`<h1>index</h1> < href=\"/delayed.html\">delayed.html</><br /> < href=\"/goref.json\">goref.json</>`))}func delayedhtml(w http.responsewriter, r *http.request) {ref := goref.ref(\"/hello.html\")defer ref.deref().sleep(200 * .millisecond)msg := fmt.sprintf(\" time is %s\", .now().string())w.write([]byte(msg))}func gorefjson(w http.responsewriter, r *http.request) {ref := goref.ref(\"/goref.json\")defer ref.deref()data, _ := json.marshal(goref.getsnapshot().data)w.header().add(\"content-type\", \"application/json\")w.write(data)}func main() {http.handlefunc(\"/\", indexhtml)http.handlefunc(\"/delayed.html\", delayedhtml)http.handlefunc(\"/goref.json\", gorefjson)http.listenandserve(\"localhost:1234\", nil)}run with run examples/webserver.and browse http://localhost:1234/ accessing each page couple times /goref.json should something this:{ \"/\": { \"active\": 0, \"count\": 6, \"duration\": 31131, \"avgmsec\": 0.0051885 }, \"/delayed.html\": { \"active\": 0, \"count\": 4, \"duration\": 811560843, \"avgmsec\": 202.89021 }, \"/goref.json\": { \"active\": 1, \"count\": 6, \"duration\": 443599, \"avgmsec\": 0.07393317 }}active: number currently active instancescount: number (finished) instances (doesn't include active ones yet)duration: total spent that function ( time.duration field)avgmsec: calculated average (usec/(1000*total))using gorilla-mux you're using gorilla-mux, 's simple toadd goref your project:(taken the example examples/gorillamux/)func trackrequests(router *mux.router) http.handler { return http.handlerfunc(func(w http.responsewriter, r *http.request) { // try find matching http route ('ll that goref key) var match mux.routematch router.match(r, &match) { path, _ := match.route.getpathtemplate() path = fmt.sprintf(\"%s %s\", r.method, path) ref := goref.ref(path) router.servehttp(w, r) ref.deref() } else { // route found (-> 404 error) router.servehttp(w, r) } })} in main function something :var router = mux.newrouter()// add routes here using router.handlefunc() the var addr = \":8080\"var handler = handlers.logginghandler(os.stdout, trackrequests(router))log.fatal(http.listenandserve(addr, handler))'ll goref data looking something this:{ \"_children\": { \"app\": { \"data\": { \"processing\": { \"active\": 0, \"count\": 11, \"duration\": 2232951708, \"avgmsec\": 202.9956 } }, \"ts\": \"2017-06-02t21:50:11.717071564+02:00\" }, \"http\": { \"data\": { \" /\": { \"active\": 0, \"count\": 13, \"duration\": 193220, \"avgmsec\": 0.014863077 }, \" /delayed.html\": { \"active\": 0, \"count\": 11, \"duration\": 2233380060, \"avgmsec\": 203.03455 }, \" /goref.json\": { \"active\": 1, \"count\": 4, \"duration\": 2025613, \"avgmsec\": 0.50640327 } }, \"ts\": \"2017-06-02t21:50:11.71706162+02:00\" } }, \"ts\": \"2017-06-02t21:50:11.717049391+02:00\"}requests matched the same gorilla-mux route be grouped together.performance impactgoref aims have little impact your application's performance possible.'s why the processing is done asynchronously a separate goroutine. a benchmark run my laptop, typical ref counter snippet takes around microsecond run:r := goref.ref(); defer r.deref()interestingly, things are lot faster we don't defer seen running bench_test. benchmarks:$ test --run=xxx --bench=.benchmarkmeasuretime-4 50000000 33.9 ns/opbenchmarkrefderef-4 5000000 339 ns/opbenchmarkrefderefdeferred-4 1000000 1124 ns/opbenchmarkgetsnapshot100-4 100000 12367 ns/opbenchmarkgetsnapshot1000-4 10000 127117 ns/oppassok github.com/mreithub/goref7.605sbenchmarkmeasuretime() measures cost calling .now() twice calculating nanoseconds between benchmarkrefderef() calls goref.ref(\"hello\").deref() directly (without using defer)benchmarkrefderefdeferred() uses defer ( in snippet above)benchmarkgetsnapshot*() measure time takes take snapshot a goref instance 100 1000 entries (= different keys) respectively"
}