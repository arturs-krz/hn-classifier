{
	"_id": "14458103",
	"site": "https://github.com/dashersw/erste",
	"title": "Erste.js â€“ NextGen UI Framework for Backbone-Lovers",
	"author": "fka",
	"date": "2017-06-13T13:55:02.651Z",
	"tags": {
		"categories": [
			"opensource",
			"javascript",
			"backbone"
		],
		"languages": [
			"javascript",
			"css",
			"html"
		]
	},
	"content": "readme.md javascript view library building performant hybrid mobile applicationserste.js is zero-hype view library an attitude. s built achieving maximum performance mobile devices.featureslightweight, 10kb minified & gzipped dependencies magic declarative it should and more pitfalls good old dom apis, html5 & css3 build modern appsclean, structured approachable apioverview// 1. import erste,import {component} 'erste';// 2. create application,class app extends component { constructor() { super(); .counter = 0; } // 3. arrange view, template() { return ` <div> <h1>${.counter}</h1> <button class=\"increment\">increment</button> <button class=\"decrement\">decrement</button> </div> `; } // 4. create methods, increment() { .$('h1').innertext = ++.counter; } decrement() { .$('h1').innertext = --.counter; } // 5. bind events. events() { return { 'tap': { '.increment': .increment, '.decrement': .decrement } } }}// 6. your application run. app().render(document.body);table contentsmotivationinstallationdirect downloadusing bowerusing npmbuilds closure compilerexample applicationbuilding first application root viewdom events dom event management workscreating componentslifecycle management componentsoption 1: declarativeoption 2: imperative erste.js apioption 3: imperative dom apicreating master detail views, introducing viewmanagergoing to master view back gestureconclusionlicensemotivationbuilding applications should straightforward simple. of frameworks used today fail hard being simple, they the wrong compromises marginal gains. super declarative framework a megabyte size, second boot and thousands questions stackoverflow due its obscure unfamiliar api... is familiar? as application developers don't need fancy features are good the paper in meetup talks. need easy--use, reasonable api gets of way. cognitive load the framework used should ideally 0. luck that you to distinguish between '<' '&'.erste.js is solemn approach application development. gives the barebones get started doesn't try steal show your application. lets focus your own source code gets of way.installationdirect downloaddevelopment versionminified version - 9.7kb gzippedusing bowerbower install --save ersteusing npmnpm install --save erstebuilds closure compilererste.js plays really with google closure compiler. 's actually built closure compiler, if use closure compiler your own application, can goog.require import source code erste.js use compile with source code right away minimal footprint maximal performance.example applicationhead to erste.js-demo an example cordova application built erste.js showcases the features erste.js. 's fortunately a do app, an almost real life multi-view app displaying fan posters popular tv shows. can learn to build manage complex view hierarchies, handle user events make of included tab bar, navigation bar, side bar, pull refresh component infinite scroll component. repository features gulpfile.js includes common tasks building application es6 transpiling through babel.building first applicationgui applications are built component architectures mind. is a latest trend the gui architecture was defined 40 years ago. in erste.js, is single simple building block component class. everything see touch an application is component erste.js, it provides special constructs ease development. most imminent these is view class, is main class presenting full view container fills screen hosts components its own lifecycle. root viewevery application starts a root view. is first thing put your <body> tag, single view includes of application.write root view extending the view class erste.js;root-view.js:import {view} 'erste';class rootview extends view { template() { return ` <root-view> <h1>hello world!</h1> </root-view> `; }} only thing need override here is template method. note templates are markups erste.js. are parsed declarative syntax, here <root-view> is a tag. since are targeting modern, html5-compatible browsers, can actually custom tags distinguishable markup. otherwise, can use plain <div>s. actually, element do fine a template, a block element makes sense the root view. now should insert view the dom. are ways do , the simplest being;index.js:import rootview './root-view';document.body.innerhtml = rootview(); simply inserts template your component the body. more involved alternative is manually render dom element the view in;index.js:import rootview './root-view'; rootview().render();note , the render method, provided arguments, renders view directly document.body. alternatively, may wish pass the desired host element the argument the render method in rootview().render(document.body); will discuss implications both approaches a further topic.dom eventshandling dom events is completely automated erste.js. acknowledge most the bugs problems arise due poor handling dom events (especially one forgets remove which leads memory leaks). moreover, manual dom listeners hinder performance your application. therefore, erste.js provides complete event management system fixes of problems you a declarative extremely performant .erste.js has built- gesture recognizer provides touch events tap, longtap, swipe more.let's listen the tap event the button our root view do something meaningless it;root-view.js:import {view} 'erste';class rootview extends view { template() { return ` <root-view> <h1>hello world!</h1> <button>tap !</button> </root-view> `; } ontapbutton() { .$('h1').innertext = 'thanks the tap!'; } events() { return { 'tap': { 'button': .ontapbutton } } }} first thing 'll notice here is declaration the events property. 's object whose keys are event types values are another object keys corresponding css selectors values corresponding event handlers.secondly, manual dom update. erste.js doesn't provide with data-binding functionality. data-binding is, matter technique employ, always poor performer. since goal erste.js is be most performant of building apps, decided against using declarative dom updates went manual updates.however, brings the question efficacy, the horrible problems due poor handling jquery code is still fresh some memories. are indeed horrible ways managing dom manually, we you stick the best practices without compromising convenience. therefore provide helper methods, $ $$. as might already guessed, are simple wrappers around queryselector queryselectorall dom apis. calls are scoped, meaning .$('button') actually translates this.el.queryselector('button') where .el is dom element the component. is very efficient straightforward of referencing dom elements. dom event management workserste.js provides declarative method managing dom events, heavily utilising event delegation. erste.js, 's global event handler each dom event type. an event occurs, global handler receives and checks there are appropriate handlers defined a component. such component is found, event is forwarded the designated handler. although event management is delegated global handlers the body, event propagation still works it's supposed . this lets use regular event handling approach are accustomed from classical web development where parent components may listen events happen their children.creating componentserste.js doesn't mess your lifecycle management. creation additional views components is strictly imperative, meaning get instantiate views manually whenever want. acknowledge a key step optimization mobile apps is manually managing instantiation disposal hefty components, we simply leave to .lets turn simple button label a standalone component.button--label.js:import {component} 'erste';class buttonwithlabel extends component { template() { return ` <button--label> <h1>hello world!</h1> <button>tap !</button> </button--label> `; } ontapbutton() { .$('h1').innertext = 'thanks the tap!'; } events() { return { 'tap': { 'button': .ontapbutton } } }} basically moved the logic a reusable component. important thing note here is, template method should return single html element. therefore, wrapped <h1> <button> <button--label>. the root view simply becomes;root-view.js:import {view} 'erste';import buttonwithlabel './button--label';class rootview extends view { constructor() { super(); .buttonwithlabel = buttonwithlabel(); } template() { return ` <root-view> ${.buttonwithlabel} </root-view> `; }}here is declarative erste.js is; views components include components simply including within template literals.lifecycle management components this example chose instantiate child component within constructor the rootview. while is very common scenario, some reason may to defer initialization the child component.option 1: declarative could create component within template method that would created when view be rendered. wouldnt extremely maintainable, could a fair trade off certain cases. the template method rootview look this:root-view.js:/* previous code */ template() { .buttonwithlabel = buttonwithlabel(); return ` <root-view> ${.buttonwithlabel} </root-view> `; }option 2: imperative erste.js api child component may require parent be the dom its instantiated. under those circumstances, would sense imperatively append child the parent the parent is rendered the dom. this case, rootview look :root-view.js:import {view} 'erste';import buttonwithlabel './button--label';class rootview extends view { onafterrender() { .buttonwithlabel = buttonwithlabel(); .buttonwithlabel.render(.el); } template() { return `<root-view></root-view>`; }} course, could as instantiate buttonwithlabel rootviews constructor render within onafterrender.option 3: imperative dom api you dont to remember custom render methods such, can use native appendchild dom api. this case, rootview look :root-view.js:import {view} 'erste';import buttonwithlabel './button--label';class rootview extends view { onafterrender() { .buttonwithlabel = buttonwithlabel(); .el.appendchild(.buttonwithlabel.el); } template() { return `<root-view></root-view>`; }}notice here need access el property the buttonwithlabel component, gives the dom element. , there is implicit rendering happening you access el the time. since creates lot buggy scenarios el might null, erste.js assumes whenever want refer el, actually to your component rendered. if component hasnt been rendered before, your convenience, erste.js renders into dom element before returning to .creating master detail views, introducing viewmanagermobile apps extensive of master / detail view scheme, its first citizen erste.js well.viewmanager is class orchestrates introduction detail views manages view hierarchy history support going to previous views altogether touch gestures.lets revise root view make a master view displays list items, introduce detail view. order facilitate internal view hierarchy, have make of viewmanager class. lets start adapting index.js this;index.js:import {viewmanager} 'erste';import rootview './root-view';var vm = viewmanager();var rootview = rootview();rootview.vm = vm;vm.setcurrentview(rootview);setcurrentview method renders view the root element vm, is default , the body, this case. then hand vm onto rootview, it later utilise view manager show detail views.lets build detail view.detail-view.js:import {view} 'erste';class detailview extends view { constructor(item) { super(); .item = item; } template() { return ` <detail-view> <p>${.item}</p> </detail-view> `; }} simply receives item its constructor prints in template.here is sample master view implementation how can use our detail view;root-view.js:import {view} 'erste';import detailview './detail-view';class rootview extends view { constructor() { super(); .items = [1, 2, 3]; } onitemtap(e) { var targetindex = e.targetel.getattribute('data-index'); var item = .items[targetindex]; var detailview = detailview(item); .vm.pull(detailview); } template_item(item, index) { return `<div data-index=${index}>${item}</div>`; } template() { return ` <root-view> ${.items.map(.template_item).join('')} </root-view> `; } events() { return { 'tap': { 'div': .onitemtap } }; }} most interesting bit here is we the information the tapped item how create detail view. although may various implementations this, chose embed index each item within template. in tap event handler, fetch index attribute instantiate detailview the corresponding item. last thing is tell view manager pull new detail view onto screen.congratulations! you a sample master / detail view application! read for more advanced cases!going to master view the simplest scenario, detail view is final view a certain while navigating the detail view, master view is disposed. also prevents memory leaks default. you wish keep history the previous views, pull method accepts second optional argument opt_cangoback type boolean. passed true, view manager saves first view its history doesnt dispose .later, can call vm.push() whenever want, the view manager go to master view, disposing detail view. back gestureerste.js features swiping gesture ios view navigation. can drag the left edge the screen towards right it reveal master view below. gesture recognition is enabled default, you need enable explicitly the detail view. modify detailview constructor set supportsbackgesture true.detail-view.js: /* previous code */ constructor(item) { super(); .item = item; .supportsbackgesture = true; } you be able navigate to original view a swipe!conclusionerste.js has lot more offer terms application development. can check the various built- components such the navigation bar, tab bar more learn you make of advanced features. sure try demo at erste.js-demo see all action.licensemit licensecopyright (c) 2017 armagan amcalarpermission is hereby granted, free charge, any person obtaining copy this software associated documentation files ( \"software\"), deal the software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /or sellcopies the software, to permit persons whom software isfurnished do , subject the following conditions: above copyright notice this permission notice shall included allcopies substantial portions the software. software is provided \" is\", without warranty any kind, express implied, including not limited the warranties merchantability,fitness a particular purpose noninfringement. no event shall authors copyright holders liable any claim, damages otherliability, whether an action contract, tort otherwise, arising ,out or connection the software the or dealings thesoftware."
}