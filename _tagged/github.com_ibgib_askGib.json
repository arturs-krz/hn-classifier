{
	"_id": "14304757",
	"site": "https://github.com/ibgib/askGib",
	"title": " AskGib â€“ Alexa Skills Kit Library with TypeScript for Amazon Echo",
	"author": "ibgib",
	"date": "2017-06-13T13:08:57.612Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"typescript"
		]
	},
	"content": "readme.md askgibalexa skills kitaskgib gives a couple primary tools make super easy developalexa skills using powerfultypescript language, superset javascript, the convenience very mature ts definitions the amazon alexa json api.funcyalexaskill gives the ability take advantage the awesomeness the amazon lambda implementations alexa skills. take incomingrequest pipe through transforms, a ridiculous amount plumbingtaken care for .lex(experimental) is new design data data retrieval not allows i18n, also alternative-driven data (neologism). this, mean with alexa, actually variety not determinism. example, you greet someone, don't to just \"hi\" 100% the. sometimes say \"hi\", sometimes \"hello\", sometimes \"greetings!\", etc. lexmakes easy these alternatives be accessed manipulated.ssml has helpful static factory functions generating ssml tags <prosody>, <emphasis>, etc. more! full api breakdown below.'ve put quite bit work jsdocs throughout self-documenting code, well creating helpfultests. be sure check those resources this readme you this library, star repo. you're feeling benevolent, open issue give some feedback. you're feeling magnanimous, add skill this issue. 'd love hear it is ( isn't?) working you. thanks nb: very cool official package alexa skills development is located here. askgib is unofficial. amazon has given endorsements anything that nature. simply wanted use typescript developing alexa skills, now approach in more functional . read for further info.dead-quickstartinherit funcyalexaskill. export class mycoolskill extends ask.funcyalexaskill { ... } ctor, map each intent an array transforms will executed order. sure initialize launch request handler well.t.transformsbyname = { \"aintent\": [t.transforma1, t.transforma2, t.transformhelpdefault], \"amazon.helpintent\": [t.transformhelpa, t.transformhelpdefault], \"amazon.repeatintent\": [t.transformrepeat], \"amazon.cancelintent\": [t.transformgoodbye], \"amazon.stopintent\": [t.transformgoodbye]}t.transformsbyname[t.getlaunchrequestname()] = [t.transformwelcome];inside each transform, check history. you the transform handle ,return next skillstate. the transform doesn't apply, return null.transforma1: ask.skilltransform = ( stimulus: ask.stimulus, history: ask.skillstate[]): ask.skillstate => { // check history (often prevskillstate) see this transform applies. let prevskillstate = .getprevskillstate(history); (!prevskillstate || prevskillstate.location !== \" prereq location\") { // doesn't apply this transform, return null // ( sure is transform this to handle !) return null; } // create output speech, mixing plain text, ssml, ssml helpers. let output = ask.speechbuilder.() .text(\"build speech plain text...\") .ssml(`<p>${ssml.emphasis(\"emphasize\", \"strong\")} some ssml.</p>`) .text(\" you a2?\") .outputspeech(); // you , you easily reuse output your reprompt let reprompt = ask.speechbuilder.() .text(\"maybe didn't hear ...\") .existing(output) .outputspeech(); // create interaction let interaction: ask.interaction = { stimulus: stimulus, type: \"ask\", output: output, reprompt: reprompt, // you include cardtitle cardcontent, will automatically incorporate // into response a simple card, e.g. tellwithcard, askwithcard. cardtitle: \" cool card title\", cardcontent: output.text, // optional (!) context additional state be persisted history context: { someadditionalinfo: \"yo\" } } // finally skillstate let nextskillstate: ask.skillstate = { id: h.generateuuid(), interaction: interaction, location: \"a1\" } return nextskillstate;}instantiate skill class call execute your index.ts handler.// create handler responds the alexa request.export var handler = async function (event, context, callback) { // create instance the bibleseeds skill. var mycoolskill = mycoolskill(app_id, db_name); // await execute. is necessary wrt callback. // async execute is convenient write, the callback actually // is called before await return. await mycoolskill.execute(event, context, callback);};'s super simplified. usage a more detailed example.api breakdownalexa-skills-kit.tstypescript typings atow (2017/05/25) json interface reference standard request types dialog directives audioplayer reference playbackcontroller referencefuncyalexaskillalexaskill descendant produces immutable(ish) skillstate based incoming stimulus.makes almost trivial implement alexa skill writing skilltransform functions. implementation class implements functions examine stimulus history. the transform applies, it creates next skillstate. otherwise returns null.e.g. transforms the amazon.helpintent be [helplocationa, helplocationb, helpdefault]. your transform, would test previous skillstate history its location. it were location \"b\", helplocationa return null, helplocationb return non-null skillstate. helpdefault not executed.plumbing is automatic.each intent ( launch request) response (outputspeech, reprompt, card info, location, etc.) is persisted a skillstate.every skillstate is stored history session.attributes. dynamo db table name is given ctor, session.attributes ( has a 24 kb max) is persisted dynamo db the current user.lexalternative-driven datae.g. 'hi' be 'hi', 'hello', 'howdy', 'yo', etc.i18ndynamic composition chunks.concatenate data paragraphs, sentences, delimited, more.upper- lowercase data demand.using chunked approach allows the alternative-driven data occur more complexsentences.e.g. \"hello, welcome my app!\", \"hi, welcome my app\", \"howdy, welcome my app\".ssmlfactory functions generating ssml tags.<speak>, <phoneme>, <emphasis>, <prosody> be used both your skill class upon retrieval, well directly your data.speechbuilderhelper class builds outputspeech objects a fluent manner.functions include text, ssml, pause, existing.existing easily weave existing outputspeech objects individual text ssml bits.dynamodbhelpersimplistic, promise-based helper class saves retrieves user's dynamorecord based user id db table name.assumes you separately created table dynamodb the given table name.alexaskillbase class contains basic plumbing an alexa skill.includes optional dynamodb persistence user information.response size is limited 24 kb. you need more, 'll need kind storage. dynamorecord interface. started the alexaskill the space geek demo code. are licensing apache 2.0. please visit license more information.since initial conversion, have adapted to typescript, locked down much it typings, added functionality. far seems be working pretty darn .helperlogging helpersuuid generationrandom helpersssml helperswrap/unwrap <speak> tags. ('t them nested)strip ssml text.phoneme, emphasis, prosody tag string factory functions.ib gib functions aop stuff tracing functions, wrapping try/catch blocks. little experimental trying remove boilerplate code.used prodigiously funcyalexaskill. class is still wip, i currently create different instances each file. would better have single service is instantiated, for it works enough my case., the tracing ib gib functions work better async/promise-based functions.installationinstall npm:npm install --save ask-gibimport es6 style:import * ask 'ask-gib';let h = ask.helper();usage - funcyalexaskill you the alexaskill class, have implement event handlers many details. you're interested docs this, let know i'll help out. you the more opinionated funcyalexaskill, your implementation isgrossly simplified. simply initialize write transforms take incomingstimulus history produce next state. of request plumbing (tracing), persistence, etc., is handled you.check biblegib see i mean:bibleseeds skill class shows how implement funcyalexaskill class.constructor takes an app id dynamo db table name ( i'm storing session dynamodb). does auto-create dynamodb table, .e. have manually create with single column userid type string.inside ctor, transformsbyname property is initialized the intent names ( launch request) mapped the corresponding transform arrays. order here is important, the transform return non-null skillstate wins (similar pattern matching). sure include transform the bare launch request, e.g. t.transformsbyname[t.getlaunchrequestname()] = [t.transformwelcome];t.transformsbyname = { \"welcomeintent\": [t.transformwelcome], \"amazon.helpintent\": [t.transformhelpblankout, t.transformhelpdefault], \"hearthewordintent\": [t.transformheartheword, t.transformhelpdefault], \"retainthewordintent\": [t.transformretaintheword, t.transformhelpdefault], \"answerintent\": [t.transformanswerwaterblankout, t.transformhelpdefault], \"idontknowintent\": [t.transformanswerwaterblankout, t.transformhelpdefault], \"answeronlyintent\": [t.transformyesintent, t.transformanswerwaterblankout, t.transformhelpdefault], \"amazon.yesintent\": [t.transformyesintent, t.transformhelpdefault], \"amazon.repeatintent\": [t.transformrepeat], \"amazon.cancelintent\": [t.transformgoodbye], \"amazon.stopintent\": [t.transformgoodbye], \"thankyouintent\": [t.transformgoodbye],}note: transformrepeat is already implemented the basic scenario \"repeat last thing just did\". just to initialize here.inside each transform function, you analyze incoming stimulus (intent usually) history. the transform applies, you your thing create next skillstate will automatically persisted the history until next incoming stimulus history. the transform does apply, return null. the transformyesintent an example this.transformyesintent: ask.skilltransform = ( stimulus: ask.stimulus, history: ask.skillstate[]): ask.skillstate => { let t = , lc = `transformyesintent`; let f = () => { let prevskillstate = t.getprevskillstate( history.filter(s => !s.interaction.context || !s.interaction.context.ishelp ) ); ( !prevskillstate || ![\"home\", \"hearing\"] .includes(prevskillstate.location) || t.getpreviousanswer(history) // cull answeronlyintent ) { // doesn't apply this transform h.log(`skipping transform...`, \"debug\", 0, lc); return null; } (prevskillstate.location === \"home\") { return t.transformheartheword(stimulus, history); } else (prevskillstate.location === \"hearing\") { return t.transformretaintheword(stimulus, history); } } let fresult = h.gib(t, f, /*args*/ null, lc); h.log(`fresult: ${json.stringify(fresult)}`, \"debug\", 0, lc); return fresult;}transforms are currently synchronous, i plan making optionallyasynchronous a promise<skillstate> | skillstate union return type.index.ts skill handler shows i'm creating async lambda handler.'ve had occasional funny blips dynamodb storage retrieving correct value a timely manner. may a race condition somewhere i haven't found yet, this be kind lambda/dynamodb thing. 'm still investigating. fixed. #13.// create handler responds the alexa request.export var handler = async function (event, context, callback) { let lc = `index handler`; h.logfuncstart(lc); try { // create instance the bibleseeds skill. var bibleseeds = bibleseeds(app_id, db_name); // await execute. is necessary wrt callback. // async execute is convenient write, the callback actually // is called before await return. await bibleseeds.execute(event, context, callback); h.logfunccomplete(lc); } catch (errexec) { h.logerror(`errexec`, errexec, lc); }};usage - lex: alternative-driven, i18n data usage lex follows basic steps:define lexdataretrieve data via lex.simplelexdataconst data: lexdata = { 'hi': [ { texts: [ \"hi\" ]} ]}lexlet lex = lex(data, \"en-\");lex._('hi').text// \"hi\"ssmlssml is as easy. this, show that can get hi object and the ssml/text will. is useful you to the ssml speech plain text cards.lexdataconst data: lexdata = { 'hi': [ { texts: [ \"hi\" ], ssmls: [ `${ssml.prosody(\"hi\", {rate: \"slow\"})}` ] } ]}lexlet lex = lex(data, \"en-\");let hi = lex._('hi')hi.ssml// '<prosody rate=\"slow\">hi</prosody>'hi.text// \"hi\"alternatives there are lot ways say \"hi\", this is primaryreason using lex: alternatives. lex, multiple items the same id are considered alternatives.lexdataconst data: lexdata = { 'hi': [ { texts: [ \"hi\" ] }, { texts: [ \"hello\" ] }, { texts: [ \"howdy\" ] } ]}lexlet lex = lex(data, \"en-\");lex._('hi').text// \"hi\", \"hello\", _or_ \"howdy\" randomly equal probability by using same calling code, could any of texts alternatives the \"hi\" lex datum. is hugedifference between natural voice interaction computer ui we known up now. you to really fancy (looking forward ai/ml), canweight various alternatives, example you to say \"howdy\" small percentage the . you define as follows:lexdataconst data: lexdata = { 'hi': [ { texts: [ \"hi\" ] }, // implicit weighting 1 { texts: [ \"hello\" ] }, // implicit weighting 1 { texts: [ \"howdy\" ], weighting: 0.2 } ]}lexlet lex = lex(data, \"en-\");lex._('hi').text// \"hi\", \"hello\", _or rarely_ \"howdy\"again, is change the calling code. really allows a wonderful layer dynamicism, is easy do.internationalization (i18n)lexdataconst data: lexdata = { 'hi': [ { texts: [ \"hi\" ] }, { texts: [ \"hello\" ] }, { texts: [ \"howdy\" ], weighting: 0.2 }, { texts: [ \"cheers\" ], language: \"en-gb\" }, { texts: [ \"guten tag\" ], language: \"de-de\" } ]}lexlet lex = lex(data, \"de-de\"); // default de-delex._('hi').text// \"guten tag\"let lex = lex(data, \"en-\"); // default en-lex._('hi', { language: \"de-de\" }).text; // choose language call// \"guten tag\"advanced advanced usage, thetests thelex jsdocs (wip)additional information the code jsdocs more information. you any questions all, don't hesitate create issue i'll glad do i to help.thanksamazon creating such documentation a product. official alexa skills kit sdk node.js is where got idea the simple dynamodb table persistence approach"
}