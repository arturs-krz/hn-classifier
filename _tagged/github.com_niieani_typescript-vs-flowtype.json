{
	"_id": "14524067",
	"site": "https://github.com/niieani/typescript-vs-flowtype",
	"title": "Differences between Flowtype and TypeScript 2.3 â€“ syntax and usability",
	"author": "tomduncalf",
	"date": "2017-06-13T14:09:47.932Z",
	"tags": {
		"categories": [
			"opensource",
			"typescript",
			"flow",
			"flowtype",
			"documentation",
			"comparison",
			"reference",
			"typing",
			"javascript-tools"
		],
		"languages": []
	},
	"content": "readme.md typescript vs flowboth typescript flow are very similar products they share of syntax some important differences. this document 've tried compile list differences similarities between flowtype typescript 2.1 -- specifically syntax, usage usability.disclaimer might incomplete /or contain mistakes.'m open contributions comments.differences usage usabilitytypescriptflowleading design goal / north staridentify errors programs through balance between correctness productivityenforce type soundness / safetyide integrationstop-notchsketchy, must save file run type-check; ides workarounds run real-speedreal-goodautocompleteboth during declaration usage for usageexpressivenessgreat (since ts @ 2.1)greattype safetyvery (7 / 10)great (8 / 10)specifying generic parameters during call-yes e.g.specifying generic parameters type definitionsyesyestypings public librariesplenty well maintained typings handful mostly incomplete typingsunique featuresautocomplete object constructiondeclarable in functions (typing somefunction.bind())large library typingsmore flexible type mapping via iterationnamespacingvarianceexistential types *testing potential code-paths types declared maximum inference$diff<, b> typetype spread operator in progressshipped >=0.42ecosystem flexibility in progress extensionsprogrammatic hookingarchitecture prepared, in progress in progressdocumentation resourcesvery docsmany booksvideose-learning resourcesincomplete, often vague docscommercial supportnoerror qualitygood some, vague other casesdifferences syntaxbounded polymorphismflowfunction foogood<t: { x: number }>(obj: t): t { console.log(math.abs(obj.x)); return obj;}typescriptfunction foogood<t extends { x: number }>(obj: t): t { console.log(math.abs(obj.x)); return obj;}referencehttps://flowtype.org/blog/2015/03/12/bounded-polymorphism.htmlmaybe & nullable typeflowlet : ?string// equvalent :let : string | null | voidtypescriptlet : string | null | undefinedoptional parameters implicitly add undefined:function f(x?: number) { }// same :function f(x?: number | undefined) { }type castingflow(1 + 1 : number);typescript(1 + 1) number;// (old version, recommended):<number> (1 + 1);mapping dynamic module namesflow.flowconfig[options]module.name_mapper='^\\(.*\\)\\.css$' -> '<project_root>/cssmodule.js.flow'cssmodule.js.flow// @flow// css modules a `classname` export is stringdeclare export var classname: string;typescriptdeclare module \"*.css\" { export const classname: string;}referencehttps://www.typescriptlang.org/docs/handbook/modules.htmlhttps://flowtype.org/docs/modules.htmlexact/partial object types default objects flow are exact ( contain more properties declared), whereas typescript are always exact (must contain declared properties).flow using flow, { name: string } means object at least name property.type exactuser = {| name: string, age: number |};type user = { name: string, age: number };type optionaluser = $shape<user>; // properties become optionaltypescripttypescript is more strict here, that you to a property is declared, must explicitly so defining indexed property. will allowed use -explicitly defined properties will to access through bracket access syntax, .e. userinstance['someproperty']. the moment, cannot define \"open\" (non-exact) types using typescript. update: possible use dotted syntax since typescript 2.2. is mostly design decision it forces to write typings upfront.type exactuser = { name: string, age: number };type user = { name: string, age: number, [otherproperty: string]: };type optionaluser = partial<{ name: string, age: number }>; // properties become optionalreferencehttps://flowtype.org/docs/objects.htmlhttps://github.com/microsoft/typescript/issues/2710importing typesflowimport type {userid, user} \"./user.js\";typescripttypescript does treat types any special when importing.import {userid, user} \"./user.js\";typeofworks same both cases, however flow has additional syntax directly import typeof:flowimport typeof {jimiguitar guitart} \"./user\";// (below works typescript)import {jimiguitar} \"./user.js\";type guitart = typeof jimiguitar;typescriptimport {jimiguitar} \"./user\";type guitart = typeof jimiguitar;accessing type a classflowclass test {};type testtype = class<test>;// should equivalent (if can confirm, please send pr):type testtype = typeof test;typescriptclass test {};type testtype = typeof test;keys/props typeflowvar props = { foo: 1, bar: '', baz: 'three',}type propstype = typeof props;type keysofprops = $enum<propstype>;function getprop<t>(key: keysofprops): t { return props[key]}typescriptvar props = { foo: 1, bar: '', baz: 'three',}type propstype = typeof propstype keysofprops = keyof propstype;function getprop<t>(key: keysofprops): t { return props[key]}recordsflowtype $record<t, u> = {[key: $enum<t>]: u}type somerecord = $record<{ : number }, string>typescripttype somerecord = record<{ : number }, string>lookup typesflowtype = { thing: string}type lookedupthing = $propertytype<, 'thing'>typescripttype = { thing: string}type lookedupthing = ['thing']mapped types / foreach propertyflowtype inputtype = { hello: string };type mappedtype = $objmap<inputtype, ()=>number>;reference:https://gist.github.com/gabro/bb83ed574690645053b815da2082b937https://twitter.com/andreypopp/status/782192355206135808typescript bit more flexibility here, you access each individual key name can combine lookup types even simple transformations.type inputtype = { hello: string };type mappedtype = { [p keyof inputtype]: number;};read- typesflowtype = { +b: string}let : a = { b: 'something' }.b = 'something-else'; // errortypescripttype = { readonly b: string}let : a = { b: 'something' }.b = 'something-else'; // error caveat makes typescript's readonly less safe is the same non-readonly property a type is compatible a readonly property. essentially means you pass object readonly properties a function expects non-readonly properties typescript not throw errors: example.\"impossible flow\" typeflowemptyfunction returnsimpossible() { throw error();}// type returnsimpossible() is 'empty'typescriptneverfunction returnsimpossible() { throw error();}// type returnsimpossible() is 'never'same syntax of syntax flow typescript is same. typescript is more expressive certain -cases (advanced mapped types keysof, readonly properties), flow is more expressive others (e.g. $diff).optional parametersflow typescriptfunction(?: string) {}typescript- conceptscall- generic parameters typescript, can create more complex behaviors, this:function maketgenerator<t>() { return function(next : () => t) { const something = next(); return something; }}const usage = maketgenerator<string>()// 'usage' is type: (next: () => string) => stringflow flow is possible define generic functions similarly the above example, only one the parameters its return type is inferrable the desired generic type, .e. cannot call method/constructor using custom t.declarable arbitrary in functions (outside objects)function something(: { hello: string }, firstarg: string) { return .hello + firstarg;}private public properties classesclass someclass { constructor(public prop: string, private prop2: string) { // transpiles : // this.prop = prop; // .prop2 = prop2; } private prop3: string;}non-null assertion operatoradd ! signify know object is non-null.// compiled --strictnullchecksfunction validateentity(e: entity?) { // throw exception e is null invalid entity}function processentity(e: entity?) { validateentity(e); let s = e!.name; // assert e is non-null access name}flow- conceptsdifference typestype c = $diff<{ : string, b: number }, { : string }>// c is { b: number}note however $diff is an official feature. only works properly lower bound, .e. can assign something it, can't it that.(source]typescript has proposal an equivalent.inferred existential types* a type a generic parameter signifies the type-checker infer type possiblearray<*>typescript has proposal an equivalent (needs link).variancehttps://flowtype.org/docs/variance.htmlfunction getlength(o: {+p: ?string}): number { return o.p ? o.p.length : 0;}typescript proposalbivariance is among design decisions driving typescript.flow's \"mixed\" type typescript equivalent the mixed type is simply:type mixed = {}reference: https://flowtype.org/docs/quick-reference.html#mixeduseful referenceshttps://github.com/microsoft/typescript/issues/1265undocumented flow modifiers https://github.com/facebook/flow/issues/2464http://sitr./2015/05/31/advanced-features--flow.html"
}