{
	"_id": "14482215",
	"site": "https://github.com/Bloomca/redux-tiles",
	"title": " Redux-Tiles â€“ library to deal with verbosity of Redux",
	"author": "bloomca",
	"date": "2017-06-13T13:04:45.754Z",
	"tags": {
		"categories": [
			"opensource",
			"redux",
			"typescript",
			"redux-modules",
			"state-management",
			"redux-tiles",
			"selector",
			"redux-middleware"
		],
		"languages": [
			"typescript",
			"javascript"
		]
	},
	"content": "readme.md redux-tilesdocumentationredux is awesome library keep state management sane scale. problem, though, is it is toooo verbose, often 'd feel you are doing literally same thing again again. library tries provide minimal abstraction top redux, allow easy composability, easy async requests, sane testability. is possible start using library existing project, adding functionality gradually.more rationale behind libraryexamplescalculatortodomvchacker news apigithub apiinstallation install latest stable version, run:npm install --save redux-tiles package was built the idea mind, people use usually using bundling tool webpack, browserify rollup. package itself is written typescript, therefore provides typings of box. you some reason don't bundler, can umd builds, are located dist folder. include in page via script tag, then will it under window.reduxtiles global variable.toc:example userationaleintegration apitiles apinestingmiddlewareserver-side renderingselectorstestsexample usemore comprehensive exampleimport { createtile, createsynctile } 'redux-tiles';// sync tile store information without async stuffconst loginstatus = createsynctile({ type: ['user', 'loginstatus'], fn: ({ params: status }) => ({ status, timestamp: date.(), }),});// request the server// is absolutely separated, it is very easy// compose different requestsconst authrequest = createtile({ type: ['user', 'authrequest'], // have access dispatch, actions, selectors, etc // can pass what need creating middleware // allows to test easier, also compose tiles fn: ({ params, api, dispatch, actions, getstate }) => api.post('/login', params),});// actual business logic// note we don't direct `api` calls here// just compose basic tilesconst authuser = createtile({ type: ['user', 'auth'], fn: async ({ params, dispatch, actions, selectors, getstate }) => { // login user await dispatch(actions.tiles.user.authrequest(params)); // check result const { data: { id }, error } = selectors.tiles.user.authrequest(getstate()); (error) { throw error(error); } // set synchronously user status dispatch(actions.tiles.user.loginstatus({ true })); return true; },});rationale are enough projects around keep state management clean ( example), they are mostly organizing, rather removing burden repetitive stuff the developer. packages offer full-fledge integration rest-api, normalizing entities, building relations between models, etc. is nothing this here fact, you need something this, the ability query local \"database\", highly advise to create own solution, will custom-tailored your specific problem. package focuses very basic blocks, are for pretty simple applications (e.g. login/logout, fetch client data, set calculator values).integration apidespite being easy--use package write modules, 'd to some to integrate into project. a nutshell, have have middleware will handle returned functions dispatched actions ( is provided this package, redux-thunk suffice well), then have combine modules create actions & reducers. is better see a small example:import { createtile, createentities, createmiddleware } 'redux-tiles';import { createstore, applymiddleware } 'redux';const clientdatatile = createtile({ type: ['client', 'data'], fn: ({ api, params}) => api.('/client/info'),});const tiles = [ clientdatatile,];const { actions, reducer, selectors } = createentities(tiles);// inject `actions` `selectors` middleware, they// be available inside `fn` function all tilesconst { middleware } = createmiddleware({ actions, selectors });createstore(reducer, applymiddleware(middleware));tiles apitiles are heart this library. are intended be very easy use, compose to test. are types tiles asynchronous synchronous. modern applications are very dynamic, async ones be likely used more often. , don't constrain yourself the mindset async tiles are for api communication might anything, involves asynchronous interaction ( well composing tiles) instance, long polling implementation.full documentation async tilesimport { createtile } 'redux-tiles';const photos = createtile({ // will structured api.photos inside redux state, // also available under actions selectors : // actions.tiles.api.photos type: ['api', 'photos'], // params is object which dispatch action // can pass one parameter, keep as object // different properties // // other properties are your middleware // fn expects promise of function fn: ({ params, api }) => api.('/photos', params), // nest data: // { 5: // 10: { // ispending: true, // data: null, // error: null, // }, // }, // you save under same nesting array, data be replaced // branches be merged nesting: (params) => [params.page, params.count], // unless will invoke second parameter object asyncforce: true, // won't requested again // dispatch(actions.tiles.api.photos(params, { asyncforce: true })) caching: true,}); also sometimes to keep sync info (e.g. list notifications), we to store numbers calculator, active filters (todomvc is good example a lot synchronous operations). this situation will createsynctile, has meta data ispending error, keeps returned data a function directly state.full documentation sync tilesimport { createsynctile } 'redux-tiles';const notifications = createsynctile({ type: ['notifications'], // parameters are same in async tile fn: ({ params, dispatch, actions }) => { // can dispatch async actions we 't wait // it inside sync tiles dispatch(actions.tiles.user.dismissterms()); return { type: params.type, data: processdata(params.data), }; }, // alternatively, you perform actions existing data, // might useful write more declarative actions // have exactly same signature dispatch returned data // the tile fns: { add: ({ params, selectors, getstate}) => { const currentdata = selectors.notifications(getstate(), params); return { ...currentdata, data: currentdata.concat(params.data), }; }, }, // can pass initial state sync tile // please, careful it! you nesting, // you to specify nested items (otherwise selectors // return undefined your nested item) initialstate: { terms: { type: 'terms', data: [] }, }, // nesting works same nesting: ({ type }) => [type],});nestingvery often have separate info, with canonical redux have write something this:case action.some_constant: return { ...state, [action.payload.id]: { [action.payload.quantity]: { ...state[action.payload.id], ...action.payload.data, }, }, }; with object.assign, will it less readable. is pretty common pattern, also pretty error prone we to cover such code unit-tests, while reality don't a lot intrinsic logic merge. course, can something lodash.merge, it is always suitable. tiles have nesting property, which can specify function which can return array nested values. same code above:const infotile = createtile({ type: ['info', 'storage'], // params here in nesting are same object fn: ({ params: { quantity, id }, api }) => api.('/storage', { quantity, id }), // the state will kept the following structure: // { // someid: { // 5: { // ispending: true, // data: null, // error: null, // }, // }, // } nesting: ({ quantity, id }) => [id, quantity],});middleware order use library, have apply middleware, will handle functions returned dispatched actions. very basic is provided this package:full documentation middlewareimport { createmiddleware } 'redux-tiles';// are required, adding allows // to dependency injection pattern, it is easier testimport actions '../actions';import selectors '../selectors';// is good idea put api layer inside middleware, // you easily separate client server, instanceimport api '../utils/api';// object is optional. every property be available inside// `fn` all tiles// , `waittiles` is helpful server-side-renderingconst { middleware, waittiles } = createmiddleware({ actions, selectors, api });applymiddleware(middleware);, redux-thunk is supported, in order pass own properties should inject object redux-thunk. , there is nothing bad just import actions selectors top the files, then testing might require much more mocking, can your tests more brittle.server-side renderingredux-tiles support requests the server side. order do correctly, are supposed create actions each request node.js. redux-tiles has caching async requests ( keeps inside middleware, they are shared between different user requests) keeps list all active promises, you might accidentaly share part the memory other users!, to this part functionality working, have use redux-tiles middleware, pass promisesstorage object redux-thunk additional object (more caching section docs).import { createmiddleware, createentities } 'redux-tiles';import { createstore, applymiddleware } 'redux';import tiles '../../common/tiles';const { actions, reducer, selectors } = createentities(tiles);const { middleware, waittiles } = createmiddleware({ actions, selectors });const store = createstore(reducer, {}, applymiddleware(middleware));// is futile render. is needed to kickstart requests// unfortunately, is way avoid renderapplication(req);// wait all requests were fired during renderawait waittiles();// time can safely render application requests// were `componentwillmount` be fullfilled// remember, `componentdidmount` is fired the serverres.send(renderapplication(req)); is a package delounce, where can limit function, will render application requests are taking too long.selectors tiles provide selectors. you've collected tiles, invoke createselectors function possible change default namespace, after can use based the passed type:import { createtile, createselectors } 'redux-tiles';const tile = createtile({ type: ['user', 'auth'], fn: ..., nesting: ({ id }) => [id],});const tiles = [tile];const selectors = createselectors(tiles);// second argument is params which dispatch action will data// corresponding nestingconst { ispending, data, error } = selectors.user.auth(state, { id: '456' });testsalmost business logic be contained \"complex\" tiles, don't requests themselves, rather dispatching tiles, composing results them. is very important pass needed functions via middleware, you easily mock without relying other modules. passed data is available tiles via reflect property.import { createtile } 'redux-tiles';const params = { type: ['auth', 'token'], fn: ({ api, params }) => api.post('/token', params),};const tile = createtile(params);// same objectassert(tile.reflect === params); // truecontributing suggestions participating are welcome! , if have idea improving api, bringing common functionality, don't hesitate, please create issue!licensemit"
}