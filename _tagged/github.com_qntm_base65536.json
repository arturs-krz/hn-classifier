{
	"_id": "14468818",
	"site": "https://github.com/qntm/base65536",
	"title": "Base65536 encoding",
	"author": "rahiel",
	"date": "2017-06-13T13:55:02.102Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript",
			"typescript"
		]
	},
	"content": "readme.md base65536base65536 is binary encoding optimised utf-32-encoded text twitter. javascript module, base65536, is first implementation this encoding.efficiency ratings are averaged long inputs. higher is better.encodingimplementationefficiencyutf8utf16utf32asciiconstrainedunarybase10%0%0%binaryeverywhere13%6%3%hexadecimaleverywhere50%25%13%base64everywhere75%38%19%base85everywhere80%40%20%bmpconstrainedhexagramencodehexagram-encode25%38%19%brailleencodebraille-encode33%50%25%base32768base3276863%94%47%full unicodebase65536base6553656%64%50%base131072base131072 (prototype)53%+53%+53% example, using base64, to 105 bytes binary data fit a tweet. base65536, 280 bytes are possible.base65536 uses \"safe\" unicode code points - unassigned code points, whitespace, control characters, etc.. details how code points were selected why are thought be safe, the sibling project base65536gen.installationnpm install base65536usagevar base65536 = require('base65536');var buf = buffer.('hello world', 'utf-8'); // 11 bytesvar str = base65536.encode(buf); console.log(str); // 6 code points, ''var buf2 = base65536.decode(str);console.log(buf.equals(buf2)); // trueapibase65536.encode(buf)encodes buffer returns base65536 string, suitable passing safely through almost \"unicode-clean\" text-handling api. string contains special characters is immune unicode normalization. string encodes bytes per code point.notewhile might expect the length the resulting string is half length the original buffer, is true counting unicode code points. javascript, string's length property reports the number code points the number 16-bit code units the string. characters outside the basic multilingual plane, surrogate pair 16-bit code units is used represent each code point. base65536 makes extensive of characters: 37,376, about 57%, the 65,536 code points are chosen these supplementary planes. a worked example:var buf = buffer([255, 255]); // bytesvar str = base65536.encode(buf); // \"\", code point, u+285ffconsole.log(str.length); // 2, 16-bit code unitsconsole.log(str.charcodeat(0)); // 55393 = 0xd861console.log(str.charcodeat(1)); // 56831 = 0xddffconsole.log(str === '\\ud861\\uddff'); // truebase65536.decode(str[, ignoregarbage])decodes base65536 string returns buffer containing original binary data. default function is very strict, no tolerance whitespace other unexpected characters. error is thrown the supplied string is a valid base65536 text, if is \"final byte\" code point the middle the string. set ignoregarbage true ignore non-base65536 characters (line breaks, spaces, alphanumerics, ...) the input.more examplesvar hash = md5(''); // \"d41d8cd98f00b204e9800998ecf8427e\", 32 hex digitsvar buf = buffer(hash, 'hex'); // <buffer d4 1d ... 7e>console.log(base65536.encode(buf)); // \"\", 8 charsvar uuid = '8eb44f6c-2505-4446-aa57-22d6897c9922'; // 32 hex digitsvar buf = buffer(uuid.replace(/-/g, ''), 'hex'); // <buffer 8e b4 ... 22>console.log(base65536.encode(buf)); // \"\", 8 charsvar address6 = require('ip-address').address6;var address = address6('2001:db8:85a3::8a2e:370:7334'); // 32 hex digitsvar buf = buffer(address.tobytearray()); // <buffer 20 01 ... 34>console.log(base65536.encode(buf)); // \"\", 8 charswhy?erm. wanted to able share hatetris replays via twitter.twitter supports tweets up 140 characters. \"tweet length is measured the number codepoints the nfc normalized version the text.\"hatetris has four buttons: left, right, down rotate. single move hateris therefore encodes bits information. present, replays are encoded hexadecimal spaced legibility/selectability. although game hatetris may extend an arbitrary number keystrokes (simply press rotate forever), general, longer game goes , the higher 's score. world record hatetris replay (30 points) is 1,440 keystrokes = 2,880 bits long. present, hatetris replays are encoded hexadecimal, each hexadecimal digit encoding 4 bits = 2 keystrokes, spaces added clarity/legibility, presented text, so:c02a aaaa aaab 00aa aaaa ac08 aaaa aac2 aaaa aaaa c2aa aaaa aeaa aaaa aa56aaaa aaaa b55a aaaa aa96 aaaa aaaa d5aa aaaa a9aa aaaa aab5 aaaa aaaa aaaaaaaa daaa aaaa 9756 aaaa aa8a aaaa aaab aaaa aaab 5aaa aaab 56aa aaaa aaaaa82a aaaa b00a aaaa a6d6 ab55 6aaa aaa9 4aaa aaa6 aaaa ad56 aaaa b56a aaaa032a aaaa a65b f00a aaaa aa6e efc0 2aaa aaaa eb00 aaaa aaa8 0aaa aaaa 802aaaaa aa54 aaaa aaa1 aaaa aaa0 aaaa aaa0 0aaa aaaa c02a aaaa b002 aaaa b00aaaac 2aaa aab0 aaaa aeaa aaa9 5aaa aaa9 d5aa aaa5 aaaa aab5 6aaa a6aa aaab5aaa aaaa aaaa daaa aad5 56aa aa2a aaaa baaa aad6 aaab 56aa aaaa 82aa ac02aaa7 b5aa d556 aaaa 52aa a6aa b55a ab56 aa80 fcaa aaa5 583f 0aaa a9bb bf00aaaa ae80 32aa aa82 faaa a802 aaaa 96aa aa1a aaa8 2aaa a00a aaab 00aa ab00aab0 aaab 0aab aaa9 5aaa ad56 aa5a aab5 6aac 02a9 aaab 5aaa aaad aab5 5aa2aaae aa0a aab2 aad5 6ab5 aa02 aaa0 0aaa b55a ad6a baac 2aab 0aa0 c2aa c02a's 899 characters including spaces, 720 characters the spaces were removed. were hexadecimal characters converted binary, would 360 bytes, were binary expressed base64, would 480 characters.using elementary run-length encoding, two bits keystroke two bits run length, get down 2040 bits. 's 255 bytes, is still 340 characters base64. in base65536 is 128 code points! much better. fits comfortably a tweet, an extravagant 12 characters left for comment. of course, worse are hatetris, shorter replay is, the more room have invective.unicode has 1,114,112 code points, of we aren't using. we further? yet. encode additional bit per character, 140 additional bits (37.5 additional bytes) per tweet, need double number code points use 65,536 131,072. would a encoding, base131072, its utf-32 encoding efficiency be 53% vs. 50% base65536. (note in utf-16, base32768 significantly outperforms either choice, in utf-8, base64 remains preferred choice.)however, of unicode 8.0, base65536gen returns 92,240 safe characters the \"letter, \" general category. modifying to add safe general categories ( the letter, number symbol gcs) yields 101,064 safe characters. similar calculation unicode 9.0 is forthcoming the numbers still aren't high enough.perhaps future versions unicode assign more characters make possible.licensemit other languagesseveral have ported base65536 javascript other programming languages.pythonrubyphpcrustc#"
}