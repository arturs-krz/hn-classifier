{
	"_id": "14527347",
	"site": "https://github.com/reactive-react/xreact",
	"title": "Xreact â€“ A Functional Reactive State Wrapper for React Components",
	"author": "oyanglulu",
	"date": "2017-06-13T14:09:47.864Z",
	"tags": {
		"categories": [
			"opensource",
			"react",
			"reactive",
			"frp",
			"rxjs",
			"react-components",
			"higher-order-component",
			"transducers",
			"functional-programming",
			"functional-reactive-programming",
			"flux-architecture",
			"redux",
			"react-most",
			"mostjs",
			"typescript"
		],
		"languages": [
			"typescript",
			"shell"
		]
	},
	"content": "readme.md | examples | best practices | wikixreact functional reactive state wrapper react componentsformerly as react-, renamed because mostjs is madatory anymore.installnpm install xreact --save# yarn add xreactxreact is lightweight higher order state component react.data flow xreact is simple unidirectional, similar flux.terminologymachine: machine emit update a timeline update$, can operated calling function actionsplan: plan is function describe to create machineupdate: function currentstate -> nextstateaction: function create instance intentintent: describe you to intent stream: timeline every intent created every actionquick startsorry don't a book document to xreact, i don't really need ,there's 3 things should notice using xreact, 'll explain a simple counter app., you refer more documents here:1. define simple stateless view componentconst counterview = ({actions, count}) => ( <div> <button onclick={actions.dec}>-</button> <span>{count}</span> <button onclick={actions.inc}>+</button> </div>)every view component expected actions fields props2. define plan we a pretty view represention inteacting interface, can define to update view, \"how react actions\". such case: counter have actions inc dec, will send intent {type: 'inc'} {type:'dec'} intent stream upon being called. counter reactively generates update it receives intent either type inc dec.const plan = (intent$) => { return { update$: intent$.map(intent => { switch (intent.type) { case 'inc': return state => ({ count: state.count + 1 }); case 'dec': return state => ({ count: state.count - 1 }); default: return _ => _; } }), actions: { inc: () => ({ type: 'inc' }), dec: () => ({ type: 'dec' }) } }} plan take intent$(intent stream) return machine. machine defines you act the machine the machine react intents.3. plan x viewimport {render} 'react-dom'import x, {x} 'xreact/lib/x'import * rx 'xreact/lib/xs/rx'const counter = x(plan)(counterview)render( <x x={rx}> <counter /> </x>, document.getelementbyid('app'));counter is product(x) plan counterview, means can react intent it's plan, update counterview<x></x> provide intent$ instance.featuresinspired redux functional reactive programming, xreact allows to model user events, actions, data reactive streams. you map, filter, compose, subscribe those streams your application's state.purely functional, declarative, monadic imperatively written code, describe step--step to process data. xreact, simply define data transformations, compose to form data flow. are variables, intermediate state, no side effects your data flow's data composition!typesafe scalablerewritten typescript, abstract stream higher kind type easier bring frp lib integrete xreact.composable reusable plan redux, reducers' of switch statements make difficult compose. unlike reducers, function x return is simply function can easily compose.const counter = x(plan1)(x(plan2)(counterview))// is same const plan1_x_plan2_x = compose(x(plan1), x(plan2))const counter = plan1_x_plan2_x(counterview) really happen behind compose is actually es6 style mixin, there won't any extra layer hoc no performance overhead.easy test, need mocks ui ui behavior are loosely coupled, can test react component just passing data. behaviors be tested calling actions then verifying state.import {mount} 'enzyme'import * rx 'xreact/lib/xs/rx'import {rx xtest} 'xreact/lib/xtests'const mountx = compose(mount, c => react.createfactory(x)({ x: rx }, c))let counterx = mountx( <counter />) let counter = counterx.find(counter).getnode()let counterview = counterx.find(counterview)let actions = counterview.prop('actions')('add intent intent$ go through sink$', () => { return xtest .([ actions.inc, actions.inc, actions.inc, ]) .collect(counter) .(state => expect(state.count).tobe(3))}) more details testing examples https://github.com/reactive-react/xreact/blob/master/src/__tests__/xtest.tsxasync actions made easyasynchronous functions, such promises, be converted a stream then flat-mapped.import {observable} '@reactivex/rxjs/observable'...intent$.filter(x=>x.kind=='rest') .flatmap(({url}) => observable.frompromise(rest(url))) .map(...)... rest(url) return promise,higher level extract ready any frp libraryxreact came 2 frp libs choice, rxjs mostjs, any lib only need implement staticstream your prefered lib higher kind type.more details hkt implementation typescript is herefaq it's different redux?unlike redux, xreact turn frp 11 react, model problem different\"global\" intent stream(using redux's word should intent store) global state store's such thing state store, state store anywhere, state transformationsfrp lib your choice, choose lib familiar how 's different cycle.js? xreact a more specify optimized cycle for react.why global state?global is state is scalable, it a database, every component query data it,however, database are hard scale, design maintain.instead making state global, think better choice doing such reversely, have you to (intent) globally instead. , every component just broadcast it's trying do, only focus how reduce intent a state transformation it self. this case, component won't need worry how global state structure, just focus itself. , components are more modular decoupled.furher more, 's composable, can build small x component constructors compose at to create bigger powerfult component constructors. 's much easier flexible compose small behavior state a big component, destruct big global state small components.thanks ...rxjsreactreduxomcycletransdux<script>(function(w,d,s,l,){w[l]=w[l]||[];w[l].push({'gtm.start': date().gettime(),event:'gtm.js'});var f=d.getelementsbytagname(s)[0],j=d.createelement(s),dl=l!='datalayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='++dl;f.parentnode.insertbefore(j,f);})(window,document,'script','datalayer','gtm-msmnj7d');</script>"
}