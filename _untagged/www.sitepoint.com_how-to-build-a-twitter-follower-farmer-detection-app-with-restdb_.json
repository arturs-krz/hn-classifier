{
	"_id": "14451407",
	"site": "https://www.sitepoint.com/how-to-build-a-twitter-follower-farmer-detection-app-with-restdb/",
	"title": " How to build a Twitter Follower Farmer detection app with restdb.io",
	"author": "knutmartin",
	"date": "2017-06-16T07:57:14.311Z",
	"tags": [],
	"content": "courses books community logincreate free account * html & css * javascript * php * ruby * design & ux * entrepreneur * web * wordpress * seo woorank * microsoft tech× * html & css * javascript * php * ruby * mobile * design & ux * entrepreneur * web * wordpress * java * seo woorank * themes * podcast * books * courses * newsletters * versioning * forums * advertise * contribute * contact * our story * 995k subscribers * 132k followers * 80k followers php article bruno skvorc may 26, 2017 to build twitter follower-farmer detection app restdb bruno skvorc article was sponsored byrestdb. thank for supporting partners make sitepoint possible. more this author * family crms, guzzle wrappers php machine learning? sourcehunt! * to set an online multi-language magazine sulu * getting started sulu cms vagrant right are active twitter? so, you often wonder why accounts seem follow only unfollow moments ( days) later? s probably something said re follower farming. follower farming is known social media hack taking advantage people #followback soon someone follows . the big brands, celebs, wannabe celebs advantage this, it keeps followers count high following count low, turn making look popular. this post, ll build app lets log via twitter, grabs followers, compares last fetched follower list a refreshed list order identify new unfollowers calculate duration their follow, potentially auto-identifying farmers.bootstrapping usual, ll using homestead improved a high quality local environment setup. feel free use own setup instead youve got you feel comfortable .git clone https://github.com/swader/homestead_improved hi_followfarmerscd hi_followfarmersbin/folderfix.shvagrant ; vagrant sshonce vm has been provisioned we find ourselves inside , lets bootstrap laravel app.composer create-project --prefer-dist laravel/laravel code/projectcd code/projectlogging with twitter make logging with twitter possible, ll the socialite package.composer require laravel/socialite per instructions, should register in config/app.php:'providers' => [ // service providers... laravel\\socialite\\socialiteserviceprovider::class,],'socialite' => laravel\\socialite\\facades\\socialite::class,finally, need register new twitter app http://apps.twitter.com/app/ and add secret credentials config/services.php: 'twitter' => [ 'client_id' => env('twitter_client_id'), 'client_secret' => env('twitter_client_secret'), 'redirect' => env('twitter_callback_url'), ],naturally, need add environment variables the .env file the root the project:twitter_client_id=keykeykeykeykeykeykeykeykeytwitter_client_secret=secretsecretsecrettwitter_callback_url=http://homestead.app/auth/twitter/callback need add login routes routes/web.php next:route::('auth/twitter', 'auth\\logincontroller@redirecttoprovider');route::('auth/twitter/callback', 'auth\\logincontroller@handleprovidercallback');finally, lets add methods routes refer into logincontroller class inside app/http/controllers/auth: /** * redirect user the github authentication page. * * @return response */ public function redirecttoprovider() { return socialite::driver('twitter')->redirect(); } /** * obtain user information github. * * @return response */ public function handleprovidercallback() { $user = socialite::driver('twitter')->user(); dd($user); } dd($user); is to easily test the authentication went , and sure enough, you visit /auth/twitter, should able authorize app see basic information your account screen:follower lists are many ways getting accounts follower list, none them pleasant. twitter still hates developersever since twitters great war developers (spoiler: very little has changed since article came ), its been outright nightmare fetch full lists peoples followers. fact, api rate limits are low people resorted third party data aggregators actually buying data, even scraping followers page. ll the white hat route suffer through api, if have means getting followers, feel free use instead the method outlined below. twitter api offers /followers/list endpoint, as one returns 20 followers per call most, only allows 15 requests per 15 minutes, would able , at , extract 1200 followers per hour unacceptable. instead, ll the followers/ids endpoint fetch 5000 ids a . this is subject the same limit 15 calls per 15 minutes, gives much more breathing room.s important keep mind id != twitter handle. ids are numeric values representing unique account across , even across different handles. for each unfollowers id, ll to an additional api call find who were ( users lookup bulk api come handy).basic api communicationsocialite is useful logging . actually communicating the api is less straightforward. given laravel comes guzzle pre-installed, installing guzzles oauth subscriber ( lets use guzzle the oauth1 protocol) is simplest solution:composer require guzzlehttp/oauth-subscriberonce s there, can update logincontroller::handleprovidercallback method test things : public function handleprovidercallback() { $user = socialite::driver('twitter')->user(); $stack = handlerstack::create(); $middleware = oauth1([ 'consumer_key' => getenv('twitter_client_id'), 'consumer_secret' => getenv('twitter_client_secret'), 'token' => $user->token, 'token_secret' => $user->tokensecret ]); $stack->push($middleware); $client = client([ 'base_uri' => 'https://api.twitter.com/1.1/', 'handler' => $stack, 'auth' => 'oauth' ]); $response = $client->('followers/ids.json', [ 'query' => [ 'cursor' => '-1', 'screen_name' => $user->nickname, 'count' => 5000 ] ]); dd($response->getbody()->getcontents()); } the above code, first create middleware stack will chew through request, pull through the middlewares, output final version. can push middlewares this stack, for , we need oauth1 .next, create oauth1 middleware pass the required parameters. first weve already got re keys defined .env previously. last we got the authenticated twitter user instance. then push middleware the stack, attach stack onto guzzle client. laymans terms, means this client does requests, pull requests through the middlewares the stack before sending to final destination. also tell client always authenticate oauth.finally, make get call the api endpoint the required query params: page start (-1 is first page), user whom pull followers, how many followers pull. the end, die output onto screen see were getting we need. sure enough, heres 5000 the recent followers my account: that know api calls are passing we talk twitter, s for loops get full list the current user. php side getting followerssince are 15 calls per 15 minutes allowed via api, lets limit account size 70k followers now simplicity. $user = socialite::driver('twitter')->user(); ($user->user['followers_count'] > 70000) { return view( 'home.index', ['message' => 'sorry, currently support accounts up 70k followers'] ); }note: home.index is arbitrary view file made for example, containing single directive: {{ $message }}., lets iterate through next_cursor_string value returned the api, paginate through ids. much numbers, very follow, wow. some luck, should execute very quickly depending twitters api responsiveness.everyone up 70k followers now a full list followers generated upon authorization. we needed support bigger accounts, would relatively simple make repeat process every 15 minutes ( the api limit resets) every 75k followers, stitch results together. course, someone is almost guaranteed follow/unfollow that window given number followers, it be very hard stay accurate. those cases, s easier focus the last 75k followers only analyze those ( api auto-orders last-followed), to find another method reliably fetching followers, bypassing api.cleaning its bit awkward have logic the logincontroller, lets move into separate service. created app/services/followers/followers.php this example, the following contents:<?phpnamespace app\\services\\followers; guzzlehttp\\client; guzzlehttp\\handlerstack; guzzlehttp\\subscriber\\oauth\\oauth1;class followers{ /** @var string */ protected $token; /** @var string */ protected $tokensecret; /** @var string */ protected $nickname; /** @var client */ protected $client; public function __construct(string $token, string $tokensecret, string $nickname) { $->token = $token; $->tokensecret = $tokensecret; $->nickname = $nickname; $stack = handlerstack::create(); $middleware = oauth1( [ 'consumer_key' => getenv('twitter_client_id'), 'consumer_secret' => getenv('twitter_client_secret'), 'token' => $->token, 'token_secret' => $->tokensecret, ] ); $stack->push($middleware); $->client = client( [ 'base_uri' => 'https://api.twitter.com/1.1/', 'handler' => $stack, 'auth' => 'oauth', ] ); } public function getclient() { return $->client; } /** * returns array follower ids a given optional nickname. * * no custom nickname is provided, one used during construction * this service is used, usually defaulting the same user authing * application. * * @param string|null $nickname * @return array */ public function getfollowerids(string $nickname = null) { $nickname = $nickname ?? $->nickname; $response = $->client->( 'followers/ids.json', [ 'query' => [ 'cursor' => '-1', 'screen_name' => $nickname, 'count' => 5000, ], ] ); $data = json_decode($response->getbody()->getcontents()); $ids = $data->ids; while ($data->next_cursor_str !== \"0\") { $response = $->client->( 'followers/ids.json', [ 'query' => [ 'cursor' => $data->next_cursor_str, 'screen_name' => $nickname, 'count' => 5000, ], ] ); $data = json_decode($response->getbody()->getcontents()); $ids = array_merge($ids, $data->ids); } return $ids; }} can clean the logincontrollers handleprovidercallback method: public function handleprovidercallback() { $user = socialite::driver('twitter')->user(); ($user->user['followers_count'] > 70000) { return view( 'home.index', ['message' => 'sorry, currently support accounts up 70k followers'] ); } $flwrs = followers( $user->token, $user->tokensecret, $user->nickname ); dd($flwrs->getfollowerids()); }s still wrong method be doing , so lets further improve things. keep user logged , lets save token, secret, nickname the session. /** * and store token data authorized user. * * @param request $request * @return response */ public function handleprovidercallback(request $request) { $user = socialite::driver('twitter')->user(); ($user->user['followers_count'] > 70000) { return view( 'home.index', ['message' => 'sorry, currently support accounts up 70k followers'] ); } $request->session()->put('twitter_token', $user->token); $request->session()->put('twitter_secret', $user->tokensecret); $request->session()->put('twitter_nickname', $user->nickname); $request->session()->put('twitter_id', $user->id); return redirect('/'); } save the information the session, making user effectively logged to application, then redirect the home page.lets create new controller , and it simple method use:artisan :controller homecontroller<?phpnamespace app\\http\\controllers; illuminate\\http\\request;class homecontroller extends controller{ public function index(request $request) { $nick = $request->session()->('twitter_nickname'); (!$nick) { return view('home.loggedout'); } return view('home.index', $request->session()->()); }}simple, right? views are simple, too:{{--index.blade.php--}}<h1>followerfarmers</h1><h2>hello, {{ $twitter_nickname }}! you? < href=\"/logout\">log !</a></h2><p> bet 'd to your follower stats, wouldn't ?</p>{{--loggedout.blade.php--}}<h1>followerfarmers</h1><h2>hello, stranger!</h2><p>'re currently logged . how you < href=\"/auth/twitter\">log with twitter </> to started?</p>ll need add routes routes/web.php, too:route::('/', 'homecontroller@index');route::('/logout', 'auth\\logincontroller@logout'); this, can check were logged , and can easily log .note for security, logout route should accept post requests csrf tokens simplicity during development, re taking get approach revamping later.admittedly, s the prettiest thing look , but re building demo here real thing get visually polished once logic is done.registering service providers common practice register service provider easier access later , so lets that. service t instantiated without token secret (.e. before user logs with twitter) well need make deferred other words, ll get created needed, well sure dont need until have those values.artisan :provider followerserviceprovider<?phpnamespace app\\providers; app\\services\\followers\\followers; illuminate\\support\\serviceprovider;class followerserviceprovider extends serviceprovider{ protected $defer = true; public function register() { $->app->singleton( followers::class, function ($app) { return followers( session('twitter_token'), session('twitter_secret'), session('twitter_nickname') ); } ); } public function provides() { return [followers::class]; }} we put simple count echo our logged view:{{ count($ids) }} modify homecontroller now this serviceprovider:... return view( 'home.index', array_merge( $request->session()->(), ['ids'=> resolve(followers::class)->getfollowerids()] ) ); then test, sure enough, works.database that have neat service extract follower lists , we should probably save somewhere. could save into local mysql database, even flat file, for performance portability, went something different time: restdb. restdb is plug play hosted database service s easy configure use, freeing your choices hosting platform. not needing database writes a local filesystem, can easily push app the were building google cloud engine heroku. the help its templates, can instantly set a blog, landing page, web form, log analyzer, a mailing system heck, service supports markdown inline field editing, letting practically a markdown-based blog right on service.restdb has free tier, the month is virtually limitless you thoroughly test . the database m developing on is a basic plan (courtesy the restdb team).setting restdbunlike other database services, restdb s important consider record number limits. basic plan offers 10000 records, would quickly exhausted we saved follower each logged user a separate entry, even list followers each user a separate entry per 15 minute timeframe. s why chose following plan: * each user be record the accounts collection. * each follower list be record the follower-lists collection will a child record accounts. * a maximum rate every 15 minutes ( more user takes longer come and log the app), new list be generated, compared the last , and new list along a diff towards last will saved. * every user be able keep most 100 histories said, lets create new follower-lists collection per quick-start docs. once collection has been created, lets add fields: * required followers text field. text field supports regular expression validations, since re going use comma separated list store follower ids, can apply regex this to sure data is always valid: ^(\\d+,\\s?)*(\\d+)$. will match lines comma separated digits, without trailing comma. can it action here. * diff_new field text type, will contain list new followers since last entry. same regex restriction for followers apply, updated be optional, becausge sometimes will no difference compared the last entry: (^(\\d+,\\s?)*(\\d+)$)?. * diff_gone field text type, will contain list unfollowers since last entry. same regex restriction for diff_new apply. collection should like :now lets create parent collection: accounts.note: may wondering why dont use built- users collection. is that collection is meant authenticating auth0 users. fields are there be useful us, as per docs, have write access that database, we need . so why just with auth0 logins restdb data? feel free that approach personally feel depending one third party service a crucial part my app is enough, would too much me. fields need are: * twitter_id, twitter account id the user. required number. * settings, required json field. will hold the users account-specific settings, refresh interval, emailing frequency, etc. adding , lets add new follower_lists field, define as child relation our follower-lists collection. under properties, should pick child . the naming is little confusing despite option saying child follower-lists, is follower-lists is child. may noticed havent used timestamp fields anywhere, created_at. s restdb automatically creates for every collection, along some fields. inspect those system fields, click show system fields option the top right corner each collections settings table:getting fields a payload querying database requires to the ?metafields=true param the api urls. are ready start combining php restdb side.saving and reading restdb be able interact restdb, need api key. can it following instructions here. options should left the default value, all rest methods enabled. key should be saved .env:restdb_key=keykeykey idea accounts is follows: * the user authorizes twitter, app read accounts collection the twitter id provided, if doesnt exist, will write new entry. * user is redirected the welcome screen, will contain message confirming account creation one was created, offer redirect the /dashboard.lets make restdb service talking the database.<?php// services/followers/restdb.phpnamespace app\\services\\followers; guzzlehttp\\client; guzzlehttp\\clientinterface; psr\\http\\message\\responseinterface;class restdb{ /** @var clientinterface */ protected $client; /** * sets guzzle client be used * * @param clientinterface $client * @return $ */ public function setclient(clientinterface $client) { $->client = $client; return $; } /** * @return clientinterface */ public function getclient() { return $->client; } /** * configures default guzzle client it doesn't need be injected * @return $ */ public function setdefaultclient() { $client = client([ 'base_uri' => 'https://followerfarmers-00df.restdb.io/rest/', 'headers' => [ 'x-apikey' => getenv('restdb_key'), 'content-type' => 'application/json' ] ]); $->client = $client; return $; } /** * returns user's account entry it exists. caches result 5 minutes * unless told be `$fresh`. * * @param int $twitter_id * @param bool $fresh * @return bool|\\stdclass */ public function useraccount(int $twitter_id, bool $fresh = false) { /** @var responseinterface $request */ $response = $->client->( 'accounts', [ 'body' => '{\"twitter_id\": ' . $twitter_id . ', \"max\": 1}', 'query' => ['metafields' => true], 'headers' => ['cache-control' => $fresh ? '-cache' : 'max-age:300'], ] ); $bodystring = json_decode($response->getbody()->getcontents()); (empty($bodystring)) { return false; } return $bodystring[0]; } /** * creates new account restdb. * * @param array $user * @return bool */ public function createuseraccount(array $user) { /** @var responseinterface $request */ $response = $->client->post('accounts', [ 'body' => json_encode([ 'twitter_id' => $user['id'], 'settings' => array_except($user, 'id') ]), 'headers' => ['cache-control' => '-cache'] ]); return $response->getstatuscode() === 201; }} this service, define ways set guzzle client be used, along a shortcut method define default . this default also includes default authorization header, sets content type json is were communicating . we demonstrate basic reading writing and restdb. useraccount method directly searches a twitter id the accountsrecords, returns record found, false not. note use the metafields query param lets fetch _created other system fields. notice that cache result 5 minutes unless $fresh param is passed , because user info rarely change we might need multiple times during session. createuseraccount method takes array user data ( most important which is id key) creates account. note were looking status 201 means created.lets make serviceprovider register service a singleton.artisan :provider restdbserviceprovider<?phpnamespace app\\providers; app\\services\\followers\\restdb; illuminate\\support\\serviceprovider;class restdbserviceprovider extends serviceprovider{ /** * register application services. * * @return void */ public function register() { $->app->singleton( 'restdb', function ($app) { $r = restdb(); $r->setdefaultclient(); return $r; } ); }}finally, lets update logincontroller. // ... $request->session()->put('twitter_id', $user->id); $rest = resolve('restdb'); (!$rest->useraccount($user->id)) { ($rest->createuseraccount( [ 'token' => $user->token, 'secret' => $user->tokensecret, 'nickname' => $user->nickname, 'id' => $user->id, ] )) { $request->session()->flash( 'info', ' account has been created! welcome!' ); } else { $request->session()->flash( 'error', 'failed create account :(' ); } } // ... return redirect('/'); the logincontrollers handleprovidercallback method, first grab (resolve) service, it check the user has account, create if , and flash message session either successful not.lets put flash messages the view:{{--index.blade.php--}}@isset($info) <p>{{ $info }}</p>@endisset@isset($error) <p>{{ $error }}</p>@endisset... we test out, sure enough, new record is created: lets offer /dashboard. idea is: * a user logs , theyll presented a dashboard link. * clicking link , in order: * grab latest follower-lists entry restdb * more 15 minutes elapsed since last entry was created, the user doesnt an entry all, new list followers be fetched. new list be saved. it wasnt first entry, diff is generated new followers unfollowers. * the user has refreshed the last 15 minutes, will simply redirected the dashboard * the user accesses dashboard, their follower-lists restdb entries are fetched * applications goes through the diff entries the records, generates reports unfollowers, displaying information how long had been following user before leaving. * once ids the report been fetched, information is fetched via /users/lookup endpoint grab avatars twitter handles. * an account had been following a or less, is flagged a red color, meaning high certainty follower farming. 1 5 days is orange, 5 10 days is yellow, others are neutral.lets update index view , and add new route.// routes/web.phproute::('/dashboard', 'homecontroller@dashboard');{{--index.blade.php--}}...<p> bet 'd to your follower stats, wouldn't ?</p> to < href=\"/dashboard\">dashboard</>.we need way fetch last follower_lists entry a user. thus, the restdb service, can add following method: /** * the last follower_lists entry the user question, false * none exists. * * @param int $twitter_id * @return bool|\\stdclass */ public function getuserslastentry(int $twitter_id) { $id = $->useraccount($twitter_id)->_id; /** @var responseinterface $request */ $response = $->client->( 'accounts/' . $id . '/follower_lists', [ 'query' => [ 'metafields' => true, 'sort' => '_id', 'dir' => -1, 'max' => 1, ], 'headers' => ['cache-control' => '-cache'], ] ); $bodystring = json_decode($response->getbody()->getcontents()); return !empty($bodystring) ? $bodystring[0] : false; } either return false, the last entry. notice were sorting the _id metafield, newest oldest (dir=-1), fetching maximum 1 entry. params are explained here. lets turn attention the dashboardmethod homecontroller: public function dashboard(request $request) { $twitter_id = $request->session()->('twitter_id', 0); (!$twitter_id) { return redirect('/'); } /** @var restdb $rest */ $rest = resolve('restdb'); $lastentry = $rest->getuserslastentry($twitter_id); ($lastentry) { $created = carbon::createfromtimestamp( strtotime($lastentry->_created) ); $diff = $created->diffinminutes(carbon::()); } if ((isset($diff) && $diff > 14) || !$lastentry) { $followerids = resolve(followers::class)->getfollowerids(); $rest->addfollowerlist($followerids, $lastentry, $twitter_id); } dd(\"let's show previous lists\"); }ok, whats going here? , we a primitive check the user is still logged the twitter_id has be the session. not, redirect homepage. , we fetch rest service, the accounts last follower-lists entry ( is either object false) then it exists, calculate old is. its more 14 minutes, if entry doesnt exist all (meaning s very one that account), fetch new list followers save . how we save ? by adding new addfollowerlist method the rest service. /** * adds new follower_lists entry an account entry * * @param array $followerids * @param \\stdclass|bool $lastentry * @param int $twitter_id * @return bool * @internal param array $newentry */ public function addfollowerlist( array $followerids, $lastentry, int $twitter_id ) { $account = $->useraccount($twitter_id); $newentry = ['followers' => implode(', ', $followerids)]; ($lastentry !== false) { $lastfollowers = array_map( function ($el) { return (int)trim($el); }, explode(',', $lastentry->followers) ); sort($lastfollowers); sort($followerids); $newentry['diff_gone'] = implode( ', ', array_diff($lastfollowers, $followerids) ); $newentry['diff_new'] = implode( ', ', array_diff($followerids, $lastfollowers) ); } try { /** @var responseinterface $request */ $response = $->client->post( 'accounts/' . $account->_id . '/follower_lists', [ 'body' => json_encode($newentry), 'headers' => ['cache-control' => '-cache'], ] ); } catch (clientexception $e) { // log exception message something } return $response->getstatuscode() === 201; } one grabs user account find id the account record restdb. , it initiates $newentry variable a properly formatted (imploded) string current follower ids. next, there was last entry, : * get those ids a proper array exploding string cleaning whitespace. * sort both current past follower arrays more effective diffing. * the differences add to $newentry. then save entry, targeting specific account entry the previously fetched id, continuing into sub-collection follower_lists. test , we fake data. lets alter $followerids part homecontroller::dashboard this: $count = rand(50, 75); $followerids = []; while ($count--) { $flw = rand(1, 100); (in_array($flw, $followerids)) $count++; else $followerids[] = $flw; } will generate 50-75 random numbers ranging 1 100. enough us get diffs. we hit url /dashboard while logged now, should our initial entry. we remove 15 minute limit the block refresh more times, ve generated 3 entries total, good looking diffs:s for final feature. lets analyze entries, identify follower farmers.final stretch it contextually makes sense, ll put logic the followers service. lets create analyzeunfollowers method. will accept arbitrary number entries, do logic a loop all them. , if later to provide quicker of checking last bit information since last login session, can simply pass two last entries instead all them, the logic remains same. public function analyzeunfollowers(array $entries) { ... } identify unfollowers, look the recent diff_gone, all are gone since last we checked follower list, then find in diff_new arrays previous entries. then lets find how long had been following before leaving. while using entries, also need turn diff_gone diff_new entries arrays, easy seeking. /** * accepts array entries (stdobjects) ordered newest oldest. * objects must the properties: diff_gone, diff_new, followers, * of are comma delimited strings integers, arrays integers. * property `_created` is essential. * * @param array $entries * @return array */ public function analyzeunfollowers(array $entries) { $periods = []; $entries = array_map( function ($entry) { (is_string($entry->diff_gone)) { $entry->diff_gone = $->intarray($entry->diff_gone); } (is_string($entry->diff_new)) { $entry->diff_new = $->intarray($entry->diff_new); } return $entry; }, $entries ); $latest = array_shift($entries); ($i = 0; $ < count($entries); $++) { $cur = $entries[$]; $curlast = array_last($entries) === $cur; ($curlast) { $matches = $latest->diff_gone; } else { $matches = array_intersect( $cur->diff_new, $latest->diff_gone ); } ($matches) { $periods[] = [ 'matches' => array_values($matches), '' => (!$curlast) ? carbon::createfromtimestamp(strtotime($cur->_created)) : 'forever', '' => carbon::createfromtimestamp(strtotime($latest->_created)) ]; } } return $periods; } /** * turns string comma separated values, spaces no, an array integers * * @param string $string * @return array */ protected function intarray(string $string): array { return array_map( function ($el) { return (int)trim($el); }, explode(',', $string) ); } course, need way fetch the follower list entries. put getuserentries method the rest service: /** * gets twitter id's full list follower list entries * * @param int $twitter_id * @return array */ public function getuserentries(int $twitter_id): array { $id = $->useraccount($twitter_id)->_id; /** @var responseinterface $request */ $response = $->client->( 'accounts/' . $id . '/follower_lists', [ 'query' => [ 'metafields' => true, 'sort' => '_id', 'dir' => -1, 'max' => 100, ], 'headers' => ['cache-control' => '-cache'], ] ); $bodystring = json_decode($response->getbody()->getcontents()); return !empty($bodystring) ? $bodystring : []; }s possible the number followers some accounts create big downloads, thus slowing app down. since only really need diff fields, can target those the h param, described the bottom this page., if , for debugging purposes, modify dashboard method $entries = $rest->getuserentries($twitter_id); dd($followers->analyzeunfollowers($entries)); output looks something this. s obvious 5 our fake followers only been following for 5 seconds, while rest them been following since before signed for service (.e. forever).finally, can analyze periods got its easy identify short ones, color-code as described the beginning this post. this is already post considerable length, ll leave part, the part using twitters users lookup api turn ids user handles homework. protip: you run of query calls that part, can crawl mini profile the user_id param!conclusion went through process building simple application tracking amount time given person has followed , and flagging down a follower farmer, without using local database restdb provided with extreme performance, scalability, independence local services. are many upgrades could apply this app: * cronjob auto-refresh follower lists behind scenes * heavy caching conserve api calls increase speed * premium account subscription would let users keep more entries * dashboard matching tweets unfollows, showing what may prompted someone leave twittersphere * multi-account support * instagram support other upgrades this system you of? feel free contribute the app github!more: restdb, twitter meet author bruno skvorc bruno is coder croatia masters degrees computer science english language literature. s editor sitepoints php channel a developer evangelist diffbot.com. avoids legacy code the plague when picking projects makes sure re cutting edge possible. s treadmill desk enthusiast active (board)gamer sometimes blogs. limited offer: 10 free adobe stock images.learn moread recommended * 1 interrupting applications laravel middleware * 2 to properly deploy web apps via sftp git * 3 alternative laravel package development workflow * 4 7 deep tips will dramatically boost productivity * 5 your own social network, game server, knowledgebase! - sourcehunt sponsors adobelimited offer: 10 free adobe stock images. phphow build cryptocurrency auto-trader bot php? joel walks through complex process auto-trading cryptocurrency turning profits night laravel, apis, bitcoin, ...joel degan, 2 days agoview3 comments phpfamily crms, guzzle wrappers php machine learning? sourcehunt! this sourcehunt, present php machine learning, crm helps track personal relationships, wrapper make guzzle usable...bruno skvorc, 4 days agoview php phphow build cryptocurrency auto-trader bot php? joel walks through complex process auto-trading cryptocurrency turning profits night laravel, apis, bitcoin, various exchanges! php3 comments phpfamily crms, guzzle wrappers php machine learning? sourcehunt! this sourcehunt, present php machine learning, crm helps track personal relationships, wrapper make guzzle usable again, more! latest php books courses1h 1m premium courselami adaexploring php learning more php, video a time3h 8m premium courseisaac castillolaravel 5 started laravel 5.2 premium bookbruno skvorcjump start php environment your php projects set the right premium booktimothy boronczykjump start mysql master database powers web premium course1h 1m premium courselami ada, may 18exploring php premium course3h 8m premium courseisaac castillo, nov 14laravel 5 premium book premium bookbruno skvorc, dec 15jump start php environment premium book premium booktimothy boronczyk, apr 08jump start mysql php books courses the latest php, once week, free.subscribe limited : get our design web dev books, courses tutorials completely free. claim deal * about * story * advertise * press room * reference * terms use * privacy policy * faq * contact * contribute * visit * sitepoint home * themes * podcast * forums * newsletters * premium * references * versioning * connect * * © 2000 2017 sitepoint pty. ltd."
}