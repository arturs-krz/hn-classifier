{
	"_id": "14541796",
	"site": "https://sgoedecke.github.io/blockchain-for-beginners/",
	"title": " A dead simple introduction to the blockchain (with ~90 line JavaScript demo)",
	"author": "gfysfm",
	"date": "2017-06-16T07:55:56.280Z",
	"tags": [],
	"content": "introduction blockchain# introduction is guide developers kinda sorta what blockchains _are for_ (making distributed crypto-currencies bitcoin possible) have idea exactly is involved that how works. problem is compounded the fact popular discussions (e.g.) bitcoin try make interesting pumping the mathematics side it, makes sound more inaccessible developers without strong maths cs chops. instance, news articles mention placing \"block\" the \"chain\" - whatever means - requires solving very difficult mathematical problem. sounds complicated! it reality 's \"mutate string and until md5 hash meets very stringent condition\". yes, 's difficult maths problem, the implementation couldn't simpler. the end this article, hope 'll understand why blockchains , and feel comfortable writing ~100 line toy blockchain client your language choice. ('s hundred lines, a typo.) can jump the [demo](https://sgoedecke.github.io/blockchain-js-demo/) soon you , but 'd recommend reading least first section below. # why blockchain? kind problem is blockchain designed solve? suppose want write database-backed app, without using server. your users have copy your app, must able read write a shared data store will. they read the store, should the latest copy everyone else's writes. since blockchain implementations are crypto-currencies, is often called _ledger_. would design app this? since don't a server, 'll to all copies our app connect each and share data somehow. luckily, problem's already been solved peer--peer networking, famously used torrent clients. building torrent client is easier our problem, since torrenters just downloading copies the same file. torrenting is write-once system: once file is made available, can't added or altered. 's easy prevent tampering a file putting hash it: the hash the copy `twilight[axxo].mp4` downloaded doesn't match hash the `.torrent` file, (or least torrenting program) knows 's invalid download. >'s nothing stop hacker uploading `.torrent` file 's associated a malicious copy _twilight_. there's safety numbers: thirty thousand have downloaded particular copy the movie, haven't reported as malicious, can pretty sure 's safe - since _know_ the hash you're getting exactly same file they did. a torrent client, blockchain app rely hashes verify you've got right copy the ledger. unlike torrent client, don't want download right copy the ledger - also to _write_ the ledger. first glaring issue here is preventing someone rewriting history. since don't actually a database, thus no single source truth, 'll to find another to stop tampering. > we stick hash the ledger, we with torrents? , because every write invalidate hash. could generate new hash you write, there's reason any user believe 've added something the ledger haven't altered anything weren't supposed . # hash lists solve , blockchains rely a data structure called _hash list_ (sometimes called merkle list). 's way hash parts the ledger the whole thing the same . a hash list is list where each element contains content, pointer the previous element - a regular linked list - a hash that previous element. we both a copy the same hash list, you add element the end, can verify you haven't altered of existing elements re-hashing existing elements checking hash (stored the next element). once 'm satisfied you haven't tampered history, 'll accept new element. since each element contains hash the previous element, then goes the hash stored the following element, can't tamper the order elements either. ![hash list](./hash_list.svg) our blockchain app, ledger be stored a hash list. each element the hash list is called _block_. ( is where \"blockchain\" comes : it's chain blocks.) every we accept generate new block, blockchain app send latest version the ledger all peers the p2p network. they verify hashes the chain, 'll add block blocks were missing. changes the ledger thus propagate the network, without anybody being able change past. # bitcoin with tamper-proof ledger, distributed nature blockchain means ledgers _will_ out sync soon two instances our app add block the same . how you reconcile -of-sync histories? could what github does force to \"pull\" latest version the ledger before \"push\" new block the p2p network, with distributed network 'll never able say sure we've got latest version. some point versions the app have conflicting ledgers. > handling would catastrophic our app. each conflict, blockchain 'community' splinter sub-communities, each which views other's ledger invalid, rendering impossible someone one community interact the community's ledger. different blockchains adopt different strategies dealing this problem. here's simplified version how bitcoin does , which 'll adapt our blockchain app. are three main parts bitcoin's strategy: first greatly reduce number generated blocks thus number conflicts, the third offers way resolving conflicts they occur. ### bundle writes , we stop making every write block. instead, publish 'un-saved' writes the p2p network, signed our private key. blocks are generated a subset users called \"miners\", bundle unsaved writes together batches before hashing. suppose five hundred writes fit one block. we've divided number blocks five hundred. >bitcoin hashes the writes a block - each which represents transaction - a special . they hash each the writes, hash sum each pair hashes, so until get binary tree. remember merkle list? is called merkle tree. point is you verify integrity one transaction without downloading re-hashing entire tree. you need do is download branch containing transaction want verify. doing enables existence \"lightweight\" bitcoin clients, verify as much they personally need . fully-fledged bitcoin nodes are still required order maintain integrity the blockchain. ### require proof work second, introduce artificial difficulty the task making blocks. instead just bundling five hundred writes hashing - very quick task - let's stipulate for block be real, hash contains must begin four zeroes. ('ll add arbitrary string, called _nonce_, each block miners tweak to the hash want.) we've restricted number potential miners those the computing power brute-force way the hash target. better still, of those miners, 's very unlikely more one get at same . this significantly slow down rate which blocks be added the ledger, since 're bundling five hundred writes a block 's so bad. >since generating hash four zeroes the start requires lot computing power, generated hash is called _proof work_. incentive miners (besides pure altruism love the bitcoin concept) spend and effort generating proof work? bitcoin is set to let miners award themselves flat bitcoin fee each block successfully mine, plus commission all transactions the block. other words, miners put \"25 btc me\" transaction the end each block mine, everyone's agreed accept those blocks the blockchain. ### resolve conflicts third, declare strategy handling -of-sync ledgers: accept longer . our app treat shorter ledger invalid. note this make possible write the ledger, circulate among users the app, then it overwritten a longer chain pops from somewhere else. 's an unfortunate consequence using blockchains - can never 100% certain your changes the ledger \"made in\", that recent blocks won't replaced. however, longer change survives, more blocks slot above , and more confidence can that change persist. > of decisions with trade-offs: fewer conflicts the expense a less distributed system; easy conflict resolution the expense making writes unreliable. since toy blockchain app isn't going be popular as dangerous bitcoin, can avoid of trade-offs. let's ditch first decisions keep third. ## why bitcoin works can see bitcoin maintain tamper-proof record all bitcoin transactions ( thus many btc everyone has the moment). each transaction gets broadcasted, picked by miner bundled into block a very special hash attached. ![bitcoin blockchain](./bitcoin_blockchain.svg) until transaction gets bundled, hasn't \"gone through\", even it becomes block might still overwritten. however, once transaction's block gets picked by bunch bitcoin users, has stack blocks top it the blockchain, 's forever. nobody alter , and thus alter bitcoin balance, without invalidating hashes. would obvious evidence tampering, would their copy the ledger - blockchain - obviously invalid. wouldn't picked by bitcoin users, wouldn't mined blocks placed top it, thus wouldn't last long all. miners are heavily incentivized only place blocks valid ledgers. placing block an invalid ledger be waste all computing they spent generating proof work, since block generated only usable that invalid chain. bitcoin proponents that automatic anti-fraud system makes bitcoin least reliable traditional government-backed currencies ( combat fraud forgery via legal system). any case, 's very cool. ## demo you a working javascript demo a completely minimal blockchain ( proof--work, write per block), 've written [here](https://sgoedecke.github.io/blockchain-js-demo/). clocks at over 90 lines code, no code-golf external libraries. sharing blockchain other nodes is left an exercise the reader: provide serialized version, you send people via email/facebook/carrier pigeon. a more fleshed- demo, check [naivechain](https://github.com/lhartikk/naivechain), is around ~200 lines code actually includes p2p implementation docker."
}