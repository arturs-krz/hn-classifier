{
	"_id": "14462217",
	"site": "http://wstoop.co.za/wregex.php",
	"title": " Wregex – How Regular Expression Engines Work",
	"author": "wernsey",
	"date": "2017-06-16T07:57:10.038Z",
	"tags": [],
	"content": "wregex - regular expression engines 2017-06-01 werner * home * * tweet * 2007 wrote regular expression engine i called wregex. 've cleaned the code placed ongithub. essay is description how is implemented. think if understand concepts will never puzzled a pattern again.state machinesregular expression engines are implemented asfinite state machines (fsm). pattern supply is compiled a data structure represents state machine. you match string against pattern, regex engine takes each character decides state transition within fsm. there are valid state transitions an input character match fails. of states the fsm is terminating/end state. the regex engine gets it reports success. are ways[1] which state machines be arranged, namely deterministic finite automata (dfa) non-deterministic finite automata (nfa). names refer the in the internal states the regex engine changes each input character.dfas dfa is called deterministic it always choose next state a given input character; it cannot to valid state means the input string does match regex pattern. following graphic shows example dfa the regular expression \"ab*c\":consider example input string \"abbc\": 1. start in \"start\" state (surprise!). 2. read 'a' character go state 1. 3. read 'b' go state 2. 4. read another 'b' remain state 2. 5. read 'c' go state 3. 6. stop state is reachable, we're done: input matches regular expression. we were read, , a 'd' while were state 2, know the input doesn't match regex.nfas nfa is called non-deterministic there are cases where regex engine has guess state go next. it guesses wrong has go to previous state try different transition. following graphic shows example nfa the regular expression \"ab*c\" before. 've drawn a bit differently, i'll explain:here's the nfa process input string \"abbc\": 1. the \"start\" state proceed immediately state . 2. read 'a' character go state x. 3. state x is special - this state next character be either 'b' a 'c'. guess it be 'b' (accepting we may wrong), we to state b. note i've drawn arrow x b thick the arrow x c thin. regex compiler decided the engine should to b , but is detail 'll explain later. read 'b' go to state x. repeat step 3 go to state b. read another 'b' go to state x. repeat step 3 again go state b. read 'c', we since 're state b can't forward. we back where came : back state x (step 6). we already tried go state b state x ( thick arrow) it didn't out, now to state c. stop state is reachable, we're done: input matches regular expression. process going to previous state trying another state transition a nfa ( in steps 8 9) is called backtracking. nfa have try possible routes through state machine until finds terminating state, possible routes are exhausted, there are more input characters., which type we prefer?dfas some big advantages nfas: dfa regex engines don't need backtrack are general much faster nfas. , because nfas need backtrack, is possible structure pattern such way the backtracking cause nearly infinite loops certain input sequences. dfas don't need non-greedy operators *? +?nfas got own advantages dfas. most important these are nfas allow capture groups. other advantage is nfa regex engines are easier implement ( my experience least). these reasons, you in practice is most modern languages implement regex engines nfas most regex tutorials the internet explain use non-greedy operators avoid problems backtracking.wregex is implemented a nfa regex engine.implementation code is available github you'd to follow along. api has 2 broad phases[2]: * compilation - is step builds nfa. is part takes input pattern \"ab*c\" builds data structure represents state machine figure 2. wregex calls structure awregex_t, does compilation the function wrx_comp() defined the file wrx_comp.c. * execution - is part matches string against compiled nfa, determines whether is match extracts submatches. wregexdoes in function wrx_exec() defined the file wrx_exec.c. remainder the api are functions error handling debugging. the description below, will need describe execution phase . it is easier understand the parser generates nfa structure you what want achieve the execution phase. will split description the compilation phase two stages:parsing code generation. parsing is responsible reading regex pattern memory, while code generation is process outputing nfa data structure. practice wregex generates nfa while parser reads pattern, it be clearer i describe two stages separately.executionstructures core wregex is built around wregex_t structure defined inwregex.h. here are most important partstypedef struct _wregex_t{ wrx_state *states; /* states themselves */ short n_states; /* number states */ short start, /* start state */ stop; /* stop state */ // ... } wregex_t; states member is most important part, it contains actual state machine. each state is wrx_state object, look the following:typedef struct _wrx_state{ char op; /* opcode */ short s[2]; /* state transitions */ union { char c; /* actual character */ char *bv; /* bit vector storing ranges characters */ short idx; /* index this is submatch/backreference state (rec, stp, brf) */ } data;} wrx_state; * member op is code an operation (opcode) should performed the nfa is that state. example opcodes are mtc tells nfa match single character, chc tells nfa try state transition, if fails try different state transition. opcodes are defined the top wrxcfg.h. * member s[2] contains state transitions. * member data contains operand the state. is union, the particular sub-member used depends the specific opcode. example the opcode is mtc the nfa compare next character the input string the c member data. you are familiar compilers, interpreters assembly language would've realised now the states the wregex_t are actually instructions a very specific interpreter executed the wrx_exec()function. start stop members the wregex_t are indices the and last states the nfa within array ( first state is necessarily states[0] will become apparent shortly).interpreter basics'm going skip forward a moment show at a compiledwregex_t nfa looks . the following is wregex_t's states array the regular expression \"ab\":start: 4; stop: 6 0 mtc '' 2 2 mtc 'b' 5 4 rec <0> 0 5 stp <0> 6 6 eom output above be obtained you compile wregex in debug mode (usemake debug your shell) then run test program \"ab\" parameter: ./test ab. * first column is index the states array[3]. * second column is opcode. * third column is operand ( data member). * forth column is first state transition ( s[0] member). * chc instruction have fifth column the second state transition ( s[1] member). is the nfa look graphically: wrx_exec() function goes through steps match string against nfa: 1. starts state 4 rec instruction represented the triangle the graphic. 2. executes rec instruction, goes state 0 (ignore specifics the rec stp instructions now. 'll discuss when get tosubmatches below). 3. mtc instruction state 0 matches first character the input string the literal '' and goes state 2. 4. mtc instruction state 2 matches next character the input string 'b' goes the stp instruction state 5 (represented the inverted triangle). 5. stp instruction is executed it proceeds state 6. 6. eom instruction means end match: input string matched regular expression.backtracking you concluded backtracking somehow involve stack my description the nfa above, you be correct. introduce chc (\"choice\") instruction implement backtracking. has arguments corresponding the possible next states should try. are stored the s[0] s[1] members the wrx_state structure. executing instruction engine pushes second state onto stack tries first state. it cannot match state, pops new state the stack tries again. the stack is empty we try pop , we that input string does match regex.lets at states the expression \"|b\":start: 6; stop: 8 0 mtc '' 7 2 mtc 'b' 7 4 chc --- 0 2 6 rec <0> 4 7 stp <0> 8 8 eomconsider wrx_exec() should when encounters input string \"b\" 1. starts the rec instruction state 6, goes state 4. 2. chc instruction pushes current position the input string state 2 ( value wrx_state.s[1]) onto stack goes state 0 ( value wrx_state.s[0]). arrow state 4 state 0 is drawn thick the from state 4 state 2 thin show state 0 be tried . which to try is important detail nfa-based regex engines. 3. mtc instruction matches 'a' the \"b\" the input string. fails we to stack. is empty we pop previous position the input string along the state transition, 2. , we go state 2. 4. now match 'b' \"b\". is successful, we to state 7. 5. perform stp instruction go state 8. 6. are at eom the match was successful. the input string was \"d\" instead would've been unsuccessful step 4. this case the stack now empty, we know the input string does match regex.parsingwregex implements parser a recursive descent parser. here is complete syntax wregex abnf- grammar:pattern ::= ['^'] [list] ['$']list ::= element [\"|\" list]element ::= (\"(\" [\":\"] list \")\" | value) [((\"*\"|\"+\"|\"?\")[\"?\"])|(\"{\" [digit+] [\",\" [digit+]] \"}\" [\"?\"])] [element]value ::= (-za-z0-9!\"#%&',-/:;=@\\\\_`~\\t) | '<' | '>' | \"[\" [\"^\"] ranges \"]\" | \".\" | 'escape sequence'ranges ::= (c [\"-\" c])+ where c is printable ascii character (>= 0x20) you are familiar bnf, above states : * a pattern consists an optional list, optionally prefixed a caret^ optionally followed a dollar $ sign. * list consists an element, optionally followed a pipe | another list (hence recursive recursive descent parser). * element be list wrapped parenthesis (capturing non capturing groups) a value ( 'a'), followed optionally a *, + '?' (like '*'), which turn may non-greedy ( a*?) a number repetitions curly braces ( a{4} a{5,10}) in turn may non-greedy ( a{4,5}?), may be followed anotherelement. * value is literal character, character set ( [a-z]), '.'operator an escape sequence. * ... so and forth. i about recursive descent parsers is it is very easy implement parser hand a grammar the above follow code the parser later. each the rules the grammar has corresponding function wrx_comp.c, nicely organises code maintainability.recursive descent parsers drawbacks, i'll leave as exercise the reader.code generation nice thing the recursive descent parser is it veery neatly splits regex pattern 're compiling sub-patterns. every level down parser creates segment the nfa returns to caller. these instructions are stored a dynamically growing array the instructions described the section the interpreter basics. function next_state()returns next available index this array, resizes if becomes full ( can of index an instruction address our bytecode interpreter). so caller needs mechanism keep track start end indices the segments generated each the functions calls. does through thepush_seg() pop_seg() functions, pushes pops nfa_segment sturcture onto stack. nfa_segment simply contains beginning end index a particular segment. an example, consider compiiling pattern ab|c. parser goes down through functions, calling pattern(), list() theelement() functions. element() doesn't find of operators it calls value() right its end. first pattern is character '', for a mtc instruction followed amov instruction is generated:0 mtc '' 11 mov 0 mov (move) instruction is a dummy instruction causes interpreter move the state specified its operand ( didn't occur me the thatjmp might been more appropriate name). this point operand is set, it is 0. beginning end addresses this segement (0 1, respectively) is pushed onto stack through push_seg() value() returns.'re back the element() function, calls itself rcurisvely ends calling value() function again. parser encounters 'b' character, it generates same 2 instructions again the :0 mtc '' 11 mov 02 mtc 'b' 33 mov 0 new segment's addresseses (2 3) are pushed onto stack, value() returns, then recursive call element() returns.'re back the initial call element() function. element() knows has concatenate segements, it pops segments off stack through pop_seg(). it uses transition() function tie end the segment the second segment setting operand the mov instruction 20 mtc '' 11 mov 22 mtc 'b' 33 mov 0 element() function returns one level the list() function encounters '|' symbol calls element() again, encounters 'c' adds new segment:0 mtc '' 11 mov 22 mtc 'b' 33 mov 04 mtc 'c' 55 mov 0 back the list() function, are two segements the stack: 0-3 4-5. get popped off. list() generates chc a mov instruction chc has start the segments, 0 4 operands, control branching. also connects two segment's end points the generated mov instruction.0 mtc '' 11 mov 22 mtc 'b' 33 mov 74 mtc 'c' 55 mov 76 chc --- 0 47 mov 0 addresses the chc mov instructions are pushed onto stack the resulting segment this demonstrates whey mov instructions are necessary: allow each function the parser have single entry exit point the generated nfa.list() returns pattern() wraps segment pops the stack between rec stp instructions (used capturing groups, describedbelow), pushes new segment onto stack.'re at top the parser wrx_comp(). pops completed nfa ( is one big segment) off stack appends eom instruction shows successful match. completed nfa looks this: 0 mtc '' 1 1 mov 2 2 mtc 'b' 3 3 mov 7 4 mtc 'c' 5 5 mov 7 6 chc --- 0 4 7 mov 9 8 rec <0> 6 9 stp <0>1010 eom other operatorsusing principles, can compile *, + and ? operators. the examples 'm to p, q, r s are addresses instructions, a is arbitrary pattern is compiled a segement through recursive calls. compile * operator pattern a*, generate chc instruction will try match pattern . it looks this: start r p <segment matching > ... q mov r r chc --- p s s ... a+ pattern is just simple modification: start p rather rto ensure the input string matches at least once. start p p <segment matching > ... q mov r r chc --- p s s ... ? operator works lot the *, the mov instruction qjumps directly s instead going through chc r start r p <segment matching > ... q mov s r chc --- p s s ...optimizer last step the compiler is call optimize() function, removes themov instructions, have become redundant: an instruction's destination is mov, just change instruction's destination the mov's destination.start: 8; stop: 10 0 mtc '' 2 2 mtc 'b' 9 4 mtc 'c' 9 6 chc --- 0 4 8 rec <0> 6 9 stp <0>1010 eomextra details you followed above, the extra features are quite straight forward implement.\"lazy\"/\"non-greedy\" operatorsimplementing non-greedy *? +? operators is laughably simple: simply swap order which try next states the chc states.remember i showed we try state b in step 3 my description ofnfas above? that setup, regex engine always try consume another 'b' character state x before tries 'c', making itgreedy more 'b's. order make '*' operator non-greedy, regex engine simply has try state c . the following graphic nfa the regular expression\"ab*?c\":'ve drawn arrow x c thick the arrow x b thin time show difference. this case, once 're state x you've read 'a', regex always try match 'c' and to \"stop\" state before tries match 'b' characters. function weaken() wrx_comp.c swaps state transitions an nfa a ? is encountered a * a +.curly braces cheated bit expressions containing curly braces, a{m,n}: are implemented repeating preceding expression n times. example,{1,4} is handled internally 'aa??a?'. function duplicate() wrx_comp.c takes care the details.character setscharacter sets are implemented 256-bit bit vectors. each bit the bit vector corresponds an ascii character. set opcode compares current input character against bit vector. is reason why wregex cannot support unicode its implementation. set [a] have bits associated both '' and '' set case-insensitive mode. '.' operator uses bit vector all bits set except the bits associated the ascii control characters.case insensitivitywregex uses '\\i' '\\i' control sequences enable disable case-insensitivity, rather depending flags passed wrx_comp(). wanted wregex be usable the regex engine a scripting language, doing this gave control the person writing scripts rather the person implementing scripting language. control sequences toggle flag the compiler controls whether mtc mci opcodes are generated how bit vectors the character sets are generated.special operatorsspecial operators '^', '$', '<' and '>' have special opcodes causes wrx_exec() check the beginning end lines words, respectively.submatches backreferences rec (\"record\") stp (\"stop recording\") instructions are used record submatches.submatches are stored an array wregmatch_t structures while engine is executing. each wregmatch_t structure contains pointer the beginning the end (called beg end respectively) the current submatch. the rec instruction is encountered engine sets beg pointer the current position the input string, when stp instruction sets end pointer. wrx_exec() is done, wregmatch_t array contains correct values. wregex_t hs member n_subm counts opening brackets ensure the correct wregmatch_t structure's value is set. nfas are surrounded a \"rec <0> - stp <0>\" instruction pair capture entire matching string submatch 0. an example, consider the pattern (b*)c is represented an nfa:start: 10; stop: 12 0 mtc '' 6 2 mtc 'b' 4 4 chc --- 2 7 6 rec <1> 4 7 stp <1> 8 8 mtc 'c'11 10 rec <0> 0 11 stp <0>12 12 eom state 6 rec instruction records the current position the input string the start submatch 1. then proceeds state 4, chcinstruction, uses backtracking mechanism state 2 read sequence 'b' symbols.once cannot read more 'b's jumps state 7 records current input position the end submatch 1 proceeds state 8 read 'c'symbols the end the pattern.backreferences are simply implemented matching input string the current position against corresponding submatch.conclusion hope article gave some insight how regex engines .i remember it seemed complex i implemented wregex originally back, the code seems simple looking it .referencesbelow are of references used i implemented wregex wrote original implementation 2007, some these links may gone stale. apologies advance that. * \"pattern matching regular expressions c++\" oliver mueller, published issue 27 linux gazette, april 1998 * \"regular expression matching be simple fast ( is slow java, perl, php, python, ruby, ...)\" russ cox * \" text editor sam\" rob pike the implementation http://plan9.bell-labs.com/sources/plan9/sys/src/libregexp/regexec.c * \"compilers principles, techniques tools\" aho, sethi, ullman addison wesley 1986 * webpages http://www.regular-expressions.info, such the at regular expression basic syntax reference provided insight. * \" regexes \" by mark-jason dominus the perl journal * \"writing own regular expression parser\" amer gerzic the code project * ozan s. yigit's implementation http://www.cse.yorku.ca/~oz/ * \"algorithmic forays\" eli bendersky, accessible http://www.gamedev.net/reference/list.asp?categoryid=25 * \"understanding regular expressions\" jeffrey friedl * \"regular expressions\" hardeep singh * henry spencer's implementation be found http://arglist.com/regex/ * jeff atwood discusses catastrophic backtracking. * wikipedia entry regexwhile writing entry, also noticed russ cox wrote new article the intervening years titledregular expression matching: virtual machine approach, covers lot the topics 've discussed here discusses several alternative approaches, optimizations practical considerations. 1. broadly speaking - rest are variants combinations these 2. 'll notice the posix regex api, regex(3), specifies functions similar purposes. 3. 'll notice some the indices, 1 3 are missing. is artifact the compilation process where those elements the array contain states are never reached 1. home 2. contact recent posts * 2017-06-01wregex - regular expression engines * 2017-03-17a bitmap library * 2017-01-03why jatalog * 2017-01-02jatalog: datalog deductive database java * 2016-08-07my chip-8 interpreter postselsewhere 1. github 2. twitter 3. google+© 2012-2017 werner stoopbased the bootstrap blog template @mdo. to top"
}