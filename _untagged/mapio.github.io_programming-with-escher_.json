{
	"_id": "14444030",
	"site": "https://mapio.github.io/programming-with-escher/",
	"title": " Programming with Escher",
	"author": "mapio",
	"date": "2017-06-16T07:57:34.277Z",
	"tags": [],
	"content": "programming escher¶ notebook is collection preliminary notes a \"code camp\" ( a series lectures) aimed young students inspired the fascinating functional geometry paper peter henderson. such the square limit woodcut maurits cornelis escher is reconstructed a set primitive graphical objects suitably composed means a functional language.here approach be somehow different: of because recipients be students to computer science (instead fellow researchers), also besides recalling fundamental concepts abstraction levels ( barriers), primitives composition, present the original paper, will here take opportunity introduce (albeit some extent elementary) considerations algebra geometry, programming recursion ( perhaps discuss implementation details). work is be considered very preliminary, is yet structured a series lectures, nor is worked the level which every topic is be presented, according the age ( previous knowledge) the students. language detail level used here is intended instructors teachers, the various topics be listed mere hints, yet a viable ready use syllabus. a last remark, before actually beginning the notes, code this notebook is very loosely derived previous \"implementations\" functional geometry such shashi gowda's julia version micah hahn's hasjell version (containing bézier curve description the escher fish used here). decided rewrote such code a jupyter notebook written python 3, simple widespread language, make easier instructors adopt .the source notebook is available github (under gpl v3), feel free use issues point errors, to fork to suggest edits.square limit tiles¶looking the original artwork is evident it is obtained the repetition a basic element ( fish) is suitably oriented, scaled, colored. suggest start journey a tile ( set lines enclosed the unit square), is drawing building block, we manipulate obtain more complex drawings.note , if wants follow \"unplugged\" approach, tiles be actually printed objects that students be able experiment them the physical world better introduce themselves the manipulations will follow. is good idea start an asymmetric tile, will it easier grasp effect the transformations will presented.fobserve the dotted line is part the tile serves as hint the tile boundary, moreover tiles are implemented a that notebook automatically draws (without need explicit drawing instructions).transforming tiles¶ are ready introduce transformations, namely rot flip , respectively, rotate counterclockwise ( 90°) tile, flip around vertical center.rot(f)observe the notation is usual for function application, should immediately clear to students to programming ( with basic understanding mathematical notation). course can compose such transformations insomuch function be composed, is performed on result another. first observation is the order which such transformation are performed make difference. consider instance [4]: flip(rot(f)) [5]: rot(flip(f)) second observation is some choices, can seem first restrictive, become less a limitation thanks composition: can obtain clockwise rotations applying three counterclockwise rotations [6]: rot(rot(rot(f))) can stimulate discussion the expressiveness completeness a set primitives respect an assigned set tasks. a few binary transformations ( is, transformation operate two tiles) be introduced, such : above, beside over. first combine tiles juxtaposition (rescaling final result that will again fit a unit square), while latter lay tile another. [7]: beside(f, rot(f)) [8]: above(flip(f), f)again can observe the order the arguments is relevant, the case these transformation, while is in case the latter. [9]: (f, flip(f))basic algebraic facts transformations¶such transformations be implemented binary operators (thanks python ability define classes emulate numeric types); can instance | and / respectively beside above, + for .in [11]: f / ( f | f ) will allow investigate ( a natural syntax) basic algebraic structures (abelian not) semigroups, even monoids, once blank tile is been introduced, well more simple concepts associativity commutativity, [12]: f + blankrecursion¶ can quite natural introduce functions, initially presented a sort macros, build derived operators. instance [13]: def quartet(p, q, r, s): return above(beside(p, q), beside(r, s))is new transformation, defined terms the previous .in [14]: quartet(flip(rot(rot(rot(f)))), rot(rot(rot(f))), rot(f), flip(rot(f))) recursion be introduced quite naturally build tiles having self-similar parts. let's a triangle obtain more pleasing result [15]: trianglelet's build tile where upper left quarter is (rotated) triangle surrounded three tiles similarly defined [16]: def rectri(n): n == 0: return blank else: return quartet(rot(triangle), rectri(n - 1), rectri(n - 1), rectri(n - 1))developing first four levels gives [17]: rectri(4)once even push things further show to of recursion instead iteration, emphasizing expressive simple set basic transformation, endowed composition recursion, become.extending basic transformations¶ if want write nonet, version quartet puts together nine tiles a $3\\times 3$ arrangement? given beside above transformations are halving width height the tiles operate , as is easy convince oneself, is way use to implement nonet. overcome such limitation, can extend those transformations that can specify the relative sizes the combined tiles. instance, in [18]: beside(flip(f), f, 2, 3) flipped f takes $2/5$ the final tile, whereas f takes other $3/5$. using such extended transformations can define [19]: def nonet(p, q, r, s, t, u, v, w, x): return above( beside(p, beside(q, r), 1, 2), above( beside(s, beside(t, u), 1, 2), beside(v, beside(w, x), 1, 2), ), 1, 2 ) obtain desired result [20]: nonet( f, f, f, f, blank, f, f, f, f) course, according the one decomposes $3\\times 3$ tile a combination two sub-tiles, are many alternative ways define nonet students experiment .another possible approach be have above, beside ( over) accept variable number arguments (thanks the functions are defined called python). such case, otaining nonet be trivial.decomposing woodcut¶ basic building block the woodcut is fish [22]: fish if is completely contained a tile ( unit square), escher choose ('ll discuss such magic the following) shape able fit his own rotation [23]: (fish,rot(rot(fish))) this is the magic. let's define new transformation is 45° rotation a rescaling ( a $\\sqrt 2$ factor) , somehow, \"lift \" half tile; using on triangle should clarify definition [24]: rot45(triangle), the fish is magic if transform with such rotation flip in [25]: smallfish = flip(rot45(fish))smallfish obtain new tile will fit the original fish, if rotated again [26]: t = (fish, (smallfish, rot(rot(rot(smallfish)))))t will moreover fit itself however rotated [27]: u = (over((smallfish, rot(smallfish)), rot(rot(smallfish))), rot(rot(rot(smallfish))))u t u tiles defined are building blocks the woodcut; recursive definition the side, based on t is given in [28]: def side(n): n == 0: return blank else: return quartet(side(n-1), side(n-1), rot(t), t)expanding first levels gives [29]: side(2)similarly, recursive definition the corner, based the side u is given in [30]: def corner(n): n == 0: return blank else: return quartet(corner(n-1), side(n-1), rot(side(n-1)), u) before, first levels are [31]: corner(2) now use nonet put together (suitably rotated) sides corners, follows [32]: def squarelimit(n): return nonet( corner(n), side(n), rot(rot(rot(corner(n)))), rot(side(n)), u, rot(rot(rot(side(n)))), rot(corner(n)), rot(rot(side(n))), rot(rot(corner(n))) )expanding first three levels gives [34]: squarelimit(3) magic fish¶ is actually more magic is (the outline) the fish, makes fit himself so many ways, be obtained from simple line [36]: edge can duplicated transformed rot45 obtain left side the fish [37]: outline2 = ( rot45(flip(rot(edge))), rot(rot(rot45(flip(rot(edge))))))outline2 obtain other side the fish need rotate edge to translate outside the boundary the tile can't accomplished the basic transformations introduced above, more directly in [38]: outline3 = tile.transform(rot(edge), t().translate(-1,0))outline3 are ready put together three edges obtain fish [39]: outline = (edge, tile.union(outline3, outline2))outline role the basic edge become more clear we add triangle tile [40]: (triangle, outline) drawing squarelimit using triangle a basic tile helps understanding magic how tiles fit [42]: squarelimit(3)perhaps better we the outline [44]: squarelimit(3)implementation notes¶implementing above primitives be done so many ways, is hard argue will the better.here the drawing is made using matplotlib, probably most common python plotting library; few details our implementation are: * matplotlib.path.path, \"represents series possibly disconnected, possibly closed, line curve segments\" is used a basic building block tiles; * such paths be easily transformed using matplotlib.transforms.affine2d very conveniently perform scaling translations; * once path the desired shape is obtained, can turned a matplotlib.patches.pathpatch can straightforwardly rendered matplotlib.axes.axes.add_patch. course, instead using matplotlib code transformation can the opportunity introduce more detail affine transformations, providing simple \"hand made\" implementation.s"
}