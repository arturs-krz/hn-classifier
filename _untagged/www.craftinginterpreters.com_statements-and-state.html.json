{
	"_id": "14461799",
	"site": "http://www.craftinginterpreters.com/statements-and-state.html",
	"title": " “Statements and State”, the next chapter of my book on interpreters",
	"author": "munificent",
	"date": "2017-06-16T07:57:10.328Z",
	"tags": [],
	"content": "statements state8 * 8.1 statements * 8.2 global variables * 8.3 environments * 8.4 assignment * 8.5 scope * * challenges * noteimplicit variable declaration previous next statements state8 * 8.1 statements * 8.2 global variables * 8.3 environments * 8.4 assignment * 8.5 scope * * challenges * noteimplicit variable declaration previous next 8 statements state book is work progress!× you a mistake, find something unclear, have suggestion, please let know. learn new chapters are , join mailing list:( post once month. dont worry, wont spam .)all life, heart has yearned a thing cannot name.andre breton interpreter have far feels less programming a real language more using calculator. programming me means building a system of smaller pieces. cant that yet we no to bind name some data function. cant compose software without way refer the pieces. support bindings, interpreter needs internal state. you define variable the beginning the program use at end, interpreter has hold to value that variable the meantime. in chapter, will our interpreter brain can just process, butremember.state statements hand hand. since statements, definition, dont evaluate a value, need do something else be useful. something is called side effect. could mean producing user-visible output modifying state the interpreter can detected later. latter makes a great fit defining variables other named entities. could a language treats variable declarations expressions both create binding produce value, im aware any widely-used languages do. scheme seems a contender, note after letexpression is evaluated, variable bound is forgotten. define syntax is an expression. this chapter, ll all that. ll define statements produce output (print) create state (var). ll add expressions access assign variables. finally, ll add blocks local scope. s lot stuff one chapter, well chew through all bite a .8 . 1 statements, well extend loxs grammar statements. arent very different expressions. start the simplest kinds: 1. expression statement lets evaluate expression where statement is expected. exist call functions have side effects. may notice , but use all time c, java, other languages. time see function method call followed a ;, re looking one. pascal is outlier. distinguishes between procedures functions. functions return values, procedures cannot. is statement form calling procedure, functions only called where expression is expected. are statement expressions. 2. print statement evaluates expression displays result the user. admit s weird bake print right the language instead making a library function. doing is concession the fact were building interpreter chapter a and to able play it before s done. make print library function, d to wait until had of machinery defining calling functions before could witness side effects. will note only modicum defensiveness basic python dedicated print statements they are real languages. syntax means grammar rules. this chapter, finally gain ability parse entire lox script. since lox is imperative, dynamically-typed language, top level a script is simply list statements. new rules are:program = statement* eof ;statement = exprstmt | printstmt ;exprstmt = expression \";\" ;printstmt = \"print\" expression \";\" ; first rule is program, is starting point the grammar represents complete lox script repl entry. program is list statements followed the special end file token. mandatory end token ensures parser consumes entire input doesnt silently ignore erroneous unconsumed tokens the end a script.right , statement has cases the kinds statements ve described. ll fill more later this chapter in following ones. next step is turning grammar something can store memory syntax trees.8 . 1 . 1 statement syntax trees are places the grammar where both expression a statement is allowed. operands , say, + are always expressions, never statements. body a while loop is always statement.since two syntaxes are disjoint, dont need single base class they inherit . splitting into separate class hierarchies enables java compiler help find dumb mistakes passing statement a java method expects expression. means new base class statements. our elders did before , we use cryptic name stmt. great foresight, have designed little ast metaprogramming script anticipation this. s why passed expr a parameter defineast(). add another call that defining stmt its subclasses: really foresight: wrote the code the whole book before started slicing things chapters scrawling prose. \"unary : token operator, expr right\" ));tool/generateast.java main() defineast(outputdir, \"stmt\", arrays.aslist( \"expression : expr expression\", \"print : expr expression\", )); }run script behold new stmt.java file the syntax tree classes need expression print statements. dont forgot add to ide project makefile whatever.8 . 1 . 2 parsing statements parsers parse() method parses returns single expression was temporary hack get last chapter and running. that grammar has correct starting rule, program, can turn parse() the real deal:lox/parser.javamethod parse()replace 7 lines list<stmt> parse() { list<stmt> statements = arraylist<>(); while (!isatend()) { statements.add(statement()); } return statements; } parses series statements, many it find until hits end the input. is pretty direct translation the program rule recursive descent style. must chant minor prayer the java verbosity gods since are using arraylist :package com.craftinginterpreters.lox;lox/parser.javaimport java.util.arraylist;import java.util.list; program is list statements, we parse of those statements using:lox/parser.javaadd expression() private stmt statement() { (match(print)) return printstatement(); return expressionstatement(); }s little bare bones, well fill in more statement types later. determines specific statement rule is matched looking the current token. print token means s obviously print statement. the next token doesnt like known kind statement, assume must an expression statement. s typical final fallthrough case parsing statement, since s hard proactively recognize expression its token.each statement kind gets own method. print:lox/parser.javaadd statement() private stmt printstatement() { expr value = expression(); consume(semicolon, \"expect ';' value.\"); return stmt.print(value); }since already matched consumed printtoken itself, doesnt need do here. parses subsequent expression, consumes terminating semicolon, emits syntax tree. parsers writers prefix method name finish it is called some its corresponding grammar rule has already been consumed. a big complex parser, helps maintainers keep track what state token stream is when method is called. loxs little parser, didnt bother. we didnt match print statement, must one these:lox/parser.javaadd printstatement() private stmt expressionstatement() { expr expr = expression(); consume(semicolon, \"expect ';' expression.\"); return stmt.expression(expr); }similar print, parses expression followed a semicolon. wraps expr a stmt returns .8 . 1 . 3 executing statementsre running through previous couple chapters microcosm, working way through front end. parser now produce statement syntax trees, the next final step is interpret . as expressions, use visitor pattern, we a visitor interface, stmt.visitor, implement since statements their own base class. add to list interfaces interpreter implements:lox/interpreter.java class interpreterreplace 1 lineclass interpreter implements expr.visitor<object>, stmt.visitor<void> { void interpret(expr expression) {unlike expressions, statements produce values, the return type the visit methods is void, object. have statement types, we need visit method each. easiest is expression statements: capitalized void might unfamiliar. java doesnt let use lowercase void a generic type argument obscure reasons having do type erasure the stack. instead, is separate void type specifically this . sort like boxed void, integer is int. has one value, null.ve never used for anything the return type visit methods the visitor pattern.lox/interpreter.javaadd evaluate() @override public void visitexpressionstmt(stmt.expression stmt) { evaluate(stmt.expression); return null; } evaluates inner expression using existing evaluate() method discards value (appropriately enough using java expression statement call evaluate()). we return null. java requires to satisfy special capitalized void return type. weird, what you ?the print statements visit method isnt much different:lox/interpreter.javaadd visitexpressionstmt() @override public void visitprintstmt(stmt.print stmt) { object value = evaluate(stmt.expression); system..println(stringify(value)); return null; }before discarding expressions value, converts to string using thestringify() method introduced the last chapter then dumps to stdout. interpreter is ready visit statements , but have work do feed to . first, modify old interpret() method the interpreter class accept list statements other words, program:lox/interpreter.javamethod interpret()replace 8 lines void interpret(list<stmt> statements) { try { (stmt statement : statements) { execute(statement); } } catch (runtimeerror error) { lox.runtimeerror(error); } } replaces old code took single expression. new code relies this tiny helper method:lox/interpreter.javaadd evaluate() private void execute(stmt stmt) { stmt.accept(); }thats statement analogue the evaluate() method have expressions. since re working lists , we need let java :package com.craftinginterpreters.lox;lox/interpreter.javaimport java.util.list;class interpreter implements expr.visitor<object>, stmt.visitor<void> { main lox class is still trying parse single expression pass to interpreter. fix parsing line so: parser parser = parser(tokens);lox/lox.java run()replace 1 line list<stmt> statements = parser.parse(); // stop there was syntax error. then replace call the interpreter this: (haderror) return;lox/lox.java run()replace 1 line interpreter.interpret(statements); }basically plumbing new syntax through. ok, fire the interpreter give a try. this point, s worth sketching a little lox program a text file run a script. something :print \"\";print true;print 2 + 1; almost looks a real program! note the repl too requires to enter full statement instead a simple expression. dont forget semicolons.8 . 2 global variables that have statements, can start working state. before get all the complexity lexical scoping, ll start off the easiest kind variables, globals. requires new constructs. 1. variable declaration statement brings new variable the world: var beverage = \"espresso\"; creates new binding associates name (here beverage) a value (here, string \"espresso\"). 2. once s done, variable expression accesses binding. the identifier beverage is used an expression, looks the value bound that name returns . print beverage; // \"espresso\". later, ll add assignment block scope, thats enough get started.global state gets bad rap. sure, lots global state especially mutablestate makes hard maintain large programs. s software engineering minimize much use. when re slapping together simple programming language , heck, learning first language, flat simplicity global variables helps. first language was basic , though outgrew eventually, was nice i didnt to wrap head around scoping rules before could a computer fun stuff.8 . 2 . 1 variable syntax before, ll through implementation front back, starting the syntax. variable declarations are statements, they are different other statements, were going split statement grammar two handle . thats the grammar restricts where kinds statements are allowed. clauses control flow statements the and else parts an statement the body a while are each single statement. that statement is allowed be that declares name. is ok: (monday) print \"ugh, already?\"; this is :if (monday) var beverage = \"espresso\"; could allow latter, its confusing. is scope thatbeverage variable? it goes past if, it means some cases, variable exists others doesnt. makes really hard the compiler a human reason the code. if variable doesnt live past if, whats point declaring at ?code this is weird, c, java, friends disallow . instead, s if are levels precedence statements. places where statement is allowed inside block at top level allow kind statement, including declarations. others allow higher precedence statements dont declare names. this analogy, block statement, where stuff series statements inside pair curly braces, works sort like parentheses expressions. block statement is itself the higher precedence level can used anywhere, in clauses an statement. the statements itcontains be lower precedence. re allowed declare variables other names inside block. curlies let escape into full statement grammar a place where some statements are allowed. accommodate distinction, add another rule kinds statements declare names:program = declaration* eof ;declaration = vardecl | statement ;statement = exprstmt | printstmt ;declaration statements under new declaration rule. right , its variables, later will include functions classes. place where declaration is allowed allows non-declaring statements, thedeclaration rule falls through statement. obviously, can declare stuff the top level a script, program routes the rule. rule declaring variable looks :vardecl = \"var\" identifier ( \"=\" expression )? \";\" ; most statements starts a leading keyword. this case, var. an identifier token the name the variable being declared, followed an optional initializer expression. finally, put bow it the semicolon. access variable, define new kind primary expression:primary = \"true\" | \"false\" | \"null\" | \"\" | number | string | \"(\" expression \")\" | identifier ; identifier clause matches single identifier token, is understood be name the variable being accessed. new grammar rules their corresponding syntax trees. in ast generator, add new statement tree a variable declaration: \"print : expr expression\",tool/generateast.java main() \"var : token name, expr initializer\", )); stores name token we what s declaring, along the initializer expression. ( there isnt initializer, s null.) we add expression node accessing variable:, we need comma the unary line, is why one is changed too. \"literal : object value\",tool/generateast.java main()replace 1 line \"unary : token operator, expr right\", \"variable : token name\" ));s simply wrapper around token the variable name. s . as always, dont forget run ast generator script that get updated expr.java stmt.java files.8 . 2 . 2 parsing variablesbefore parse variable statements, need shift around code make room the declaration rule the grammar. top level a program is a list declarations, the entrypoint method the parser becomes: list<stmt> parse() { list<stmt> statements = arraylist<>(); while (!isatend()) {lox/parser.java parse()replace 1 line statements.add(declaration()); } return statements; } calls new method:lox/parser.javaadd expression() private stmt declaration() { try { (match(var)) return vardeclaration(); return statement(); } catch (parseerror error) { synchronize(); return null; } }hey, you remember back that earlier chapter we put infrastructure place do error recovery? are finally ready hook up. declaration() method is method call repeatedly parsing series statements a block a script, its right point synchronize when parser goes panic mode. whole body this method is wrapped a try block catch exception thrown the parser begins error recovery. gets back trying parse beginning the next statement declaration. real parsing happens inside try block. , it looks see were a variable declaration looking the leading var keyword. not, bubbles to higher precedence statement method.recall statement() tries parse expression statement no statement matches. expression() reports syntax error it t parse expression the current token. that chain calls ensures report error a valid declaration statement isnt parsed. the parser matches var token, branches :lox/parser.javaadd printstatement() private stmt vardeclaration() { token name = consume(identifier, \"expect variable name.\"); expr initializer = null; (match(equal)) { initializer = expression(); } consume(semicolon, \"expect ';' variable declaration.\"); return stmt.var(name, initializer); } always, recursive descent code follows grammar rule. ve already matched var token, next requires consumes identifier token the variable name., when sees = token, knows is initializer expression. so, parses . otherwise, leaves initializer null. finally, consumes required semicolon the end the statement. this gets wrapped a stmt.var syntax tree node were groovy.parsing variable expression is easier. the primary(), look an identifier token: return expr.literal(previous().literal); }lox/parser.java primary() (match(identifier)) { return expr.variable(previous()); } (match(left_paren)) { gives a working front end declaring using variables. thats left is feed into interpreter. before get that, need talk where variables live memory.8 . 3 environments bindings associate variables values need be stored somewhere. ever since lisp folks invented parentheses, data structure has been called environment. like imagine environment literally, a sylvan wonderland where variables values frolic. can of like map where keys are variable names the values are variables, uh, values. fact, s well implement in java. could stuff map the code manage right interpreter, since forms nicely delineated concept, ll pull out its own class.start new file add:java calls maps hashmaps. languages call hash tables, dictionaries (python c#), hashes (ruby perl), tables (lua), associative arrays (php). back , they were known scatter tables.lox/environment.javacreate filepackage com.craftinginterpreters.lox;import java.util.hashmap;import java.util.map;class environment { private final map<string, object> values = hashmap<>();}s java map there store bindings. uses bare strings the keys, tokens. token represents unit code a specific place the source text, when comes looking variables, identifier tokens the same name should refer the same variable (ignoring scope now). using string ensures of those tokens refer the same map key. are operations need support. , a variable definition binds new name a value:lox/environment.java class environment void define(string name, object value) { values.put(name, value); } exactly brain surgery, we made interesting semantic choice. we add key the map, dont check see if s already present. means this program works:var = \"before\";print ; // \"before\".var = \"after\";print ; // \"after\". variable statement doesnt define new variable, can be used re-define existing variable. could chooseto this error instead. user may intend redefine existing variable. ( they did mean , they probably have used assignment, notvar.) making redefinition error help find bug.however, doing interacts poorly the repl. the middle a repl session, s nice not to mentally track variables ve already defined. could allow redefinition the repl not scripts, then users to learn sets rules, code copied pasted one form the might work. rule variables scoping is, in doubt, what scheme does. scheme folks probably spent more thinking variable scope we ever one the main goals scheme was introduce lexical scoping the world its hard go wrong you follow their footsteps.scheme allows redefining variables the top level., to keep two modes consistent, ll allow (at least global variables). once variable exists, need way look up:lox/environment.java class environment object (token name) { (values.containskey(name.lexeme)) { return values.(name.lexeme); } throw runtimeerror(name, \"undefined variable '\" + name.lexeme + \"'.\"); } is little more semantically interesting. the variable is found, simply returns value bound it. what its ? again, have choice. * it syntax error. * it runtime error. * allow and return default value nil. lox is pretty lax, the last option is little too permissive me. making a syntax error compile error seems a smart choice. using undefined variable is bug, the sooner detect mistake, better. problem is using variable isnt same referring it . you refer a variable a chunk code without immediately evaluating if chunk code is wrapped inside function. we it static error mention variable before s been declared, becomes much harder define recursive functions. could accommodate single recursion function calls itself declaring functions own name before examine body. that doesnt help mutually recursive procedures call each . consider:fun isodd(n) { (n == 0) return false; return iseven(n - 1);}fun iseven(n) { (n == 0) return true; return isodd(n - 1);}granted, is probably the efficient to tell a number is or odd ( to mention bad things happen you pass non-integer negative number them). bear me. iseven() function isnt defined the we are looking the body isodd() where s called. we swap order the functions, isodd() isnt defined were looking atiseven()s body. statically-typed languages java c# solve by specifying the top level a program isnt sequence imperative statements. instead, program is set declarations all into being simultaneously. implementation declares of names before looking the bodies anyof functions.older languages c pascal dont like . instead, force to add explicit forward declarations declare name before s fully defined. was concession the limited computers the . they wanted be able compile source file one single pass through text, those compilers couldnt gather all the declarations before processing function bodies.since making a static error makes recursive declarations too difficult, ll defer error runtime. s ok refer a variable before s defined long you dont evaluate reference. lets program even odd numbers , but d a runtime error :print ;var = \"too late!\"; with type errors the expression evaluation code, report runtime error throwing exception, giving the token the variable we tell user where their code messed .8 . 3 . 1 interpreting global variables interpreter class gets instance the environment class:class interpreter implements expr.visitor<object>, stmt.visitor<void> {lox/interpreter.java class interpreter private environment environment = environment(); void interpret(list<stmt> statements) { store as field directly interpreter that variables stay memory long the interpreter is still running. have new syntax trees, thats new visit methods. first is declaration statements:lox/interpreter.javaadd visitprintstmt() @override public void visitvarstmt(stmt.var stmt) { object value = null; (stmt.initializer != null) { value = evaluate(stmt.initializer); } environment.define(stmt.name.lexeme, value); return null; } the variable has initializer, evaluates . if , we another choice make. could it syntax error requiring initializer. languages dont, though, it feels little harsh do in lox. could it runtime error. d let define uninitialized variable, if accessed before assigning it, runtime error occur. s a bad idea, most dynamically typed languages dont that. instead, ll keep simple say lox sets variable nil it isnt explicitly initialized:var ;print ; // \"nil\".thus, there isnt initializer, set value null, is java representation loxs nil value. we tell environment bind variable that value.next, evaluate variable expression:lox/interpreter.javaadd visitunaryexpr() @override public object visitvariableexpr(expr.variable expr) { return environment.(expr.name); } simply forwards the environment does heavy lifting make sure variable is defined. that, ve got rudimentary variables working. try out:var = 1;var b = 2;print + b; cant reuse code yet, we start build programs reusedata.8 . 4 assignments possible create language has variables does let reassign, mutate, . haskell is example. sml supports mutable references arrays variables cannot re-assigned. rust steers away mutation requiring mut modifier enable assignment.mutating variable is side effect , as name suggests, language folks side effects are dirty inelegant. code should pure math produces values crystalline, unchanging ones an act divine creation. some grubby automaton beats blobs data shape, imperative grunt a .i find delightful the same group people pride themselves dispassionate logic are the ones cant resist emotionally-loaded terms their : pure, side effect, lazy, persistent, -class, higher-order.lox is so austere. lox is imperative language, mutation comes the territory. adding support assignment doesnt require much . global variables already support redefinition, most the machinery is now. mainly, re missing explicit assignment notation.8 . 4 . 1 assignment syntax little = syntax is more complex it might seem. most c-derived languages, assignment is expression not statement. in c, is lowest precedence expression form. means rule slots between expression equality, next lowest precedence expression: some languages, pascal, python, go, assignment is statement.expression = assignment ;assignment = identifier ( \"=\" assignment )? | equality ; says assignment is either identifier followed an = an expression the value, an equality ( thus other) expression. later, assignment get more complex we add property setters objects, :instance.field = \"value\"; easy part is adding new syntax tree node: defineast(outputdir, \"expr\", arrays.aslist(tool/generateast.java main() \"assign : token name, expr value\", \"binary : expr left, token operator, expr right\", has token the variable being assigned , and expression the value. you run astgenerator get new expr.assign class, swap the body the parsers existing expression() method match updated rule: private expr expression() {lox/parser.java expression()replace 1 line return assignment(); }here is where gets tricky. single token lookahead recursive descent parser t far enough tell its parsing assignment until it has gone through left-hand side stumbled onto =. you might wonder why even needs . after , we dont were parsing + expression until weve finished parsing left operand. difference is the left-hand side an assignment isnt expression evaluates a value. s sort pseudo-expression evaluates a thing can assign . in:var = \"before\"; = \"value\"; the second line, dont evaluate (which return string before). figure what variable refers so know where store right-hand side expressions value. classic terms these constructs are lvalue rvalue. of expressions weve seen far produce values are rvalues. lvalue evaluates a storage location you assign .in fact, names from assignment expressions. l-values appear theleft side the = an assignment, r-values the right. an lvalue isnt evaluated a normal expression, syntax tree must reflect . thats why expr.assign node has token the left-hand side, an expr. problem is the parser doesnt its parsing lvalue until hits =. in complex lvalue, may occur many tokens later:makelist().head.next = node; fact, since receiver a field assignment be expression, expressions be long you to them, may an unbounded number tokens lookahead find =.we have single token lookahead, what we ? we a little trick, it looks this:lox/parser.javaadd expressionstatement() private expr assignment() { expr expr = equality(); (match(equal)) { token equals = previous(); expr value = assignment(); (expr instanceof expr.variable) { token name = ((expr.variable)expr).name; return expr.assign(name, value); } error(equals, \"invalid assignment target.\"); } return expr; } of code parsing assignment expression looks similar the binary operators +. we parse left-hand side, can any expression higher precedence. we find =, we parse right-hand side then wrap all in assignment expression tree node. slight difference binary operators is we dont loop build a sequence the same operator. since assignment is right-associative, instead recursively call assignment() parse right-hand side. trick is right before create assignment expression node, look the left-hand side expression figure what kind assignment target is. convert rvalue expression node an lvalue representation. trick works it turns that every valid assignment target happens also valid syntax a normal expression. consider complex field assignment :you still this trick if are assignment targets are valid expressions. define cover grammar, looser grammar accepts both of valid expression assignment target syntaxes. you hit =, report error the left-hand side isnt within valid assignment target grammar. conversely, you dont hit =, report error the left-hand side isnt valid expression.newpoint(x + 2, 0).y = 3; left-hand side that assignment also as valid expression:newpoint(x + 2, 0).y;(where first example sets field, second gets .)this means can parse left-hand side if were expression then the fact produce syntax tree turns into assignment target. the left-hand side expression isnt validassignment target, fail a syntax error. ensures report error code :a + b = c; you remember back the parsing chapter i said represent parenthesized expressions the syntax tree well need later. is why. need keep track them that can distinguish between: = 3; // ok.() = 3; // error.right , the valid target is simple variable expression, well add fields later. end result this trick is assignment expression tree node knows it is assigning and has expression subtree the value being assigned. with a single token lookahead no backtracking.8 . 4 . 2 assignment semantics have new syntax tree node, our interpreter gets new visit method:lox/interpreter.javaadd visitvarstmt() @override public object visitassignexpr(expr.assign expr) { object value = evaluate(expr.value); environment.assign(expr.name, value); return value; } obvious reasons, s similar variable declaration. evaluates right-hand side get value, stores in named variable. instead using define() environment, calls new method:lox/environment.javaadd get() void assign(token name, object value) { (values.containskey(name.lexeme)) { values.put(name.lexeme, value); return; } throw runtimeerror(name, \"undefined variable '\" + name.lexeme + \"'.\"); } key difference between assignment definition is assignment is notallowed create new variable. terms our implementation, means s runtime error the key doesnt already exist the environments variable map.unlike python ruby, lox doesnt implicit variable declaration. last thing visit() method does is return assigned value. s assignment is expression can nested inside expressions, so:var = 1;print = 2; // \"2\". interpreter now create, read, modify variables. s as sophisticated early basics. global variables are simple, writing large program any chunks code accidentally step each s state is fun. want local variables, means s for scope.maybe little better that. unlike old basics, lox handle variable names longer two characters8 . 5 scope scope is region where name maps a certain entity. multiple scopes enable same name refer different things different contexts. my house, bob usually refers me. maybe your town know different bob. same name, different entities based where use .lexical scope ( the less common static scope) is specific style scope where text the program itself shows where scope begins ends. lox, in modern languages, variables are lexically scoped. you an expression uses variable, can figure which variable declaration refers just statically reading code.lexical comes the greek lexikos means related words. we it programming languages, usually means thing can figure from source code itself without having execute anything.lexical scope came onto scene algol. earlier languages were often dynamically scoped. believed dynamic scope was faster execute. today, thanks early scheme hackers, know isnt true. anything, s opposite.dynamic scope variables lives some corners. emacs lisp defaults dynamic scope variables. binding macro clojure provides . the widely-disliked statement javascript turns properties an object dynamically-scoped variables. example:{ var = \"first\"; print ; // \"first\".}{ var = \"second\"; print ; // \"second\".}here, have blocks a variable is declared each them. and can tell from looking the code the of in first print refers the a, the second refers the second. is contrast dynamic scope where dont what name refers until execute code. lox doesnt dynamically scopedvariables, methods fields objects are dynamically scoped:class saxophone { play() { print \"careless whisper\"; }}class golfclub { play() { print \"fore!\"; }}fun playit(thing) { thing.play();} playit() calls thing.play(), dont if re to hear careless whisper fore!. depends whether pass saxophone a golfclub the function, we dont that until runtime.scope environments are close cousins. former is theoretical concept, the latter machinery implements . as interpreter works way through code, syntax tree nodes affect scope change environment. a c-ish syntax loxs, scope is controlled curly-braced blocks.s why call block scope.{ var = \"in block\";}print ; // error! more \"\".the beginning a block introduces new local scope, that scope ends execution passes closing }. variables declared inside block disappear.8 . 5 . 1 nesting shadowing first cut implementing block scope might like : 1. we visit each statement inside block, keep track any variables declared. 2. the last statement is executed, tell environment delete of those variables. would for previous example. , remember, motivation local scope is encapsulation block code one corner the program shouldnt interfere some one. check out:var count = 0;// everytime is called, increments prints count.fun increment() { count = count + 1; print count;}fun sumtoten() { var sum = 0; (var count = 1; count <= 10; count = count + 1) { sum = sum + count; } print sum;} imagine calling sumtoten(). the loop finishes, interpreter delete global count variable. aint right. we exit block, should remove variables declared inside block, if is variable the same name declared outside the block, s different variable. doesnt touched. a local variable has same name a variable an enclosing scope, itshadows outer . code inside block t it more ( is hidden the shadow cast the inner ), but s still .when enter new block scope, need preserve variables defined outer scopes they are still around we exit inner block. do by defining fresh environment each block containing the variables defined that scope. we exit block, discard environment restore previous .we need handle enclosing variables are shadowed:var global = \"outside\";{ var local = \"inside\"; print global + local;}here, global lives the outer global environment local is defined inside blocks environment. that print statement, both those variables are scope. order find , the interpreter must search only current innermost environment, also enclosing ones. implement by chaining environments together. each environment has reference the environment the immediately enclosing scope. we up variable, walk chain innermost until find variable. starting the inner scope is we local variables shadow outer ones. any point time while interpreter is running, environments form linear list objects. consider full set environments are created during entire execution. outer scope may multiple blocks nested within , and each point the outer , giving tree- structure, though a single path through tree exists any point time. boring name this is parent-pointer tree, i much prefer evocative cactus stack.before add block syntax the grammar, ll beef our environment class support this nesting. , we each environment reference its enclosing :class environment {lox/environment.java class environment final environment enclosing; private final map<string, object> values = hashmap<>(); field needs be initialized, we add couple constructors:lox/environment.java class environment environment() { enclosing = null; } environment(environment enclosing) { .enclosing = enclosing; } no-argument constructor is the global scopes environment, ends chain. other constructor creates new local scope nested inside given outer .we dont to touch define() method new variable is always declared the current innermost scope. variable lookup assignment with existing variables they need walk chain find . first, lookup: return values.(name.lexeme); }lox/environment.java get() (enclosing != null) return enclosing.(name); throw runtimeerror(name, \"undefined variable '\" + name.lexeme + \"'.\"); the variable isnt found this scope, simply try enclosing . that turn does same thing recursively, this ultimately walk entire chain. assignment rolls same :its faster iteratively walk chain, i the recursive solution is prettier. ll something much faster clox. values.put(name.lexeme, value); return; }lox/environment.java assign() (enclosing != null) { enclosing.assign(name, value); return; } throw runtimeerror(name,again, the variable isnt this environment, checks outer , recursively.8 . 5 . 2 block syntax semantics that environments nest, re ready add blocks the language. behold grammar:statement = exprstmt | printstmt | block ;block = \"{\" declaration* \"}\" ;s (possibly empty) series statements declarations surrounded curly braces. block is itself statement can appear anywhere statement is allowed. syntax tree node looks this: defineast(outputdir, \"stmt\", arrays.aslist(tool/generateast.java main() \"block : list<stmt> statements\", \"expression : expr expression\", contains list statements are inside block. parsing is straightforward. other statements, detect beginning a block its leading token this case {. in thestatement() method, add: always, dont forget run generateast.java. (match(print)) return printstatement();lox/parser.java statement() (match(left_brace)) return stmt.block(block()); return expressionstatement(); the real happens here:lox/parser.javaadd expressionstatement() private list<stmt> block() { list<stmt> statements = arraylist<>(); while (!check(right_brace) && !isatend()) { statements.add(declaration()); } consume(right_brace, \"expect '}' block.\"); return statements; } creates empty list then parses statements adds to list until reaches end the block, marked the closing }. note the loop has explicit check isatend(). have be careful avoid infinite loops, when parsing invalid code. the user forgot closing}, parser needs not stuck.s for syntax. semantics, add another visit method interpreter:lox/interpreter.javaadd execute() @override public void visitblockstmt(stmt.block stmt) { executeblock(stmt.statements, environment(environment)); return null; } execute block, create new environment the blocks scope pass off this method:lox/interpreter.javaadd execute() void executeblock(list<stmt> statements, environment environment) { environment previous = .environment; try { .environment = environment; (stmt statement : statements) { execute(statement); } } finally { .environment = previous; } } executes list statements the context a given environment. until , the environment field interpreter always pointed the same environment global . now, field represents current environment. s environment corresponds the innermost scope containing code be executed. execute code within given scope, method updates interpretersenvironment field, visits of statements, then restores previous value. is always practice java, restores previous environment using finally clause. way gets restored if exception is thrown.explicitly changing restoring mutable environment field may seem little inelegant. another classic approach explicitly pass environment a parameter each visit method. change enviroment, pass different as recurse down tree. dont to restore old , since new lives the java stack is implicitly discarded the interpreter returns the blocks visit method. considered for jlox, its kind tedious verbose adding environment parameter every single visit method.surprisingly, s we need do order fully support local variables, nesting, shadowing. ahead try out:var = \"global \";var b = \"global b\";var c = \"global c\";{ var = \"outer \"; var b = \"outer b\"; { var = \"inner \"; print ; print b; print c; } print ; print b; print c;}print ;print b;print c; little interpreter remember things . we are inching closer something resembling full-featured programming language.challenges 1. repl longer supports entering single expression automatically printing result value. s drag. add support the repl let users type both statements expressions. they enter statement, execute . if enter expression, evaluate and display result value. 2. maybe want lox be little more explicit variable initialization. instead implicitly initializing variables nil, it runtime error access variable has been initialized assigned , as : // no initializers. var ; var b; = \"assigned\"; print ; // ok, was assigned . print b; // error! 3. does following program ? var = 1; { var = a + 2; print ; } what did expect to ? is what think should ? what does analogous code other languages are familiar do? do think users expect to ? design note: implicit variable declarationlox has distinct syntax declaring new variable assigning an existing . some languages collapse those only assignment syntax. assigning a non-existent variable automatically brings into being. is calledimplicit variable declaration exists python, ruby, coffeescript, among others. javascript has explicit syntax declare variables, can create variables assignment. visual basic has option enable disable implicit variables. the same syntax assign create variable, each language must decide happens it isnt clear which behavior user intends. particular, each language must choose implicit declaration interacts shadowing, which scope implicitly declared variable goes . * in python, assignment always creates variable the current functions scope, if is variable the same name declared outside the function. * ruby avoids ambiguity having different naming rules local global variables. however, blocks ( are more closures like blocks c) ruby their own scope, it still has problem. assignment ruby assigns an existing variable outside the current block there is with same name. otherwise, creates new variable the current blocks scope. * coffeescript, takes ruby many ways, is similar. explicitly disallows shadowing saying assignment always assigns a variable an outer scope there is , all way to outermost global scope. otherwise, creates variable the current function scope. * javascript, assignment modifies existing variable any enclosing scope, found. not, implicitly creates new variable the global scope. main advantage implicit declaration is simplicity. s less syntax no declaration concept learn. users just start assigning stuff the language figures out.older statically typed languages c benefit explicit declaration they the user place tell compiler type each variable has how much storage allocate it. a dynamically typed, garbage collected language, isnt really necessary, you get away making declarations implicit. feels little more scripty, more know i mean. is a idea? implicit declaration has problems. * user may intend assign an existing variable, may misspelled . the interpreter doesnt that, it goes ahead silently creates new variable the variable user wanted assign still has old value. is particularly heinous javascript where typo create global variable, may turn interfere other code. * js, ruby, coffeescript the presence an existing variable some name in outer scope determine whether not assignment creates new variable assigns an existing . that means adding new variable a surrounding scope change meaning existing code. was once local variable may silently turn an assignment that outer variable. * python, may to assign some variable outside the current function instead creating new variable the current , but cant. time, languages know implicit variable declaration ended adding more features complexity deal these problems. * implicit declaration global variables javascript is universally considered mistake today. strict mode disables and makes a compile error. * python added global statement let explicitly assign a global variable within function. later, a functional programming style nested functions became more popular, added similar nonlocalstatement assign variables enclosing functions. * ruby extended block syntax allow declaring certain variables be explicitly local the block if same name exists an outer scope. given those, think simplicity argument is mostly lost. is argument implicit declaration is right default i personally find less compelling. opinion is implicit declaration made sense years past most scripting languages were heavily imperative code was pretty flat. programmers got more comfortable deep nesting, functional programming, closures, s become much more common want access variables outer scopes. makes more likely users run the tricky cases where s clear whether intend assignment create new variable reuse surrounding .so prefer explicitly declaring variables, is why lox requires .next chapter: control flow hand-crafted robert nystrom © 2015 2017"
}