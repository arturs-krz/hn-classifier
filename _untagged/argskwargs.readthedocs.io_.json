{
	"_id": "14523905",
	"site": "https://argskwargs.readthedocs.io/",
	"title": " Argskwargs, flexible python lib for positional and keyword arguments",
	"author": "wbolster",
	"date": "2017-06-14T12:56:09.504Z",
	"tags": [],
	"content": "argskwargs latest * argskwargs * installation * usage * api * contributing * license argskwargs * docs » * argskwargs * edit github argskwargs¶argskwargs is small python library provides flexible container positional keyword arguments.installation¶pip install argskwargsusage¶ tiny library provides small container class hold arbitrary positional arguments (args) keyword arguments (kwargs).argskwargs module is essentially same a (args, kwargs) tuple, with nice small api top keep code simple clear. you to pass around args kwargs without invoking function will eventually end taking those arguments, typically uses variables hold args tuple akwargs dict. argskwargs simplifies clunky error-prone code pattern. can consider argskwargs missing companion tofunctools.partial() the python standard library.argskwargs lets treat combination args kwargsas single object without attaching to function ( another callable), functools.partial() do.here is example:>>> argskwargs import argskwargs>>> my_args = argskwargs(1, 2, foo='bar')>>> my_argsargskwargs(1, 2, foo='bar') my_args variable simply holds arguments passed it. lets a function simply prints anything is passed it:>>> import pprint>>> def print_arguments(*args, **kwargs):... print('positional arguments ' + str(args))... print('keyword arguments ' + pprint.pformat(kwargs)) can invoke directly this accessing .args .kwargs attributes ( hold tuple a list, respectively):>>> print_arguments(*my_args.args, **my_args.kwargs)positional arguments (1, 2)keyword arguments {'foo': 'bar'}alternatively, can unpack argskwargs object obtain tuple a dict:>>> x, y = my_args>>> x(1, 2)>>> y{'foo': 'bar'} far is arguably any better directly callingprint_arguments(*some_args, **some_kwargs) using variables. , lets what makes argskwargs useful.here is another to the same using .apply() method:>>> my_args.apply(print_arguments)positional arguments (1, 2)keyword arguments {'foo': 'bar'}since is typical case argskwargs, can omit .apply() call instance directly:>>> my_args(print_arguments)positional arguments (1, 2)keyword arguments {'foo': 'bar'}magic! you see code is inverted: callable is passed the arguments, instead the way around. for more magic: assume we to pass more arguments toprint_arguments those stored the argskwargs instance. pass in:>>> my_args(print_arguments, 'another', oh='yes')positional arguments (1, 2, 'another')keyword arguments {'foo': 'bar', 'oh': 'yes'} you want extend arguments without calling function, the .copy() method, does exactly :>>> more_args = my_args.copy(3, 4, abc='xyz')>>> more_argsargskwargs(1, 2, 3, 4, abc='xyz', foo='bar')>>> more_args(print_arguments)positional arguments (1, 2, 3, 4)keyword arguments {'abc': 'xyz', 'foo': 'bar'} descibed above, argskwargs is companion tofunctools.partial(). can directly create partial functions using .partial() method:>>> f = my_args.partial(print_arguments)>>> f()positional arguments (1, 2)keyword arguments {'foo': 'bar'} completeness, can pass more arguments one , but may to avoid for own sanity:>>> g = my_args.partial(print_arguments, 'insane', foo='foofoo')>>> g()positional arguments (1, 2, 'insane')keyword arguments {'foo': 'foofoo'}hopefully demonstrated usefulness argskwargs, by means it, please keep mantra mind:simple is better complex.happy hacking!api¶contributing¶ source code issue tracker this package be found github:https://github.com/wbolster/argskwargslicense¶..include:: ../license.rst© copyright wouter bolsterlee. revision 662052f6. built sphinx using theme provided read docs. read docsv: latest versions latest stable downloads pdf htmlzip epub read docs project home builds free document hosting provided read docs."
}