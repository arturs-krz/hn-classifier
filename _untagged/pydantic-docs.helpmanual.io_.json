{
	"_id": "14477222",
	"site": "https://pydantic-docs.helpmanual.io/",
	"title": " Pydantic – Data validation using Python 3.6 type hinting",
	"author": "scolvin",
	"date": "2017-06-16T07:56:42.081Z",
	"tags": [],
	"content": "pydantic¶ current version: 0.2.1data validation settings management using python 3.6 type hinting.define data should in pure, canonical python; validate with pydantic.pep 484 introduced type hinting python 3.5,pep 526 extended with syntax variable annotation python 3.6.pydantic uses those annotations validate untrusted data takes form want.example: datetime import datetime typing import list pydantic import basemodelclass user(basemodel): id: int name = 'john doe' signup_ts: datetime = none friends: list[int] = []external_data = {'id': '123', 'signup_ts': '2017-06-01 12:22', 'friends': [1, '2', b'3']}user = user(**external_data)print(user)# > user id=123 name='john doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]print(user.id)# > 123( script is complete, should run is)s going here: * id is type int; annotation declaration tells pydantic this field is required. strings, bytes floats be coerced ints possible, otherwise exception be raised. * name is inferred a string the default, is required it has default. * signup_ts is datetime field is required (none its supplied), pydantic process either unix timestamp int (e.g. 1496498400) a string representing date & . * friends uses pythons typing system, is required be list integers, with id integer- objects be converted integers. validation fails pydantic raise error a breakdown what was wrong: pydantic import validationerrortry: user(signup_ts='broken', friends=[1, 2, ' number'])except validationerror e: print(e.json())\"\"\"{ \"friends\": [ { \"error_msg\": \"invalid literal int() base 10: ' number'\", \"error_type\": \"valueerror\", \"index\": 2, \"track\": \"int\" } ], \"id\": { \"error_msg\": \"field required\", \"error_type\": \"missing\", \"index\": null, \"track\": null }, \"signup_ts\": { \"error_msg\": \"invalid datetime format\", \"error_type\": \"valueerror\", \"index\": null, \"track\": \"datetime\" }}\"\"\"rationale¶ pydantic uses cool language feature, why should actually an it? brainfuckno schema definition micro-language learn. you python ( perhaps skim read thetype hinting docs) know to pydantic.plays nicely your ide/linter/brainbecause pydantic data structures are instances classes define; auto-completion, linting,mypy your intuition should work properly your validated data.dual usepydantics basesettings class allows to used both validate request data context load system settings context. main difference being system settings can defaults changed environment variables more complex objects dsns python objects often required.fastin benchmarks pydantic is around twice fast trafaret. comparisons cerberus, marshmallow, drf, jsonmodels etc. come.validate complex structuresuse recursive pydantic models typings list dict etc. allow complex data schemas be clearly easily defined.extendiblepydantic allows custom data types be defined you extend validation the clean_* methods a model.install¶:pip install pydanticpydantic has dependencies except python 3.6+. youve got python 3.6 pip installed - re to .usage¶pep 484 types¶pydantic uses typing types define more complex objects. typing import dict, list, optional, union, set pydantic import basemodelclass model(basemodel): simple_list: list = none list_of_ints: list[int] = none simple_dict: dict = none dict_str_float: dict[str, float] = none simple_set: set = none set_bytes: set[bytes] = none str_or_bytes: union[str, bytes] = none none_or_str: optional[str] = none compound: dict[union[str, bytes], list[set[int]]] = noneprint(model(simple_list=['1', '2', '3']).simple_list) # > ['1', '2', '3']print(model(list_of_ints=['1', '2', '3']).list_of_ints) # > [1, 2, 3]print(model(simple_dict={'': 1, b'b': 2}).simple_dict) # > {'': 1, b'b': 2}print(model(dict_str_float={'': 1, b'b': 2}).dict_str_float) # > {'': 1.0, 'b': 2.0}( script is complete, should run is)choices¶pydantic uses pythons standard enum classes define choices. enum import enum, intenum pydantic import basemodelclass fruitenum(str, enum): pear = 'pear' banana = 'banana'class toolenum(intenum): spanner = 1 wrench = 2class cookingmodel(basemodel): fruit: fruitenum = fruitenum.pear tool: toolenum = toolenum.spannerprint(cookingmodel())# > cookingmodel fruit=<fruitenum.pear: 'pear'> tool=<toolenum.spanner: 1>print(cookingmodel(tool=2, fruit='banana'))# > cookingmodel fruit=<fruitenum.banana: 'banana'> tool=<toolenum.wrench: 2>print(cookingmodel(fruit=''))# will raise validation error( script is complete, should run is)recursive models¶more complex hierarchical data structures be defined using models types annotations themselves. ellipsis ... means required same annotation declarations above. typing import list pydantic import basemodelclass foo(basemodel): count: int = ... size: float = noneclass bar(basemodel): apple = 'x' banana = 'y'class spam(basemodel): foo: foo = ... bars: list[bar] = ...m = spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])print(m)# > spam foo=<foo count=4 size=none> bars=[<bar apple='x1' banana='y'>, <bar apple='x2' banana='y'>]print(m.values())# {'foo': {'count': 4, 'size': none}, 'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}]}( script is complete, should run is)error handling¶ typing import list pydantic import basemodel, validationerrorclass location(basemodel): lat = 0.1 lng = 10.1class model(basemodel): list_of_ints: list[int] = none a_float: float = none is_required: float = ... recursive_model: location = nonetry: model(list_of_ints=['1', 2, 'bad'], a_float=' a float', recursive_model={'lat': 4.2, 'lng': ' york'})except validationerror e: print(e)\"\"\"4 errors validating inputlist_of_ints: invalid literal int() base 10: 'bad' (error_type=valueerror track=int index=2)a_float: not convert string float: ' a float' (error_type=valueerror track=float)is_required: field required (error_type=missing)recursive_model: 1 error validating input (error_type=validationerror track=location) lng: not convert string float: ' york' (error_type=valueerror track=float\"\"\"try: model(list_of_ints=1, a_float=none, recursive_model=[1, 2, 3])except validationerror e: print(e.json())\"\"\"{ \"is_required\": { \"error_msg\": \"field required\", \"error_type\": \"missing\", \"index\": null, \"track\": null }, \"list_of_ints\": { \"error_msg\": \"'int' object is iterable\", \"error_type\": \"typeerror\", \"index\": null, \"track\": null }, \"recursive_model\": { \"error_msg\": \"cannot convert dictionary update sequence element #0 a sequence\", \"error_type\": \"typeerror\", \"index\": null, \"track\": \"location\" }}\"\"\"( script is complete, should run is)exotic types¶pydantic comes a number utilities parsing validating common objects. pathlib import path pydantic import dsn, basemodel, emailstr, nameemail, pyobject, conint, constr, positiveint, negativeintclass model(basemodel): cos_function: pyobject = none path_to_something: path = none short_str: constr(min_length=2, max_length=10) = none regex_str: constr(regex='apple (pie|tart|sandwich)') = none big_int: conint(gt=1000, lt=1024) = none pos_int: positiveint = none neg_int: negativeint = none email_address: emailstr = none email_and_name: nameemail = none db_name = 'foobar' db_user = 'postgres' db_password: str = none db_host = 'localhost' db_port = '5432' db_driver = 'postgres' db_query: dict = none dsn: dsn = nonem = model( cos_function='math.cos', path_to_something='/home', short_str='foo', regex_str='apple pie', big_int=1001, pos_int=1, neg_int=-1, email_address='samuel colvin <s@muelcolvin.com >', email_and_name='samuel colvin <s@muelcolvin.com >',)print(m.values())\"\"\"{ 'cos_function': <built- function cos>, 'path_to_something': posixpath('/home'), 'short_str': 'foo', 'regex_str': 'apple pie', 'big_int': 1001, 'pos_int': 1, 'neg_int': -1, 'email_address': 's@muelcolvin.com', 'email_and_name': <nameemail(\"samuel colvin <s@muelcolvin.com>\")>, ... 'dsn': 'postgres://postgres@localhost:5432/foobar'}\"\"\"( script is complete, should run is)model config¶behaviour pydantic be controlled via config class a model.here default config parameter are shown together their meaning. pydantic import basemodelclass usermodel(basemodel): id: int = ... class config: min_anystr_length = 0 # min length str & byte types max_anystr_length = 2 ** 16 # max length str & byte types min_number_size = -2 ** 64 # min size numbers max_number_size = 2 ** 64 # max size numbers raise_exception = true # whether not raise exception the data is invalid validate_all = false # whether not validate field defaults ignore_extra = true # whether ignore extra values input data allow_extra = false # whether not too allow ( include the model) extra values input data fields = none # extra information each field, currently \"alias is allowed\"settings¶ of pydantics useful applications is define default settings, allow to overridden environment variables keyword arguments (e.g. unit tests). usage example comes last it uses numerous concepts described above. pydantic import dsn, basesettings, pyobjectclass settings(basesettings): redis_host = 'localhost' redis_port = 6379 redis_database = 0 redis_password: str = none auth_key: str = ... invoicing_cls: pyobject = 'path..invoice' db_name = 'foobar' db_user = 'postgres' db_password: str = none db_host = 'localhost' db_port = '5432' db_driver = 'postgres' db_query: dict = none dsn: dsn = none class config: env_prefix = 'my_prefix_' # defaults 'app_' fields = { 'auth_key': { 'alias': 'my_api_key' } }here redis_port be modified via export my_prefix_redis_port=6380 auth_key byexport my_api_key=6380.usage mypy¶pydantic works mypy provided use annotation version required variables: datetime import datetime typing import list, optional pydantic import basemodel, nonestrclass model(basemodel): age: int first_name = 'john' last_name: nonestr = none signup_ts: optional[datetime] = none list_of_ints: list[int]m = model(age=42, list_of_ints=[1, '2', b'3'])print(m.age)# > 42model()# raise validation error age list_of_ints script is complete, should run is. can run through mypy :mypy --ignore-missing-imports --follow-imports=skip --strict-optional pydantic_mypy_test.pystrict optional¶ your code pass --strict-optional need to optional[] an alias optional[] all fields none default, is standard mypy.pydantic provides few useful optional union types: * nonestr aka. optional[str] * nonebytes aka. optional[bytes] * strbytes aka. union[str, bytes] * nonestrbytes aka. optional[strbytes] these arent sufficient can course define own.required fields mypy¶ ellipsis notation ... not with mypy, need use annotation fields in example above.warning aware using annotation fields alter order your fields metadata errors: annotation fields always last, still the order were defined. get round you use required (via pydantic import required) field an alias ellipses annotation .history¶v0.2.1 (2017-06-07)¶ * pypi travis together messed the deploy v0.2 should fix v0.2.0 (2017-06-07)¶ * breaking change: values() a model is a method a property, takes include exclude arguments * allow annotation fields support mypy * add pretty to_string(pretty=true) method modelsv0.1.0 (2017-06-03)¶ * add docs * add historypydantic table contents * pydantic * rationale * install * usage * pep 484 types * choices * recursive models * error handling * exotic types * model config * settings * usage mypy * strict optional * required fields mypy * history * v0.2.1 (2017-06-07) * v0.2.0 (2017-06-07) * v0.1.0 (2017-06-03)"
}