{
	"_id": "14513021",
	"site": "https://performancejs.com/post/ewffd34/Introducing:-Lazy-arrays-in-JavaScript",
	"title": " Bringing lazy streams to JavaScript",
	"author": "bcherny",
	"date": "2017-06-14T12:56:09.738Z",
	"tags": [],
	"content": "performancejs blog boris cherny * blog * css1 * clojure1 * functional programming2 * haskell1 * js2 * ruby1 * sass1 * scala1 * * contact * githubintroducing: lazy arrays javascripttoday m introducing lazy-arr, brings lazy arrays javascript.s lazy array why is useful?flashback your job interview your software engineering job: lets write fibonacci function. define base cases 0 1, recurse generate rest:let fib = n => { switch (n) { case 0: return 0 case 1: return 1 default: return fib(n - 1) + fib(n - 2) }}easy peezy.s problem this solution? duh - s really really inefficient. compute nth fibonacci number, call fib 2n-1 times! clearly sucks, we should better. way do is memoize output fib. is, since fib is pure idempotent can cache output:let memoize = fn => { let cache = map return _ => { (!cache.has(_)) { cache.set(_, fn(_)) } return cache.(_) }}let fib = memoize(n => { switch (n) { case 0: return 0 case 1: return 1 default: return fib(n - 1) + fib(n - 2) }})ah, better! we call fib n - 1 times an input size n. else we express ?lazy sequences scala, can it this (credit philipp gabler):def fib(n: int): stream[int] = { lazy val stream: stream[int] = 0 #:: stream.scan(1)(_ + _) stream.(n)} that does is define lazy stream numbers ( initial numbers, plus function generates more numbers), when call fib(n) returns nth number, generates returns if hasnt been computed yet. another to about is a generator plus cache keeps track previously generated values, you then access the values index.lazy streams are really cool abstraction working sequences are either expensive calculate, impossible calculate all indices (ie. infinite sequences). re popular functional languages, especially languages lazy evaluation default. example heres you it haskell:fibs :: [integer]fibs = 0 : 1 : zipwith (+) fibs (tail fibs) same idea, in clojure:(defn fib [] ((fn rfib [ b] (cons (lazy-seq (rfib b (+ b))))) 0 1)) get picture. how you that javascript?lazy sequences javascript lazy-arr, do like :let fibs = lazy([0, 1])(_ => fibs[_ - 1] + fibs[_ - 2])s ! then can access items the array needed, theyll computed demand:fibs[10] // 55fibs[7] // 13 first line computes 10th fibonacci number, since defined computation recursively ( terms previous fibonacci numbers) need compute first 9 fibonacci numbers order compute 10th. when compute 7th fibonacci number the second line, result returns instantly, weve already computed !the best part is far the consumer is concerned, fibs array doesnt anything lazily statefully recursively anything that. s an array. yucky stuff is hidden away lazy-arr, the generator is one liner.neat, huh?view repo github lazy-arrposted... * boris cherny * 5 days ago * jsfunctional programmingclojurescalahaskell"
}