{
	"_id": "14505411",
	"site": "https://evoasm.github.io/evoasm/doc/file.ExpressionCompiler.html",
	"title": " Compiling simple math expressions to x86 using Genetic Programming",
	"author": "haematom",
	"date": "2017-06-16T07:56:21.203Z",
	"tags": [],
	"content": "index Â» file: expression compiler expression compiler following program takes mathematical expression a command line argument. then evaluates expression some specific points generate example cases. evoasm is used find sequence machine code instructions whose input output matches example set, is that calculates expression. time takes find such sequence machine code varies greatly, sometimes evoasm fails find at . it strongly depends the chosen meta-parameters (kernel size, deme size etc.). keep in mind you cannot exactly reproduce is shown below. the moment, expressions are restricted a single variable x, however, adding support multiple variables not too hard implement.given below are example runs results (introns been eliminated). code is shown the very bottom the page. command used was $ bundle exec ruby docs/examples/expr_comp.rb ---gem-libevoasm \"<expr>\" line input registers: <reg>:<index> gives information which registers been initialized which argument; x being 0th argument. remaining arguments are possible constants, appearing the expression.example 1 x/2.00x7f023ca0100f: vdivpd xmm2, xmm2, xmm3input registers: xmm2:0, xmm3:1output registers: xmm2average loss is 0.0generations: 0example 2 sqrt(x)0x7fd1928fc00f: vfmadd231ps xmm1, xmm0, xmm10x7fd1928fc014: vshufpd xmm3, xmm0, xmm1, 0x4e0x7fd1928fc019: vphaddsw ymm2, ymm3, ymm30x7fd1928fc01e: vsqrtpd xmm2, xmm0input registers: xmm0:0, xmm1:0, xmm3:0output registers: xmm2average loss is 0.0generations: 0example 3 sqrt(x**3)0x7fb54e1ca00f: sqrtsd xmm1, xmm00x7fb54e1ca013: movq xmm3, xmm10x7fb54e1ca017: vfnmadd213pd xmm1, xmm2, xmm30x7fb54e1ca01c: addsubpd xmm3, xmm1input registers: xmm0:0, xmm1:1, xmm2:0output registers: xmm3average loss is 0.0generations: 1620example 4 2*x0x7f400818100f: vpsadbw ymm2, ymm1, ymm30x7f4008181013: vmpsadbw xmm3, xmm1, xmm0, 20x7f4008181019: vcvtsi2sd xmm2, xmm3, eax0x7f400818101d: vpsrad ymm3, ymm3, xmm20x7f4008181021: addpd xmm2, xmm30x7f4008181025: addsd xmm1, xmm10x7f4008181029: cvttpd2dq xmm2, xmm1input registers: :0, xmm0:1, xmm1:0, xmm3:1output registers: xmm2average loss is 0.0generations: 42example 5 3*x0x7fcd9b73500f: vpsrad ymm1, ymm1, xmm10x7fcd9b735013: vmulsd xmm1, xmm1, xmm10x7fcd9b735017: vfmaddsub213pd ymm0, ymm3, ymm10x7fcd9b73501c: vcvttpd2dq xmm3, ymm00x7fcd9b735020: orpd xmm3, xmm3input registers: xmm0:0, xmm1:1, xmm3:1output registers: xmm3average loss is 0.0generations: 90example 6 (3.5*x) + 105.010x7f9ef260a00f: vfmsubadd231pd ymm2, ymm1, ymm0input registers: xmm0:0, xmm1:1, xmm2:2output registers: xmm2average loss is 0.0generations: 264coderequire 'evoasm'require 'evoasm/x64'require 'colorize'evoasm.log_level = :infoexpression = argv[0]module expressionscope extend mathendp expressionimms = expression.scan(/\\b\\d+(?:\\.\\d+)?\\b/).map(&:to_f)examples = (0..10).map |x| [[x.to_f, *imms], expressionscope.module_eval(expression)]end.to_hinstructions = evoasm::x64.instruction_names(:xmm)instructions += %( mov_r8_imm8 mov_r16_imm16 mov_r32_imm32 mov_rm8_imm8 mov_rm16_imm16 mov_rm32_imm32 mov_rm64_imm32)parameters = evoasm::population::parameters. do |p| p.instructions = instructions p.examples = examples p.deme_size = 256 p.deme_count = 6 p.kernel_size = 10 p.distance_metric = :absdiff p.parameters = %(reg0 reg1 reg2 reg3 imm0) regs = %(xmm0 xmm1 xmm2 xmm3 b c d) domains = { reg0: regs, reg1: regs, reg2: regs, reg3: regs } imm_domain = imms.flat_map |imm| [ [imm.to_f].pack('d').unpack('q'), [imm.to_f].pack('f').unpack('l'), imm ] end domains[:imm0] = imm_domain unless imm_domain.empty? p.domains = domainsendputs \"supported features:\"evoasm::x64.features.each |feature, supported| puts \"\\t#{feature.to_s.upcase}: #{supported ? 'yes' : ''}\"endputspopulation = evoasm::population. parameterskernel, loss = population.run loss: 0.0, max_generations: 100000 population.reportendputs kernel.disassemble format: trueputskernel = kernel.eliminate_intronsputs kernel.disassemble format: trueputs \"input registers: #{kernel.input_mapping.map { |reg, arg| \"#{reg.to_s.bold}:#{arg}\"}.join(', ')}\"puts \"output registers: #{kernel.output_registers.join(', ').bold}\"puts \"average loss is #{loss.to_s.bold}\"puts \"generations: #{population.generation}\"putsputs \"x\\texpected\\tactual\"examples.each |x, y| puts \"#{x}\\t#{y.round(3)}\\t\\t#{kernel.run(*x).round(3)}\"endgenerated wed jun 7 13:39:24 2017 yard0.9.5 (ruby-2.4.0)."
}