{
	"_id": "14313151",
	"site": "https://github.com/andreas-gone-wild/blog/blob/master/portable_ssl_imap_smtp.md",
	"title": " Solid IMAP and SMTP in Go Using Python",
	"author": "andreasgonewild",
	"date": "2017-06-13T13:08:55.937Z",
	"tags": {
		"categories": [
			"system", "development"
		],
		"languages": []
	},
	"content": "solid imap & smtp go using pythonposted may 3rd, 4:26 pmintromany the ideas 've been playing around lately are the distributed, secure & networked kind. since distributed asynchronous networks are tricky beasts, want leverage existing network such nature commonly known email. quest has led to of hardest find buggiest libraries have ever across. either imap & smtp are tricky hell get right there is kind mass-psychosis going , i never felt dipping appendages that tar pit enough tell. two solid implementations have found are the standard libraries java & python.this around was trying get idea and running go. usually excellent library support is of reasons went go begin , but it comes email might well been coding javascript. writing whole application python is , big python code-bases the structural integrity jello my experience; java goes too far other . no, it is.epiphany tearing of hair trying get something working within , i started looking calling external code instead; gradually dawned me writing tiny servers python, for smtp one imap; remote controlling via stdin / stdout should possible. python solution ended taking the same amount code the non-working version, glue included. it performs better the naive -connection-per-request strategy was i get semi-working go, room grow. as added bonus now in posession portable solution the email problem, will my life lot easier.codeincluded below are two tiny python servers the glue-code used drive . the communication protocol is kept simple possible using lines text where possible json objects where needed.imap.pyimport json email import message_from_string email.header import decode_header imaplib import imap4_ssl select import select sys import argv, stdin, stdouttag = '__snackis__'heartbeat = 3server, port, user, password = argv[1:]imap = imap4_ssl(server, int(port))imap.login(user, password)imap.create(tag)imap.select('inbox')while true: input_waiting, _, _ = select([stdin], [], [], heartbeat) not input_waiting: imap.noop() continue stdin.readline().strip() == \"quit\": break imap.check() _, data = imap.uid('search', none, '(header subject \"{0}\")'.format(tag)) uid data[0].split(): try: res, raw = imap.uid('fetch', uid, '(rfc822)') res != 'ok': continue msg = message_from_string(raw[0][1].decode('utf-8')) subj = decode_header(msg['subject'])[0][0] json.dump({ 'id': subj[len(tag)+1:], 'sentby': decode_header(msg[''])[0][0], 'body': msg.get_payload() }, stdout) print(\"\") imap.uid('copy', uid, tag)[0] == 'ok': imap.uid('store', uid , '+flags', '(\\deleted)') except exception e: json.dump({'error': e.message}, stdout) print(\"\") stdout.flush() print(\"\") stdout.flush() imap.expunge()imap.close()imap.logout()imap.package imapimport (\"bufio\"\"encoding/json\"\"fmt\"\"io\"\"os/exec\"\"strconv\")type proc struct {cmd *exec.cmd io.writer *bufio.reader}type msg struct {id, sentby, body stringerror string}func start(server string, port int, user, password string) (proc *proc, err error) {proc = (proc)proc.cmd = exec.command(\"python3\",\"imap.py\",server,strconv.itoa(port),user,password) proc., err = proc.cmd.stdinpipe(); err != nil {return nil, fmt.errorf(\"failed get imap stdin: %v\", err)}var io.reader out, err = proc.cmd.stdoutpipe(); err != nil {return nil, fmt.errorf(\"failed get imap stdout: %v\", err)} err = proc.cmd.start(); err != nil {return nil, err}proc. = bufio.newreader()return proc, nil}func (self *proc) fetch() (msgs []*msg, err error) { _, err = self..write([]byte(\"\")); err != nil {return nil, err} true {var data []byte data, err = self..readbytes(''); err != nil {return nil, fmt.errorf(\"failed read result: %v\", err)} len(data) == 1 {break}msg := (msg) err = json.unmarshal(data, msg); err != nil {return nil, fmt.errorf(\"failed unmarshal msg: %v\", err)}msgs = append(msgs, msg)}return msgs, nil}func (self *proc) stop() (err error) { _, err = self..write([]byte(\"quit\")); err != nil {return fmt.errorf(\"failed send quit command: %v\", err)} err = self.cmd.wait(); err != nil {return err}return nil}smtp.pyimport json email.mime.text import mimetext smtplib import smtp select import select sys import argv, stdin, stdouttag = '__snackis__'heartbeat = 3server, port, user, password = argv[1:]smtp = smtp(server, int(port))smtp.starttls()smtp.login(user, password)while true: input_waiting, _, _ = select([stdin], [], [], heartbeat) not input_waiting: smtp.noop() continue cmd = stdin.readline() cmd.strip() == 'quit': break cmd = json.loads(cmd) try: msg = mimetext(cmd['body']) msg[''] = cmd['sentby'] msg[''] = cmd['sentto'] msg['subject'] = '{0} {1}'.format(tag, cmd['id']) smtp.sendmail(cmd['sentby'], [cmd['sentto']], msg.as_string()) print(\"\") except exception e: print(e.message) stdout.flush()smtp.quit()smtp.package smtpimport (\"bufio\"\"encoding/json\"\"errors\"\"fmt\"\"io\"\"os/exec\"\"strconv\")type proc struct {cmd *exec.cmd io.writerjsonin *json.encoder *bufio.reader}type msg struct {id, sentby, sentto, body string}func start(server string, port int, user, password string) (proc *proc, err error) {proc = (proc)proc.cmd = exec.command(\"python3\",\"smtp.py\",server,strconv.itoa(port),user,password) proc., err = proc.cmd.stdinpipe(); err != nil {return nil, fmt.errorf(\"failed get imap stdin: %v\", err)}proc.jsonin = json.newencoder(proc.)var io.reader out, err = proc.cmd.stdoutpipe(); err != nil {return nil, fmt.errorf(\"failed get imap stdout: %v\", err)}proc. = bufio.newreader()if err = proc.cmd.start(); err != nil {return nil, err}return proc, nil}func (self *proc) send(msg *msg) (err error) { err = self.jsonin.encode(msg); err != nil {return fmt.errorf(\"failed encode json: %v\", err)}var res string res, err = self..readstring(''); err != nil {return fmt.errorf(\"failed read result: %v\", err)} res != \"\" {return errors.(res)}return nil}func (self *proc) stop() (err error) { _, err = self..write([]byte(\"quit\")); err != nil {return fmt.errorf(\"failed send quit command: %v\", err)} err = self.cmd.wait(); err != nil {return err}return nil} well,"
}