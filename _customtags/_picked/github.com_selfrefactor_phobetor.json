{
	"_id": "14492162",
	"site": "https://github.com/selfrefactor/phobetor",
	"title": " Phobetor â€“ browser automation library with Nightmare.js",
	"author": "self_refactor",
	"date": "2017-06-13T13:04:45.038Z",
	"tags": {
		"categories": [
			"opensource",
			"electron",
			"e2e",
			"browser-automation"
		],
		"languages": [
			"javascript",
			"shell"
		]
	},
	"content": "readme.md phobetorbrowser emulation library build nightmare.jsnightmare.js is great library, you cannot straightforward pass functions arguments the evaluation context.phobetor uses eval run those functions browser's context give back result.example reddit login// yarn add phobetorconst browser = require(\"phobetor\");(async () => { browser.init({show:true}) await browser.(\"https://www.reddit.com/\") await browser.wait({condition:1000}) await browser.type({ selector:\"input[name='user']\", payload:\"foo\" }) await browser.type({ selector:\"input[name='passwd']\", payload:\"bar\" }) const submitbuttonselector = \".submit button[type=submit]\" await browser.click({ selector: submitbuttonselector }) await browser.sleep(2000) await browser.close()})() example is part phobetor's showcase project reddit voter, logs reddit your credentials, redirect declared subreddit then vote randomly.namingphobetor is greek god nightmaresapi most important functions 'phobetor' are 'getelements' 'getsingleelement'. of other methods are build using those functions.getelementstypinggetelements({ constants?: , evaluate?: function, filter?: function<boolean>, map?: function, selector: string}): promiseselector(required)elements query selector compatible document.queryselectorallfilterboolean returning function. can it filter result document.queryselectorall(selector). filter fails return true at least element, will receive null result.mapfunction will map the returned elements filterevaluatefunction receives result map argument. evaluate returns is actual return value getelementsconstants can constants pass values browser contextexampleconst browser = require(\"phobetor\");browser.init({show:true})const constants = \"placeholder\"const result = await browser.getelements({ constants: {limit: 100}, selector:\".foo\", filter: element => element.innerhtml.length > constants.limit, map: element => element.queryselector(\"p\").textcontent, evaluate: elements => elements.join(\"\")})notice in order use constants our functions, need have in context, you declare evaluate- functions. convenience method has alias '$$' you use also that:const result = await browser.$$({ ...})getsingleelementtypinggetsingleelement({ constants?: , evaluate?: function, filter?: function, selector: string}): promiseselector*(required)element query selector compatible document.queryselectorfilterboolean returning function. can it filter result document.queryselector(selector) filter return false, will receive null result.evaluatefunction receives result document.queryselector(selector) argument. evaluate returns is actual return value getsingleelementconstants can constants pass values browser contextexampleconst constants = \"placeholder\"const result = await browser.getsingleelement({ constants: \"baz\", selector:\".foo\", filter: element => element.innerhtml.includes(constants), evaluate: element => element.textcontent}) you may expect, filter is evaluated, will replace constants \"baz\" \"placeholder\". convenience method has alias '$' you use also that:const result = await browser.$({ ...})getnightmareinstance(): objectreturn same nightmare.js instance the library uses itself.init(options: object)options are used create nightmare.js instancecheck requirements nightmare.js's page(url: string): promisesame nightmare.js.gotocheck nightmare.js's desription gotowaittypingwait({ condition: string|function|number, conditionarguments?: , timeout?: number}): promisecondition is passed nightmare.js's wait condition is function, is passed nightmare.js's wait conditionarguments argument.timeout is delay race condition. thus if condition fails, can proceed nothing happened. default value is 5000msiselementpresentiselementpresent({selector:string}):promise<boolean>sleepsleep(ms: number): promisesettimeout a promisedelaydelay(ms: number): promisesettimeout a promise"
}