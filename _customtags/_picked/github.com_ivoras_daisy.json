{
	"_id": "14512531",
	"site": "https://github.com/ivoras/daisy",
	"title": " Daisy: A private blockchain where blocks are SQLite databases, in Go",
	"author": "ivoras",
	"date": "2017-06-13T13:04:19.548Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"go"
		]
	},
	"content": "readme.md daisy - private blockchain where blocks are sqlite databases if... if is blockchain where certain nodes, possession one accepted private keys, add data (.e. blocks) a blockchain, whose blocks are (sqlite) databases, where those existing nodes accept ones their ranks signing candidate's keys a web--trust style? if public (government) documents were distributed this ...? what wikipedia was...?usage started, daisy initialise databases install default ( currently only ) blockchain. will connect a list peers maintains fetch blocks, any.querying blockchain the blocks the blockchain be queried using command such ./daisy query \"select count(*) wikinews_titles\" (note quotes!). will iterate all blocks, in those blocks where query is successful, output results stdout json objects separated newlines. course, is limited read- queries.adding data the blockchainsince is private blockchain, everyone has ability create blocks. 'm thinking this a more a framework creating blockchains. you to contribute the default blockchain (.e. store data, .e. add sqlite databases the blockchain), run ./daisy mykeys command, send the public key hash sign, an explanation / introductory letter saying why what you to with , and 'll sign key accept into blockchain one the signatories. you a private key whose public part is added the list signatories, running ./daisy signimportblock mydata.db import mydata.db file the blockchain. before 's imported, database is modified contain daisy metadata tables.intended uses possible cases 've thought for blockchains where everyone download verify data, only few parties publish:distributing academic articles: create new blockchain academic institutions ( arxiv such) allow to push blocks articles the blockchain.distributing municipal governmental records: each institution / agency be allowed publish blocks records documents the blockchain.distributing scientific data: certified research institutions publish data the blockchain.distributing sensor data, having gateways publishing daily aggregate data sensor networks.distributing sports / betting / lottery resultswikileaks, coursemaking gigantic world-wide database e.g. product information: manufacturs add information their products, keyed e.g. upc codescurrent statusbasic crypto, block db operations are implemented, network part is mostly done. simple form db queries is done. automated key management operations (.e. signing someone else's key) are pending ('re manual ).warning: is mostly alpha quality code.todoimplement nicer error handling replying messagesrefactor db..., action... blockchain... funcs struct methodsimplement \"url\" encoding block transfers: the data the json messages isn't block data, an url the block data.implement bloom filter tables sql queries, skip querying blocks don't the appropriate tables.implement stochastic guarded block importing: there apparently is new block the network: ask number peers they've seen before importing .design notesnote: this is fluid can changed development progresses.everyone download blockchain, special \"miners\" create ones, a sort- web--trust . those nodes are able create blocks are called \"signatories.\" are posssion an accepted private key.block payloads are sqlite database files. except special metadata tables, content is enforced.blockchain metadata is mostly separate the block payloads, some obvious exceptions such the block hash. metadata critical blockchain integrity ( the previous block's hash (merkle)is within block database)consensus rules accepting blocks: validity the sqlite files presence a special tables named _meta keys, validity the previous block hash the _meta table previous block hash is signed a key is of accepted private keys, .e. signatories, .e. is present the previous blocks' _keys table. _keys table contains signatory keys additions revocations. both operations must signed a number currently valid signatories, where number is given \"1 height < 149 else floor(log(height)*2)\"longest chain wins.flood-based p2p network: every node request list known connections the nodes.each message contains genesis (root) block hash, technically multiple chains safely communicate the same tcp portrandom thoughts blue-moon wishes to deal blockchain abuse? .e. of signatories turns to an adversary? ideas:limit amount data ( bytes) signatory add the signatorie's age (.e. longer key is approved, more data can add). offers absolutely protection against \"sleepers\" turn to adversaries enough has passed.require multiple signatures blocks, offers protection against clique adversaries, inconveniences common case where are indeed individul authoritative sources data.create cryptocurrency overlay the blockchain (possibly using external cryptocurrencies, tokens) where adding data becomes expensive - doesn't protect against well-funded adversary. blocks are createdblocks are sqlite database files. every party posession an accepted private key (.e. signatory) create blocks sign . blocks are accepted ( other criteria are satisfied) if are signed one the accepted keys. blocks contain operations add remove keys a (global) list accepted keys, they contain sufficient number signatures a list already accepted keys. the _keys table description the section block metadata. be accepted blocks, sqlite database files some soft hard restrictions: databases must be created the \"wal\" journal mode. should created the \"off\" journal mode. databases should created the smallest possible page size, .e. 512 bytes.block metadata _keys table table contains key operations block creators. keys be either accepted revoked. is invalid a _keys table contain both acceptance revocation records a single key. both acceptance revocation operations require quorum, where q different keys are already accepted sign hash the key question. number q is calculated : q = 1 h < 149 else floor(log(h)*2)where h is block height the block containing records. example, q is 3, add key k the list accepted keys, must exactly 3 records the _keys table pertaining k. each the records must contain valid signature a different, already accepted key. key k be used sign blocks immediately the block contain records has been accepted. table quorums required specific block heights is: 1 1 149 10 245 11 404 12 666 13 1097 14 1809 15 2981 16 4915 17 8104 18 13360 19 22027 20 36316 21 59875 22 98716 23 162755 24e.g. block 100000, 23 signatures are required accept new signature.basic cryptoecdsa p-256 is used public key crypto operations.strings refered daisy \"public keys\" are sha256 hashes public keys begin the string \"1:\" ( 1 is indicate key type, should need change the future). look \"1:9569f0894e3d2b435a4c49c6a97501f4191b9729ff53be5acee2c7bd4be0e439\"."
}