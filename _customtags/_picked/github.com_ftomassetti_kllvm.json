{
	"_id": "14468267",
	"site": "https://github.com/ftomassetti/kllvm",
	"title": " KLLVM, a small Kotlin library to work with LLVM",
	"author": "ftomassetti",
	"date": "2017-06-13T13:05:02.923Z",
	"tags": {
		"categories": [
			"library"
		],
		"languages": [
			"kotlin",
			"shell"
		]
	},
	"content": "readme.md kllvmkllvm stands kotlin-llvm. is intended a library work llvm kotlin.currently supports generation ir code. rationale is there are currently decent options use llvm the jvm: while is autogenerated wrapper thellvm c++ api java is unusable. this reason best option seems generate textual representation ir code later compile to object file ( interpret directly) using llvm utilities. to it the following example show to generate simple application takes parameters, sum and print result. @test fun generatesum() { val exit_code_ok = 0 val exit_code_wrong_params = 1 val n_params_expected = 2 val string_type = pointer(i8type) val module = modulebuilder() val mainfunction = module.createmainfunction() val atoideclaration = functiondeclaration(\"atoi\", i32type, listof(), varargs = true) module.adddeclaration(atoideclaration) module.adddeclaration(functiondeclaration(\"printf\", i32type, listof(string_type), varargs = true)) val okparamsblock = mainfunction.createblock(\"okparams\") val koparamsblock = mainfunction.createblock(\"koparams\") val comparisonresult = mainfunction.tempvalue(comparison(comparisontype.equal, mainfunction.paramreference(0), intconst(n_params_expected + 1, i32type))) mainfunction.addinstruction(ifinstruction(comparisonresult.reference(), okparamsblock, koparamsblock)) // ok block : convert int, sum, print val aasstringptr = okparamsblock.tempvalue(getelementptr(string_type, mainfunction.paramreference(1), intconst(1, i64type))) val aasstring = okparamsblock.load(aasstringptr.reference()) val aasint = okparamsblock.tempvalue(callwithbitcast(atoideclaration, aasstring)) val basstringptr = okparamsblock.tempvalue(getelementptr(string_type, mainfunction.paramreference(1), intconst(2, i64type))) val basstring = okparamsblock.load(basstringptr.reference()) val basint = okparamsblock.tempvalue(callwithbitcast(atoideclaration, basstring)) val sum = okparamsblock.tempvalue(intaddition(aasint.reference(), basint.reference())) okparamsblock.addinstruction(printf(mainfunction.stringconstforcontent(\"result: %d\").reference(), sum.reference())) okparamsblock.addinstruction(returnint(exit_code_ok)) // ko block : error message exit koparamsblock.addinstruction(printf(mainfunction.stringconstforcontent(\"please specify arguments\").reference())) koparamsblock.addinstruction(returnint(exit_code_wrong_params)) println(module.ircode()) assertequals(\"\"\"@stringconst0 = private unnamed_addr constant [12 x i8] c\"result: %d\\0a\\00\"@stringconst1 = private unnamed_addr constant [29 x i8] c\"please specify arguments\\00\"declare i32 @atoi(...)declare i32 @printf(i8*, ...)define i32 @main(i32, i8**) { ; unnamed block %tmpvalue0 = icmp eq i32 %0, 3 br i1 %tmpvalue0, label %okparams, label %koparams okparams: %tmpvalue1 = getelementptr inbounds i8*, i8** %1, i64 1 %tmpvalue2 = load i8*, i8** %tmpvalue1 %tmpvalue3 = call i32 (i8*, ...) bitcast (i32 (...)* @atoi i32 (i8*, ...)*)(i8* %tmpvalue2) %tmpvalue4 = getelementptr inbounds i8*, i8** %1, i64 2 %tmpvalue5 = load i8*, i8** %tmpvalue4 %tmpvalue6 = call i32 (i8*, ...) bitcast (i32 (...)* @atoi i32 (i8*, ...)*)(i8* %tmpvalue5) %tmpvalue7 = add i32 %tmpvalue3, %tmpvalue6 call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @stringconst0, i32 0, i32 0), i32 %tmpvalue7) ret i32 0 koparams: call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @stringconst1, i32 0, i32 0)) ret i32 1}\"\"\", module.ircode().trim()) } using kllvm is possible programmatically build program the obtain ir code. ir code then interpreted using lli command llvm. can be compiled an executable running:llc -filetype=obj example.llclang example.o -o examplestatus library is currently used compile ir domain specific languages. code is presented the book to create pragmatic, lightweight languages.future plan add features following requests the community. possible option be create wrapperaround javacpp-presets llvm"
}