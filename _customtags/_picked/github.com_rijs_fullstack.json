{
	"_id": "14345569",
	"site": "https://github.com/rijs/fullstack",
	"title": " Ripple Fullstack Modular web framework",
	"author": "pemrouz",
	"date": "2017-06-13T13:08:16.489Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md ripple fullstack the server:index.jsconst ripple = require('rijs')({ dir: __dirname }) the client:pages/index.html<script src=\"/ripple.js\"></script>run :$ node index.js starts a server a random port statically serves /pages directory. can specify port always , or pass existing http server (e.g. express).clients then be streamed fine-grained resources are using (.e. everything is lazy loaded, bundling, over-fetching).ripple keeps clients/servers sync replicating immutable log actions the background, subsequently view - other modules - are reactively updated the local store is updated.'s ! no boilerplate necessary, build pipeline, special transpilation, magical cli. basic api is:ripple(name) // getterripple(name, body) // setterripple.('change', (name, change) => { .. }) componentslet's add (web) component the page:index.html<script src=\"/ripple.js\"></script>+ <-app></-app>let's define component:resources/-app.js:export default () => ()ripple is agnostic how write components, should be idempotent: single render function. is fine:resources/-app.js:export default (node, data) => node.innerhtml = 'hello world!' using dom-diff helper:resources/-app.js:export default (node, data) => jsx(node)`<h1>hello world</h1>` using once/d3 joins:resources/-app.js:export default (node, data) => { once(node) ('h1', 1) .text('hello world')}) more info writing idempotent components, this spec. state/data first parameter the component is node update. second parameter contains the state data component needs render:export default function component(node, data){ ... } can inject data resources adding name the resources the data attribute:<-shop data=\"stock\">export default function shop({ stock }){ ... }declaring data needed a component is used reactively rerender when data changes.alternatively, can ripple.pull directly retrieve resource, has similar semantics dynamic import() (.e. resolves local cache returns single promise):const dependency = await pull('dependency') other option is explicitly pass down data the component the parent:once(node) ('-shop', { stock }) helper function set state redraw, redrawing parent redraw 's children. you to it yourself:element.state = { stock }element.draw() defaults can set defaults using es6 syntax:export default function shop({ stock = [] }){ ... } you need persist defaults the component's state object, can a small helper function:export default function shop(state){ const stock = defaults(state, 'stock', [])} updateslocal statewhenever need update local state, change state invoke redraw ( a game loop):export default function abacus(node, state){ const o = once(node) , { counter = 0 } = state o('span', 1) .text(counter) o('button', 1) .text('increment') .('click.increment' d => { state.counter++ o.draw() })}global statewhenever need update global state, can simply compute new value register again will trigger update:ripple('stock', { apples: 10, oranges: 20, pomegranates: 30}) if just to change part the resource, a functional operator apply finer-grained diff trigger update:update('pomegranates', 20)(ripple('stock'))// same : set({ type: 'update', key: 'pomegranate', value: 20 })(ripple('stock'))using logs atomic diffs combines benefits immutability a saner to synchronise state across distributed environment.components are raf batched default. can access list all relevant changes since last render your component via node.changes make more performant necessary. eventsdispatch event the root element communicate changes parents (node.dispatchevent). routingrouting is handled your top-level component: simply parse url determine children render invoke redraw your application the route has changed:export function app(node, data){ const o = once(node) , { pathname } = location o('page-dashboard', pathname == '/dashboard') o('page-login', pathname == '/login') once(window) .('popstate.nav', d => o.draw())} solution is tied any library, you may need at .for advanced uses cases, checkout decouter. styling can author stylesheets assuming are completely isolated, using web component syntax (:host etc). will either inserted the shadow root the element, scoped added the head there is shadow. default, css resource component-name.css be automatically applied the component component-name. you apply multiple stylesheets a component too: extend css attribute. folder convention files your /resources folder be automatically registered (except tests etc). can organise as like, i recommend using convention: folder each component ( co-locate js, css tests), a data folder the resources make your domain model.resources data stock.js order.js ... -app -app.js -app.css test.js another-component another-component.js another-component.css test.js ...hot reloading works of box. changes these files be instantly reflected everywhere. loading resources can get/set resources yourselves imperatively:ripple(name) // getterripple(name, body) // setter for example import resources other packages:ripple .resource(require('external-module-1')) .resource(require('external-module-2')) .resource(require('external-module-3')) offlineresources are currently cached localstorage. means before network interaction, application renders last-known--state a superfast startup. as resources are streamed , the relevant parts the application are updated.note: caching resources be improved using serviceworkers under hood instead soon (#27) render middleware default draw function invokes function an element. can extend without framework hooks using explicit decorator pattern:// componentexport default function component(node, data){ middleware(node, data)}// around componentexport default middleware(function component(node, data){ })// all componentsripple.draw = middleware(ripple.draw) few useful middleware included this build are:needs middleware reads needs header applies attributes onto element. component does render until dependencies are available. is useful a component needs define own dependencies. can supply function dynamically calculate required resources.export default { name: '-component', body: function(){}, headers: { needs: '[css=..][data=..]' }}helpers middleware makes specified helper functions available the resource (hidden properties). is useful co-locate logic each resource one place.export default { name: 'stock', body: {}, headers: { helpers: { addnewstock, removestock }}} shadow supported the browser, shadow root be created each component. component render the shadow dom rather the light dom.perf (optional) one is included default, you use to log the each component takes render. debugging tips:check ripple.resources a snapshot your application. resources are the tuple format { name, body, headers }.check $0.state an element see state object was last rendered or manipulate . syncripple uses declarative transformation functions define flow data between server-client. changes flow through functions may return different representation. concept is analogous , but more generic , \"request-response\" http. request-response, have make request get response. you decouple , consider you receive response without request, make request multiple responses, make request does have response. are proxy functions ( and ) which can define the headers section:ripple('tweets', [], { , to }) ({ key, value, type, socket }) outgoing changes be passed through first. function is used send different representation a client, at .returning false not send resource all, useful privatising resources: = req => falsereturning true just continue streaming change. you return anything else, will stream representation instead. example, following collapse just send total number tweets. whenever is change the tweets resource, push still triggered broadcast all clients they are still always to date, instead transferring array all tweets, will get total count representation :to = req => (req.value = req.value.length, req) can vary representations based authentication. each socket has sessionid you use lookup whether user has logged or , and send different representation so: = req => users[req.socket.sessionid] ? req : filter(req) ({ key, value, type, socket }, res) incoming changes be passed through first. function is used process change before ripple commits in-memory triggers change notification.typically, will to check type (method/verb) then delegate the appropiate function. example, may different actions want take a user resource:const = (req, res) => req.type == 'register' ? register(req, res): req.type == 'forgot' ? forgot(req, res): req.type == 'logout' ? logout(req, res): req.type == 'reset' ? reset(req, res): req.type == 'login' ? login(req, res) : res(405, err('method allowed', req.type))returning false ignore change: = req => falseignore type changes, except adding items: = req => req.type != 'add' could choose ignore whatever change user made, take another action instead (ripple populates ip property all sockets). manually updating another resource instead returning true also trigger wave updates any interested clients/services:(..) => (push(socket.ip)(audit), false)` a user successfully logins, could force refresh all resources that user since may have access more resources:(..) => login(username, password).(d => ripple.send(socket)())` declarative transformation functions a very high power--weight ratio the above examples are a few illustrative examples. can the res function reply directly a request. can reply any arbitrary arguments. conventionally, ripple set first parameter the (http) status code the message the second. happens example a resource is found (404), type has been handled (405), your custom handler threw exception (500). request-response imperative api sending or requests, all some clients is:const { send } = ripplesend(sockets)(req) // server .(replies => ..)send(req) // client .(replies => ..)sockets: be socket, array sockets, sessionid string identifying sockets, nothing would imply connected sockets. the client, can send one socket ( server), this is pre-bound (.e. send(req)).req: be request object wish send, name a resource send, array either previous , or nothing would imply sending resources. req object have shape, typically would like:send({ name, type, value }) which can the shortcut:send(name, type, value) function returns promise all replies.pro-tip: sockets == ripple, can send requests the same node reuse logic the handler that resource use is a redux manner. function is aliased ripple.req = ripple.send(ripple).const { req } = ripplereq({ name: 'store', type: 'increment' })req('store', 'increment') .(..) .catch(..) 7 error handling request handler simply throw error:// serverfunction (req, res) { throw error('wtf!!')} error be logged then returned the client where can catch .// clientsend(req) .() .catch() default response status code is 500 the message is error message. can customise status code returned also changing status property the error. can respond directly instead throwing:res(500, 'something went wrong!') ripple minimal you don't backend your frontend, checkout rijs/minimal is client-side build ripple. can adjust own framework adding/removing modules. docs rijs/docs more guides, index modules, api reference, etc"
}