{
	"_id": "14098232",
	"site": "https://github.com/ngryman/tree-crawl",
	"title": " A Node.js agnostic tree traversal library",
	"author": "ngryman",
	"date": "2017-06-13T13:35:27.813Z",
	"tags": {
		"categories": [
			"opensource",
			"tree",
			"traversal",
			"visitor",
			"dfs",
			"bfs"
		],
		"languages": [
			"javascript"
		]
	},
	"content": "readme.md tree-crawl agnostic tree traversal library.agnostic: supports kind tree. provide way access node's children, 's .fast: crafted be optimizer-friendly. performance more details.mutation friendly: does when mutate tree.multiple orders: supports dfs pre post order bfs traversals.quickstartinstallation can install tree-crawl yarn:$ yarn add tree-crawlalternatively using npm:$ npm install --save tree-crawlusageimport crawl 'tree-crawl'// traverse tree pre-ordercrawl(tree, console.log)crawl(tree, console.log, { order: 'pre' })// traverse tree post-ordercrawl(tree, console.log, { order: 'post' })// traverse tree using `childnodes` the children keycrawl(tree, console.log, { getchildren: node => node.childnodes })// skip node its childrencrawl(tree, (node, context) => { ('foo' === node.type) { context.skip() }})// stop walkcrawl(tree, (node, context) => { ('foo' === node.type) { context.break() }})// remove nodecrawl(tree, (node, context) => { ('foo' === node.type) { context.parent.children.splice(context.index, 1) context.remove() }})// replace nodecrawl(tree, (node, context) => { ('foo' === node.type) { const node = { type: ' node', children: [ { type: ' leaf' } ] } context.parent.children[context.index] = node context.replace(node) }})apiiteratee: traversal context.called each node the tree.type: functionparametersnode object node being visited.context context traversal contextoptionswalk options.type: objectparametersnodepropertiesgetchildren function? return node's children.order (\"pre\" | \"post\" | \"bfs\")? order the walk either dfs pre post order, bfs.examplestraverse dom tree.crawl(document.body, dosomestuff, { getchildren: node => node.childnodes })bfs traversalcrawl(root, dosomestuff, { order: 'bfs' })crawlwalk tree recursively. default getchildren return children property a node.parametersroot object root node the tree be walked.iteratee iteratee function invoked each node.options options? options customizing walk.context traversal context.four operations are available. note depending the traversal order, operations no effects.parametersflags flagscursor cursorskipskip current node, children won't visited.examplescrawl(root, (node, context) => { ('foo' === node.type) { context.skip() }})breakstop traversal .examplescrawl(root, (node, context) => { ('foo' === node.type) { context.break() }})removenotifies the current node has been removed, children won't visited. tree-crawl has idea the intrinsic structure your tree, have remove node yourself. context#remove notifies traversal code the structure the tree has changed.examplescrawl(root, (node, context) => { ('foo' === node.type) { context.parent.children.splice(context.index, 1) context.remove() }})replacenotifies the current node has been replaced, new node's children be visitedinstead. tree-crawl has idea the intrinsic structure your tree, have replace node yourself. context#replace notifies traversal code the structure the tree has changed.parametersnode object replacement node.examplescrawl(root, (node, context) => { ('foo' === node.type) { const node = { type: ' node', children: [ { type: ' leaf' } ] } context.parent.children[context.index] = node context.replace(node) }})parent the parent the current node.returns object parent node.depth the depth the current node. depth is number ancestors current nodehas.returns number depth.level the level current node. level is number ancestors+1 current node has.returns number level.index the index the current node.returns number node's index.performancetree-crawl is built be super fast traverse potentially huge trees. 's possible it implements own stack queue traversal algorithms makes sure code is optimizable the vm. you need real performance please consider reading checklist .your main objective is keep traversal code optimized avoid de-optimizations bailouts. do , your nodes should the same hidden class your code stay monomorphic.relatedarbre agnostic tree library.tree-mutate agnostic tree mutation library.tree-morph agnostic tree morphing library.licensemit Â© nicolas gryman"
}