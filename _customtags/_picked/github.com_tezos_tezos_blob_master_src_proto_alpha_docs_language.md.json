{
	"_id": "14440596",
	"site": "https://github.com/tezos/tezos/blob/master/src/proto/alpha/docs/language.md",
	"title": "Michelson: The Language of Smart Contracts in Tezos",
	"author": "bshanks",
	"date": "2017-06-13T13:55:20.517Z",
	"tags": {
		"categories": [
			"opensource"
		],
		"languages": []
	},
	"content": "michelson: language smart contracts tezos language is stack based, high level data types primitives strict static type checking. design cherry picks traits several language families. vigilant readers notice directreferences forth, scheme, ml cat. michelson program is series instructions are run sequence: each instruction receives input stack resulting the previous instruction, rewrites for next . the stackcontains both immediate values heap allocated structures. values are immutable garbage collected. michelson program receives input single element stackcontaining input value the contents a storage space. mustreturn single element stack containing output value the contents the storage space. alternatively, michelson program fail, explicitly using specific opcode, because something wentwrong could be caught the type system (e.g. division zero, gas exhaustion). types the input, output storage are fixed monomorphic, the program is typechecked before being introduced thesystem. smart contract execution fail an instructionhas been executed a stack unexpected length contents. specification gives complete instruction set, type system semantics the language. is meant a precise reference manual, an easy introduction. though, examples are provided the end the document can read or the same as specification.table contents - semanticsii - type systemiii - core data typesiv - core instructionsv - operationsvi - domain specific data typesvii - domain specific operationsviii - concrete syntaxix - examplesx - full grammarxi - reference implementation - semantics specification gives detailed formal semantics the michelsonlanguage. explains a symbolic the computation performed the michelson interpreter a given program initial stack produce corresponding resulting stack. michelson interpreteris pure function: only builds result stack the elements an initial , without affecting environment. semantics is naturally given what is called big step form: symbolicdefinition a recursive reference interpreter. definition takes form a list rules cover the possible inputs theinterpreter (program stack), describe computation thecorresponding resulting stacks.rules form selection rules the main following form.> (syntax pattern) / (initial stack pattern) => (result stack pattern) iff (conditions) where (recursions) left hand side the => sign is used selecting rule. given program an initial stack, (and one) rule be selected using following process. , the toplevelstructure the program must match syntax pattern. is quitesimple since is a few non trivial patterns deal instruction sequences, the rest is made trivial pattern match specific instruction. , the initial stack must match initial stack pattern. finally, rules add extra conditions the values the stack follow iff keyword. sometimes,several rules may apply a given context. this case, one appears in specification is be selected. no ruleapplies, result is equivalent the for explicit failinstruction. case does happen well-typed programs, explained the next section. right hand side describes result the interpreter therule applies. consists a stack pattern, whose part are eitherconstants, elements the context (program initial stack) have been named the left hand side the => sign.recursive rules (big step form)sometimes, result interpreting program is derived theresult interpreting another (as conditionals functioncalls). these cases, rule contains clause the followingform.where (intermediate program) / (intermediate stack) => (partial result) means this rules applies case interpreting intermediate state the left gives pattern the right. left hand sign the => sign is constructed elements the initial state other partial results, the right hand sideidentify parts can used build result stack the rule. the partial result pattern does actually match result the interpretation, the result the whole rule is equivalent the for explicit fail instruction. again, case does happen well-typed programs, explained the next section.format patternscode patterns are one the following syntactical forms.instr ( uppercase identifier) is simple instruction(e.g. drop);instr (arg) ... is compound instruction,whose arguments be code, data type patterns(e.g. push uint8 3) ;{ (instr) ; ... } is possibly empty sequence instructions,(e.g. { swap ; drop } { drop }),nested sequences drop braces ;name is pattern matches program names part the matched program can used build result ;_ is pattern matches instruction.stack patterns are one the following syntactical forms.[fail] is special failed state ;[] is empty stack ;(top) : (rest) is stack whose top element is matched thedata pattern (top) the left, whose remaining elements arematched the stack pattern (rest) the right(e.g. x : y : rest) ;name is pattern matches stack names in order use to build result ;_ is pattern matches stack.data patterns are one the following syntactical forms.integer literals,(e.g. 3) ;string literals,(e.g. \"contents\") ;tag (capitalized) is symbolic constant,(e.g. unit, true, false) ;(tag (arg) ...) tagged constructed data,(e.g. (pair 3 4)) ; code pattern first class code values ;name name value order use to build result ;_ match value. domain instruction names, symbolic constants dataconstructors is fixed this specification. michelson does let programmer introduce own types. aware the syntax used the specification may differ bit the concrete syntax, is presented section viii. particular, instructions are annotated types are present the concrete language they are synthesized thetypechecker.shortcutssometimes, is easier think ( shorter write) terms program rewriting in terms big step semantics. it is case, when both are equivalents, write rules the form:p / s => s''where p' / s' => s''using following shortcut:p / s => p' / s' concrete language has syntax sugar group commonsequences operations one. is described thisspecification using simple regular expression style recursiveinstruction rewriting.ii - introduction the type system notations specification describes type system michelson. makethings clear, particular readers are accustomed reading formal programming language specifications, does give typechecking inference algorithm. only gives intentionaldefinition what consider be -typed programs. eachsyntactical form, describes stacks are considered-typed inputs, the resulting outputs. type system is sound, meaning if program be given type, if run a -typed input stack, interpreter never apply interpretation rule a stack unexpected length contents. , it never reach state where cannot select appropriate rule continue execution. -typed programs notblock, do go wrong.type notations specification introduces notations the types values, terms stacks. appart a subset value types appear theform type annotations some places througout language, isimportant understand this type language exists thespecification. stack type be written:[] the empty stack ;(top) : (rest) the stack whose value has type (top) queue has stack type (rest).instructions, programs primitives the language are typed, types are written:(type stack before) -> (type stack )the types values the stack are written:identifier a primitive data-type(e.g. bool),identifier (arg) a parametric data-type one parameter type (arg)(e.g. list uint8),identifier (arg) ... a parametric data-type several parameters(e.g. map string uint8),[ (type stack before) -> (type stack ) ] for code quotation,(e.g. [ uint8 : uint8 : [] -> uint8 : [] ]),lambda (arg) (ret) is shortcut [ (arg) : [] -> (ret) : [] ].meta type variables typing rules introduce meta type variables. be clear, hasnothing do polymorphism, michelson does have. variables live the specification level, are used express consistency between parts the program. instance, typing rule the construct introduces metavariables express both branches must the same type.here are notations meta type variables:' for type variable,' for stack type variable,_ an anonymous type stack type variable.typing rules system is syntax directed, means here it defines single typing rule each syntax construct. typing rule restricts type input stacks are authorized this syntaxconstruct, links output type the input type, links both them the subexpressions needed, using meta type variables.typing rules are the form:(syntax pattern):: (type stack before) -> (type stack ) [rule-name] iff (premisses)where premisses are typing requirements subprograms values the stack, both the form (x) :: (type), meaning value (x)must type (type). program is shown -typed one find instance a rule applies the toplevel program expression, all meta typevariables replaced non variable type expressions, of alltype requirements the premisses be proven -typed thesame manner. the reader unfamiliar formal type systems, is called building typing derivation.here is example typing derivation a small program computesx+5/10 a given input x, obtained instanciating typingrules instructions push, add for sequence, found the next sections. instanciating, replace iff by.{ push uint8 5 ; add ; push uint8 10 ; swap ; div }:: [ uint8 : [] -> uint8 : [] ] { push uint8 5 ; add } :: [ uint8 : [] -> uint8 : [] ] push uint8 5 :: [ uint8 : [] -> uint8 : uint8 : [] ] 5 :: uint8 add :: [ uint8 : uint8 : [] -> uint8 : [] ] { push uint8 10 ; swap ; div } :: [ uint8 : [] -> uint8 : [] ] push uint8 10 :: [ uint8 : [] -> uint8 : uint8 : [] ] 10 :: uint8 { swap ; div } :: [ uint8 : uint8 : [] -> uint8 : [] ] swap :: [ uint8 : uint8 : [] -> uint8 : uint8 : [] ] div :: [ uint8 : uint8 : [] -> uint8 : [] ]producing such typing derivation be done a number manners,such unification abstract interpretation. the implementation michelson, is done performing recursive symbolicevaluation the program an abstract stack representing inputtype provided the programmer, checking the resultingsymbolic stack is consistent the expected result, provided the programmer.side note with type systems, is incomplete. are programs cannot given type this type system, yet would gowrong executed. is necessary compromise make typesystem usable. , it is important remember theimplementation michelson does accept many programs thetype system describes well-typed. is theimplementation uses simple single pass typechecking algorithm, does handle form polymorphism.iii - core data types notationsstring, u?int{8|16|32|64}: core primitive constant types.bool: type booleans whose values are true falseunit: type whose value is unit, use a placeholder some result parameter is non necessary. instance, the goal a contract is update storage.list (t): single, immutable, homogeneous linked list, whose elements are type (t), that note nil the empty list (cons (head) (tail)).pair (l) (r): pair values and b types (l) (r), wewrite (pair b).option (t):optional value type (t) we note none (some v). (l) (r): union two types: value holding either value of type(l) a value b type (r), we write (left ) or(right b).set (t):immutable sets values type (t) we note(set (item) ...).map (k) (t):immutable maps keys type (k) values type (t) we note (map (item (key) (value)) ...).iv - core instructionscontrol structuresfail:explicitly abort current program.:: _ -> _ special instruction is callable any context, since does use input stack ( rule below), makes output useless since subsequent instruction simplyignore usual semantics propagate failure to main result (second rule below). type is thus completelygeneric.fail / _ => [fail]_ / [fail] => [fail]{ ; c }:sequence.:: ' -> 'ciff :: [ 'a -> 'b ]c :: [ 'b -> 'c ] ; c / sa => scwhere / sa => sb c / sb => sc bt bf:conditional branching.:: bool : ' -> 'biff bt :: [ ' -> 'b ]bf :: [ ' -> 'b ] bt bf / true : s => bt / s bt bf / false : s => bf / sloop body: generic loop.:: bool : ' -> 'aiff body :: [ ' -> bool : ' ]loop body / true : s => body ; loop body / sloop body / false : s => sdip code:runs code protecting top the stack.:: 'b : ' -> 'b : 'ciff code :: [ ' -> 'c ]dip code / x : s => x : s'where code / s => s'dii+p code: syntactic sugar working deeper the stack.dii(est=*)p code / s => dip (di(est)p code) / sexec:execute function the stack.:: ' : lambda ' 'b : 'c -> 'b : 'cexec / : f : s => r : swhere f / : [] => r : []stack operationsdrop:drop top element the stack.:: _ : ' -> 'adrop / _ : s => sdup:duplicate top the stack.:: ' : 'a -> ' : 'a : 'dup / x : s => x : x : sduu+p: syntactic sugar duplicating nth element the stack.duu(est=u*)p / s => dip (du(est)p) ; swap / sswap:exchange top elements the stack.:: ' : 'b : ' -> 'b : ' : 'aswap / x : y : s => y : x : spush ' x:push constant value a given type onto stack.:: ' -> 'a : 'iff x :: 'push ' x / s => x : sunit:push unit value onto stack.:: ' -> unit : 'unit / s => unit : sgeneric comparisoncomparison works a class types we call comparable. compare operation is defined an ad hoc for each comparabletype, the result compare is always int64, can turn checked a generic manner using followingcombinators. result compare is 0 the compared values areequal, negative the is less the second, positiveotherwise.eq:checks the top the stack equals zero.:: int64 : 's -> bool : 'seq ; c / int64 (0) : s => c / true : seq ; c / _ : s => c / false : sneq:checks the top the stack does equal zero.:: int64 : 's -> bool : 'sneq ; c / int64 (0) : s => c / false : sneq ; c / _ : s => c / true : slt:checks the top the stack is less zero.:: int64 : 's -> bool : 'slt ; c / int64 (v) : s => c / true : s iff v < 0lt ; c / _ : s => c / false : sgt:checks the top the stack is greater zero.:: int64 : 's -> bool : 'sgt ; c / int64 (v) : s => c / true : s iff v > 0gt ; c / _ : s => c / false : sle:checks the top the stack is less of equal zero.:: int64 : 's -> bool : 'sle ; c / int64 (v) : s => c / true : s iff v <= 0le ; c / _ : s => c / false : sge:checks the top the stack is greater of equal zero.:: int64 : 's -> bool : 'sge ; c / int64 (v) : s => c / true : s iff v >= 0ge ; c / _ : s => c / false : ssyntactic sugar exists merging compare comparisoncombinators, also branching.cmp{eq|neq|lt|gt|le|ge}cmp(\\op) ; c / s => compare ; (\\op) ; c / s{eq|neq|lt|gt|le|ge} bt bf(\\op) ; c / s => (\\op) ; bt bf ; c / sifcmp{eq|neq|lt|gt|le|ge} bt bfifcmp(\\op) ; c / s => compare ; (\\op) ; bt bf ; c / sv - operationsoperations booleans:: bool : bool : 's -> bool : 's ; c / x : y : s => c / (x | y) : s:: bool : bool : 's -> bool : 's ; c / x : y : s => c / (x & y) : sxor:: bool : bool : 's -> bool : 'sxor ; c / x : y : s => c / (x ^ y) : s:: bool : 's -> bool : 's ; c / x : s => c / ~x : soperations integersintegers be size 1, 2, 4 8 bytes, signed unsigned.integer operations are homogeneous, that performing computationsbetween values different int types must done via explicit casts. specifying arithmetics, consider integers are stored 64 bits ( largest integer size) that can express operations, particular casts, using usual bitwise masks. thiscontext, type indicator functions are defined follows (can read both a constraint the bitpatttern as conversion operation). uint64 (x) = int64 (x) = x uint32 (x) = x & 0x00000000ffffffff int32 (x) = x & 0x00000000ffffffff | (x & 0x80000000 ? 0xffffffff00000000 : 0) uint16 (x) = x & 0x000000000000ffff int16 (x) = x & 0x000000000000ffff | (x & 0x8000 ? 0xffffffffffff0000 : 0) uint8 (x) = x & 0x00000000000000ff int8 (x) = x & 0x00000000000000ff | (x & 0x80 ? 0xffffffffffffff00 : 0) also the function bits (t) retrieve meaningful number bits a given integer type (e.g. bits (int8) = 8).neg:: t : 's -> t : 's t int{8|16|32|64}neg ; c / t (x) : s => c / t (-x) : s cycling semantics overflows (min (t) = -min (t)).abs:: t : 's -> t : 's t int{8|16|32|64}abs ; c / t (x) : s => c / t (abs (x)) : s cycling semantics overflows (abs (min (t)) = min (t)).add:: t : t : 's -> t : 's t u?int{8|16|32|64}add ; c / t (x) : t (y) : s => c / t (x + y) : s cycling semantics overflows.sub:: t : t : 's -> t : 's t u?int{8|16|32|64}sub ; c / t (x) : t (y) : s => c / t (x - y) : s cycling semantics overflows.mul:: t : t : 's -> t : 's t u?int{8|16|32|64}mul ; c / t (x) : t (y) : s => c / t (x * y) : sunckeched overflows.div:: t : t : 's -> t : 's t u?int{8|16|32|64}div ; c / t (x) : t (0) : s => c / [fail]div ; c / t (x) : t (y) : s => c / t (x / y) : smod:: t : t : 's -> t : 's t u?int{8|16|32|64}mod ; c / t (x) : t (0) : s => c / [fail]mod ; c / t (x) : t (y) : s => c / t (x % y) : scast t_to where t_to u?int{8|16|32|64}:: t_from : 's -> t_to : 's t_from u?int{8|16|32|64}cast t_to ; c / t_from (x) : s => c / t_to (x) : salternative operators are defined check overflows.checked_neg:: t : 's -> t : 's t int{8|16|32|64}checked_neg ; c / t (x) : s => [fail] overflowchecked_neg ; c / t (x) : s => c / t (-x) : schecked_abs:: t : 's -> t : 's t int{8|16|32|64}checked_abs ; c / t (x) : s => [fail] overflowchecked_abs ; c / t (x) : s => c / t (abs (x)) : schecked_add:: t : t : 's -> t : 's t u?int{8|16|32|64}checked_add ; c / t (x) : t (y) : s => [fail] overflowchecked_add ; c / t (x) : t (y) : s => c / t (x + y) : schecked_sub:: t : t : 's -> t : 's t u?int{8|16|32|64}checked_sub ; c / t (x) : t (y) : s => [fail] overflowchecked_sub ; c / t (x) : t (y) : s => c / t (x - y) : schecked_mul:: t : t : 's -> t : 's t u?int{8|16|32|64}checked_mul ; c / t (x) : t (y) : s => [fail] overflowchecked_mul ; c / t (x) : t (y) : s => c / t (x * y) : schecked_cast t_to where t_to u?int{8|16|32|64}:: t_from : 's -> t_to : 's t_from u?int{8|16|32|64}checked_cast t_to ; c / t_from (x) : s => c / t_to (x) : siff t_from (x) = t_to (x)checked_cast t_to ; c / t_from (x) : s => [fail]bitwise logical operators are available unsigned integers.:: t : t : 's -> t : 's t uint{8|16|32|64} ; c / t (x) : t (y) : s => c / t (x | y) : s:: t : t : 's -> t : 's t uint{8|16|32|64} ; c / t (x) : t (y) : s => c / t (x & y) : sxor:: t : t : 's -> t : 's t uint{8|16|32|64}xor ; c / t (x) : t (y) : s => c / t (x ^ y) : s:: t : 's -> t : 's t uint{8|16|32|64} ; c / t (x) : s => c / t (~x) : slsl:: t : uint8 (s) : 's -> t : 's t uint{8|16|32|64}lsl ; c / t (x) : uint8 (s) : s => c / t (x << s) : siff s <= bits (t)lsl ; c / t (x) : uint8 (s) : s => [fail]lsr:: t : uint8 (s) : 's -> t : 's t uint{8|16|32|64}lsr ; c / t (x) : uint8 (s) : s => c / t (x >>> s) : siff s <= bits (t)lsr ; c / t (x) : uint8 (s) : s => [fail]compare:integer comparison (signed unsigned according the type).:: t : t : 's -> int64 : 's t uint{8|16|32|64}operations stringsstrings are mostly used naming things without having rely external id databases. what be done is basically stringconstants is, concatenate and them keys.concat:string concatenation.:: string : string : 's -> string : 'scompare:lexicographic comparison.:: string : string : 's -> int64 : 'soperations pairspair:build pair the stack's top elements.:: ' : 'b : 's -> pair ' 'b : 'spair ; c / : b : s => c / (pair b) : sp(*ai)+r: syntactic sugar building nested pairs bulk.p(\\fst=*)ai(est=(aai)+)r ; c / s => p(\\fst)air ; p(est)r ; c / spa(est=)air ; c / s => dip (p(est)air) ; c / scar:access left part a pair.:: pair ' _ : 's -> ' : 'scar ; c / (pair _) : s => c / : scdr:access right part a pair.:: pair _ 'b : 's -> 'b : 'scar ; c / (pair _ b) : s => c / b : sc[ad]+r: syntactic sugar accessing fields nested pairs.ca(est=[ad]+)r ; c / s => car ; c(est)r ; c / scd(est=[ad]+)r ; c / s => cdr ; c(est)r ; c / soperations setsempty_set 'elt:build new, empty set elements a given type.:: 's -> set 'elt : 's 'elt type must comparable ( compare primitive must defined it).mem:check the presence an element a set.:: 'key : set 'elt : 's -> bool : 'supdate:inserts removes element a set, replacing previous value.:: 'elt : bool : set 'elt : 's -> set 'elt : 'sreduce:apply function a set passing result eachapplication the next and return last.:: lambda (pair 'elt * 'b) 'b : set 'elt : 'b : 's -> 'b : 'soperations mapsempty_map 'key 'val:build new, empty map. 'key type must comparable ( compare primitive must defined it).:: 's -> map 'key 'val : 's:access element a map, returns optional value bechecked if_some.:: 'key : map 'key 'val : 's -> option 'val : 'smem:check the presence an element a map.:: 'key : map 'key 'val : 's -> bool : 'supdate:assign remove element a map.:: 'key : option 'val : map 'key 'val : 's -> map 'key 'val : 'smap:apply function a map return map results under same bindings.:: lambda (pair 'key 'val) 'b : map 'key 'val : 's -> map 'key 'b : 'sreduce:apply function a map passing result eachapplication the next and return last.:: lambda (pair (pair 'key 'val) 'b) 'b : map 'key 'val : 'b : 's -> 'b : 'soperations optional values:pack present optional value.:: ' : 's -> '? : 's ; c / v :: s => c / ( v) :: snone ':the absent optional value.:: 's -> '? : 'snone ; c / v :: s => c / none :: sif_some bt bf:inspect optional value.:: '? : 's -> 'b : 'siff bt :: [ ' : 's -> 'b : 's]bf :: [ 's -> 'b : 's]if_some ; c / ( a) : s => bt ; c / : sif_some ; c / (none) : s => bf ; c / soperations unionsleft 'b:pack value a union (left case).:: ' : 's -> 'a 'b : 'sleft ; c / v :: s => c / (left v) :: sright ':pack value a union (right case).:: 'b : 's -> 'a 'b : 'sright ; c / v :: s => c / (right v) :: sif_left bt bf:inspect optional value.:: 'a 'b : 's -> 'c : 'siff bt :: [ ' : 's -> 'c : 's]bf :: [ 'b : 's -> 'c : 's]if_left ; c / (left ) : s => bt ; c / : sif_left ; c / (right b) : s => bf ; c / b : soperations listscons:prepend element a list.:: ' : list ' : 's -> list ' : 'scons ; c / : l : s => c / (cons l) : snil ':the empty list.:: 's -> list ' : 'snil ; c / s => c / nil : sif_cons bt bf:inspect optional value.:: list ' : 's -> 'b : 'siff bt :: [ ' : list ' : 's -> 'b : 's]bf :: [ 's -> 'b : 's]if_cons ; c / (cons rest) : s => bt ; c / : rest : sif_cons ; c / nil : s => bf ; c / smap:apply function a list left right return list results the same order.:: lambda ' 'b : list ' : 's -> list 'b : 'sreduce:apply function a list left rightpassing result each application the next and return last.:: lambda (pair ' 'b) 'b : list ' : 'b : 's -> 'b : 'svi - domain specific data typestimestamp:dates the real world.tez: specific type manipulating tokens.contract 'param 'result: contract, the type its code.key: public cryptography key.signature: cryptographic signature.vii - domain specific operationsoperations timestampstimestamp immediates be obtained the operation, retrieved script parameters globals. only valid operationsare addition a (positive) number seconds the comparison.addincrement / decrement timestamp the given number seconds.:: timestamp : float : 's -> timestamp : 'sadd ; c / t : period : s => [fail] iff period < 0add ; c / t : period : s => c / (t + period seconds) : saddincrement / decrement timestamp the given number seconds.:: timestamp : uint{8|16|32|64} : 's -> timestamp : 'sadd ; c / t : seconds : s => [fail] overflowadd ; c / t : seconds : s => c / (t + seconds) : scompare:timestamp comparison.:: timestamp : timestamp : 's -> int64 : 'soperations tezoperations tez are limited prevent overflow mixing with numerical types mistake. are mandatorily checked under/overflows.add::: tez : tez : 's -> tez : 'sadd ; c / x : y : s => [fail] overflowadd ; c / x : y : s => c / (x + y) : ssub::: tez : tez : 's -> tez : 'ssub ; c / x : y : s => [fail] iff x < ysub ; c / x : y : s => c / (x - y) : smul:: tez : u?int{8|16|32|64} : 's -> tez : 'smul ; c / x : y : s => [fail] overflowmul ; c / x : y : s => c / (x * y) : scompare::: tez : tez : 's -> int64 : 'soperations contractsmanager:access manager a contract.:: contract 'p 'r : 's -> key : 'screate_contract:forge new contract.:: key : key? : bool : bool : tez : lambda (pair (pair tez 'p) 'g) (pair 'r 'g) : 'g : 's-> contract 'p 'r : 's with non code-emitted originations contract code takes argument transfered amount plus ad-hoc argument returns ad-hoc value. code takes global data returns to stored retrieved thenext transaction. data are initialized anotherparameter. calling convention the code is follows:(pair (pair amount arg) globals)) -> (pair ret globals), extrapolable the instruction type. first parameters are manager, optional delegate, spendable delegatableflags finally initial amount taken the currentlyexecuted contract. contract is returned a classvalue be called immediately stored.create_account:forge account ( contract without code).:: key : key? : bool : tez : 's -> contract unit unit : 's as argument manager, optional delegate, delegatableflag finally initial amount taken the currentlyexecuted contract.transfer_tokens:forge evaluate transaction.:: 'p : tez : contract 'p 'r : 'g : [] -> 'r : 'g : [] parameter return value must consistent the onesexpected the contract, unit an account. preserve global consistency the system, current contract's storagemust updated before passing control another script. this, script must put partially updated storage thestack ('g is type the contract's storage). a recursivecall the current contract happened, updated storage is put the stack next the return value. nothing else remain the stack during nested call. some local values to kept after nested call, have be storedexplicitly a transient part the storage. trivial example that is reserve boolean the storage, initialized false, reset false the end each contract execution, set true during nested call. thus gives easy for contract prevent recursive call ( contract fails the boolean is true).balance:push current amount tez the current contract.:: 's -> tez :: 'ssource 'p 'r:push source contract the current transaction.:: 's -> contract 'p 'r :: 'sself:push current contract.:: 's -> contract 'p 'r :: 'swhere contract 'p 'r is type the current contractamount:push amount the current transaction.:: 's -> tez :: 'sspecial operationssteps_to_quota:push remaining steps before contract execution must terminate.:: 's -> uint32 :: 's:push timestamp the block whose validation triggered execution (does change during execution the contract).:: 's -> timestamp :: 'scryptographic primitivesh:compute cryptographic hash the value contents using sha256 cryptographic algorithm.:: ' : 's -> string : 'scheck_signaturecheck a sequence bytes has been signed a given key.:: key : pair signature string : 's -> bool : 'scompare:: key : key : 's -> int64 : 'sviii - concrete syntax concrete language is very close the formal notation thespecification. structure is extremely simple: expression thelanguage only one the three following constructs. constant (integer string). application a primitive a sequence expressions. sequence expressions.constants are kinds constants:integers decimal ( prefix), hexadecimal (0x prefix), octal(0o prefix) binary (0b prefix).strings usual escapes , \\t, \\b, , \\\\, \\\".strings are encoding agnostic sequences bytes. non printablecharacters be escaped 3 digits decimal codes \\ddd 2 digit hexadecimal codes \\xhh.primitive applications the specification, primitive applications always luckily fit asingle line. this case, concrete syntax is exactly formalnotation. however, is sometimes necessary break lines a realprogram, can done follows. in python haskell, concrete syntax the language isindentation sensitive. elements a syntactical block, such all elements a sequence, all parameters a primitive,must written the exact same left margin the program sourcecode. is unlike c- languages, where blocks are delimited braces the margin is ignored the compiled. simplest form requires break line the primitive name after every argument. argument must indented at least more space the primitive, all arguments must sit the exactsame column.prim arg1 arg2 ... an argument a primitive application is primitive applicationitself, arguments must pushed further the right, lift ambiguity, in following example.prim1 prim2 arg1_prim2 arg2_prim2 arg2_prim1 is possible put successive arguments a single line using semicolon a separator:prim arg1; arg2 arg3; arg4 is possible add arguments the same line the primitive a lighter to write simple expressions. other representation the example is:prim arg1 arg2 ... is possible mix both notations in:prim arg1 arg2 arg3 arg4 even:prim arg1 arg2 arg3; arg4both equivalent :prim arg1 arg2 arg3 arg4trayling semicolons are ignored:prim arg1; arg2calling primitive a compound argument a single line isallowed wrapping parentheses. another notation the secondexample is:prim1 (prim2 arg1_prim2 arg2_prim2) arg2_prim1sequencessuccessive expression be grouped a single sequence expressionusing braces delimiters semicolon separators.{ expr1 ; expr2 ; expr3 ; expr4 } sequence block be split several lines. this situation, whole block, including closing brace, must indented respect the instruction.{ expr1 ; expr2 expr3 ; expr4 }blocks be passed argument a primitive.prim arg1 arg2 { arg3_expr1 ; arg3_expr2 arg3_expr3 ; arg3_expr4 }conventions concrete syntax follows same lexical conventions thespecification: instructions are represented uppercase identifiers,type constructors lowercase identifiers, constant constructorsare capitalised.lists be written a single shot instead a succession cons(list 1 2 3) = (cons 1 (cons 2 (cons 3 nil))) domain specific constants are strings specific formats:tez amounts are written using same notation json schemas the command line client: thousands are optionally separated comas, centiles, present, must prefixed a period. regexp form: ([0-9]{1,3}(,[0-9]{3})+)|[0-9]+(\\.[0.9]{2})?\"1234567\" means 123456700 tez centiles\"1,234,567\" means 123456700 tez centiles\"1234567.89\" means 123456789 tez centiles\"1,234,567.00\" means 123456789 tez centiles\"1234,567\" is invalid\"1,234,567.\" is invalid\"1,234,567.0\" is invalidtimestamps are written using rfc 339 notation.contracts are raw strings returned json rpcs the commandline interface cannot forged hand their format is no interest here.keys are sha256 hashes ed25519 public keys encoded base48 format the following custom alphabet:\"exmne9qvhpqddcfx5j86rt7vrm2ataypghglfbs3ckjnksb4\".signatures are ed25519 signatures a series hex-encoded bytes. prevent errors, control flow primitives take instructions parameters require sequences the concrete syntax. { instr1_true ; instr2_true ; ... } { instr1_false ; instr2_false ; ... } { instr1_true ; instr2_true ; ... } { instr1_false ; instr2_false ; ... }main program structure toplevel a smart contract file must an undelimited sequence four primitive applications ( no particular order) provide parameter, return storage types, well its code. the next section a concrete example.comments hash sign (#) anywhere outside a string literal make rest the line ( itself) completely ignored, in followingexample.push int8 1 # pushes 1push int8 2 # pushes 2add # computes 2 + 1ix - examplescontracts the system are stored a piece code a globaldata storage. type the global data the storage is fixed each contract origination . this is ensured statically checking origination the code preserves type the globaldata. this, code the contract is checked be thefollowing type lambda (pair (pair tez 'arg) 'global) -> (pair 'ret'global) where 'global is type the original global store given origination. contract takes parameter an amount, returns value, hence complete calling convention above.empty contract of calling convention, empty sequence is a validcontract type (contract unit unit). code building contract such type must a unit argument, amount tez, transform unit global storage, must thus of type (lambda (pair (pair tez unit) unit) (pair unit unit)).such minimal contract code is thus { cdr ; unit ; pair }. valid contract source file be follows.code { cdr ; unit ; pair }storage unitparameter unitreturn unitreservoir contract want create contract stores tez until timestamp t amaximum amount n is reached. whenever n is reached before t, tokensare reversed an account b ( the contract is automaticallydeleted). call the contract's code performed t otherwise transfer tokens another account .we to build contract a reusable manner, we nothard-code parameters. instead, assume the global data the contract are (pair (pair t n) (pair b)).hence, global data the contract has following type'g = pair pair timestamp tez pair (contract unit unit) (contract unit unit)following contract calling convention, code is lambda typelambda pair (pair tez unit) 'g pair unit 'gwriten lambda pair (pair tez unit) pair pair timestamp tez pair (contract unit unit) (contract unit unit) pair unit pair pair timestamp tez pair (contract unit unit) (contract unit unit) complete source reservoir.tz is:parameter timestamp ;storage pair (pair timestamp tez) # t n (pair (contract unit unit) (contract unit unit)) ; # breturn unit ;code { dup ; cdaar ; # t ; compare ; le ; { dup ; cdadr ; # n balance ; compare ; le ; { cdr ; unit ; pair } { dup ; cdddr ; # b balance ; unit ; diiip { cdr } ; transfer_tokens ; pair } } { dup ; cddar ; # balance ; unit ; diiip { cdr } ; transfer_tokens ; pair } }reservoir contract (variant broker status) basically the same contract the previous , but instead destroying , we to keep alive, storing flag s that can tell afterwards the tokens been transfered a b. also a broker x get fee p any case. thus add variables p s x the global data thecontract, (pair (s, pair (t, pair (pair p n) (pair x (pair b))))).p is fee broker , s is state, a string \"open\",\"timeout\" \"success\". the beginning the transaction: s is accessible via cdar t via cddar p via cdddaar n via cdddadr x via cddddar via cdddddar b via cddddddr the contract stay alive, test all least (tez \"1.00\") isstill available each transaction. value is given anexample must updated according the actual tezos minmalvalue contract balance. complete source scrutable_reservoir.tz is:parameter timestamp ;storage pair string # s pair timestamp # t pair (pair tez tez) ; # p n pair (contract unit unit) # x pair (contract unit unit) (contract unit unit) ; # breturn unit ;code { dup ; cdar # s push string \"open\" ; compare ; neq ; { fail } # \"success\", \"timeout\" a bad init value { dup ; cddar ; # t ; compare ; lt ; { # before timeout # compute ((1 + p) + n) tez keeping contract alive push tez \"1.00\" ; dip { dup ; cdddaar } ; add ; # p dip { dup ; cdddadr } ; add ; # n # compare the cumulated amount balance ; compare; lt ; { # not enough cash, just accept transaction # leave global untouched cdr } { # enough cash, successful ending # update global cddr ; push string \"success\" ; pair ; # transfer fee the broker dup ; cddaar ; # p dip { dup ; cdddar } # x unit ; transfer_tokens ; drop ; # transfer rest a dup ; cddadr ; # n dip { dup ; cddddar } # unit ; transfer_tokens ; drop } } { # timeout, refund # update global cddr ; push string \"timeout\" ; pair ; # try transfer fee the broker push tez \"1.00\" ; balance ; sub ; # available dip { dup ; cddaar } ; # p compare ; lt ; # available < p { push tez \"1.00\" ; balance ; sub ; # available dip { dup ; cdddar } # x unit ; transfer_tokens ; drop } { dup ; cddaar ; # p dip { dup ; cdddar } # x unit ; transfer_tokens ; drop } # transfer rest b push tez \"1.00\" ; balance ; sub ; # available dip { dup ; cdddddr } # b unit ; transfer_tokens ; drop } } # return unit unit ; pair }forward contract want write forward contract dried peas. contract takes global data tons peas q, expected delivery date t, contract agreement date z, strike k, collateral c per ton driedpeas, the accounts the buyer b, seller s the warehouse w. parameters grouped the global storage follows:pair pair (pair q (pair t z)) pair (pair k c) (pair (pair b s) w) typepair pair uint32 (pair timestamp timestamp) pair pair tez tez pair (pair account account) account 24 hours timestamp z are the buyer seller store collateral (q * c). this, contract takes string parameter, matching \"buyer\" \"seller\" indicating party which tokens are transfered. the end this , each them send transaction send tokens . for , we need store already paid how much, a (pair tez tez) where leftcomponent is buyer the right the seller. the day, nothing cam happen until t.during 24 hours t, buyer must pay (q * k) thecontract, minus amount already sent. this , if buyer didn't pay enough any transaction send the tokens the seller.otherwise, seller must deliver least q tons dried peas the warehouse, the next 24 hours. the amount is equal orexceeds q, the tokens are transfered the seller the contractis destroyed. storing quantity peas already delivered, add counter type uint32 the global storage. knowing quantity, accept messages w a partial amount deliveredpeas argument. this , any transaction send the tokens the buyer( enough peas been delivered time).hence, global storage is pair, the counters the left, the constant parameters the right, initially follows.pair pair 0 (pair 0_00 0_00) pair pair (pair q (pair t z)) pair (pair k c) (pair (pair b s) w) typepair pair unit32 (pair tez tez) pair pair uint32 (pair timestamp timestamp) pair pair tez tez pair (pair account account) account parameter the transaction be either transfer thebuyer the seller a delivery notification the warehouse type ( string uint32). the beginning the transaction:q is accessible via cddaart via cddadarz via cddaddrk via cdddaarc via cdddadrb via cddddaars via cddddadrw via cdddddr delivery counter via cdaar amount versed the buyer via cdadar amount versed the seller via cdaddr argument via cadr contract returns unit value, we assume it is created the minimum amount, set (tez \"1.00\"). complete source forward.tz is:parameter ( string uint32) ;return unit ;storage pair pair uint32 (pair tez tez) # counter from_buyer from_seller pair pair uint32 (pair timestamp timestamp) # q t z pair pair tez tez # k c pair pair (contract unit unit) (contract unit unit) # b s (contract unit unit); # wcode { dup ; cddaddr ; # z push uint64 86400 ; swap ; add ; # day second ; compare ; lt ; { # before z + 24 dup ; cadr ; # must receive (left \"buyer\") (left \"seller\") if_left { dup ; push string \"buyer\" ; compare ; eq ; { drop ; dup ; cdadar ; # amount already versed the buyer dip { dup ; caar } ; add ; # transaction # we rebuild globals dip { dup ; cdaddr } ; pair ; # seller amount push uint32 0 ; pair ; # delivery counter 0 dip { cddr } ; pair ; # parameters # return unit unit ; pair } { push string \"seller\" ; compare ; eq ; { dup ; cdaddr ; # amount already versed the seller dip { dup ; caar } ; add ; # transaction # we rebuild globals dip { dup ; cdadar } ; swap ; pair ; # buyer amount push uint32 0 ; pair ; # delivery counter 0 dip { cddr } ; pair ; # parameters # return unit unit ; pair } { fail } } } # (left _) { fail } } # (right _) { # z + 24 # test the required amount is reached dup ; cddaar ; # q dip { dup ; cdddadr } ; mul ; # c push uint8 2 ; mul ; push tez \"1.00\" ; add ; balance ; compare ; lt ; # balance < 2 * (q * c) + 1 { # refund parties cdr ; dup ; cadar ; # amount versed the buyer dip { dup ; cdddaar } # b unit ; transfer_tokens ; drop dup ; caddr ; # amount versed the seller dip { dup ; cdddadr } # s unit ; transfer_tokens ; drop balance ; # bonus the warehouse destroy account dip { dup ; cddddr } # w unit ; transfer_tokens ; drop # return unit, don't change global # since contract be destroyed unit ; pair } { # otherwise continue dup ; cddadar # t ; compare ; lt { fail } # between z + 24 t { # t dup ; cddadar # t push uint64 86400 ; add # day second ; compare ; lt { # between t t + 24 # only accept transactions the buyer dup ; cadr ; # must receive (left \"buyer\") if_left { push string \"buyer\" ; compare ; eq ; { dup ; cdadar ; # amount already versed the buyer dip { dup ; caar } ; add ; # transaction # amount must exceed q * k dup ; diip { dup ; cddaar ; # q dip { dup ; cdddaar } ; mul ; } ; # k dip { compare ; gt ; # amount > q * k { fail } { } } ; # abort continue # we rebuild globals dip { dup ; cdaddr } ; pair ; # seller amount push uint32 0 ; pair ; # delivery counter 0 dip { cddr } ; pair ; # parameters # return unit unit ; pair } { fail } } # (left _) { fail } } # (right _) { # t + 24 # test the required payment is reached dup ; cddaar ; # q dip { dup ; cdddaar } ; mul ; # k dip { dup ; cdadar } ; # amount already versed the buyer compare ; neq ; { # not reached, pay seller destroy contract balance ; dip { dup ; cddddadr } # s diip { cdr } ; unit ; transfer_tokens ; drop ; # return unit unit ; pair } { # otherwise continue dup ; cddadar # t push uint64 86400 ; add ; push uint64 86400 ; add ; # days second ; compare ; lt { # between t + 24 t + 48 # accept delivery notifications, w dup ; cdddddr ; manager ; # w source unit unit ; manager ; compare ; neq ; { fail } {} # fail not warehouse dup ; cadr ; # must receive (right amount) if_left { fail } # (left _) { # increment counter dip { dup ; cdaar } ; add ; # rebuild globals advance dip { dup ; cdadr } ; pair ; dip { cddr } ; pair ; unit ; pair ; # test enough been delivered dup ; cdaar ; dip { dup ; cddaar } ; compare ; lt ; # counter < q { cdr } # wait more { # transfer the money the seller balance ; # destroy contract dip { dup ; cddddadr } # s diip { cdr } ; unit ; transfer_tokens ; drop } } ; unit ; pair } { # t + 48, transfer everything the buyer balance ; # destroy contract dip { dup ; cddddaar } # b diip { cdr } ; unit ; transfer_tokens ; drop ; # return unit unit ; pair } } } } } } }x - full grammar<data> ::= | <int constant> | <string constant> | <timestamp string constant> | <signature string constant> | <key string constant> | <tez string constant> | <contract string constant> | unit | true | false | pair <data> <data> | left <data> | right <data> | <data> | none | list <data> ... | set <data> ... | map (item <data> <data>) ... | instruction<instruction> ::= | { <instruction> ... } | drop | dup | swap | push <type> <data> | | none <type> | if_none { <instruction> ... } { <instruction> ... } | pair | car | cdr | left <type> | right <type> | if_left { <instruction> ... } { <instruction> ... } | nil <type> | cons | if_cons { <instruction> ... } { <instruction> ... } | empty_set <type> | empty_map <comparable type> <type> | map | reduce | mem | | update | { <instruction> ... } { <instruction> ... } | loop { <instruction> ... } | lambda <type> <type> { <instruction> ... } | exec | dip { <instruction> ... } | fail | nop | concat | add | sub | mul | div | abs | neg | mod | lsl | lsr | | and | xor | | compare | eq | neq | lt | gt | le | ge | cast | checked_abs | checked_neg | checked_add | checked_sub | checked_mul | checked_cast | floor | ceil | inf | nan | isnan | nanan | manager | transfer_tokens | create_account | create_contract | | amount | balance | check_signature | h | steps_to_quota | source <type> <type><type> ::= | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | unit | string | tez | bool | key | timestamp | signature | option <type> | list <type> | set <comparable type> | contract <type> <type> | pair <type> <type> | <type> <type> | lambda <type> <type> | map <comparable type> <type><comparable type> ::= | int8 | int16 | int32 | int64 | uint8 | uint16 | uint32 | uint64 | string | tez | bool | key | timestampxi - reference implementation language is implemented ocaml follows: lower internal representation is written a gadt whose typeparameters encode exactly typing rules given thisspecification. other words, a program written thisrepresentation is accepted ocaml's typechecker, ismandatorily type-safe. of course valid programs handwritten generated ocaml code, we are sure anymanipulated code is type-safe. the end, remains be checked is encoding thetyping rules ocaml types, boils down half line code each instruction. everything else is left thevenerable well trusted ocaml. interpreter is basically direct transcription therewriting rules presented above. takes instruction, stack transforms . ocaml's typechecker ensures thetransformation respects pre post stack types declared the gadt case each instruction. only things remain we reviewed are value dependentchoices, such that did swap true false interpreting if instruction. input, untyped internal representation is ocaml adt the 5 grammar constructions: string, int, seq prim. is target language the parser, since allparsable programs are typed, thus simply beconstructed using gadt. typechecker is simple function recognizes abstractgrammar described section x pattern matching, producing well-typed, corresponding gadt expressions. is mostly checker, a full inferer, thus takes annotations(basically input output the program, lambdas ofuninitialized maps sets). works performing symbolic evaluation the program, transforming symbolicstack. only needs pass the whole program.here again, ocaml does of checking, structure thefunction is very simple, we to check is wetransform prim (\"\", ...) into if, prim (\"dup\", ...) a dup, etc."
}