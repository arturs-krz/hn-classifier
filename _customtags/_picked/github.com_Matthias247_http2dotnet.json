{
	"_id": "14524747",
	"site": "https://github.com/Matthias247/http2dotnet",
	"title": " HTTP/2 client and server library for .NET standard",
	"author": "Matthias247",
	"date": "2017-06-13T13:23:09.107Z",
	"tags": {
		"categories": [
			"opensource",
			"http2",
			"network",
			"csharp",
			"dotnet",
			"http",
			"hpack",
			"rfc-7541",
			"rfc-7540"
		],
		"languages": [
			"c#"
		]
	},
	"content": "readme.md http2dotnetnuget package: http2dotnet library implements http/2 hpack protocol .net standard. goal the library is cover protocol handling parts the http/2(rfc7540) hpack(rfc7541) specifications. goal this library is to provide ready--use http/2 server client framework concrete request/response abstractions. instead shouldenable .net libraries applications easily integrate http/2 support encapsulating protocol handling easy use flexible .net classes.examples building simple applications top the library are providedwithin repository.current state library is currently an experimental state. majority http/2features been implemented there is already pretty test coverage. was tested a h2c prior knowledge configuration against nghttp2 h2load. was however yet tested an encrypted connection a browser based client due missing ssl connection alpn negotiation.various features not yet been implemented ( current limitations).design goalsenable easy integration http/2 different frameworks applications (asp.net core, webservers, grpc, etc.)provide abstract interface http/2 streams, which custom request response classes be built. stream abstraction supports features the http/2 specification, including sending headers bothdirections, flow-controlled data trailing headers. request response are handled fully independet, enables features pure serverside data streaming.io layer independence: library uses abstract io interface, is defined thebytestreams.cs source file. io layer be implemented .net system.io.streams, pipelines,tcp sockets, tls sockets other io sources. abstract io interface is inspired the io interfaces. was chosen simplicity, high performance (async reads/writes be avoided) because can easily provide necessary flow control behavior.correctness reliability: http/2 frames are validated according the http/2 specification.full backpressure behavior is provided http/2 dataframes (through specified flow control mechanism) well for http/2 frames ( suspending reception further frames until suitableresponse a frame be sent).high performance: achieve high performance low overhead library tries minimizedynamic allocations whereever possible, e.g. through use valuetaskstructures reusing buffers data structures. possible library avoids async operations trying nonblocking operations to avoidscheduling continuation overhead.full support all http/2 features (however yet everything is implemented)usage library exposes 2 important classes:connection represents http/2 connection between client the server.http/2 connections are created top bidirectional streams. encryptedhttp/2 ( only variant support browser - called h2) connectionmust created top ssl connection. unencrypted connections (h2c) connection has be created top a tcp stream. top the connection multiple bidirectional streams be established.istream represents single bidirectional http/2 stream.each request/response pair http/2 is represented a single stream. the common lifecycle http/2 client create new stream top the connection, send required headers the request through stream, then send optional data through stream. server receive notification a create stream invoke request handler. requesthandler then read received headers, read incoming data thestream respond headers data.besides there are advanced features, e.g. both clients servers also cancel/reset stream during processing both are able sendtrailing headers the end a stream. library does create underlying tcp ssl connections server client side. is responsibility the library user. however pattern allows use library top arbitrary io stream types. create connection top io streams constructor connection be used:connectionconfiguration config = connectionconfigurationbuilder(isserver: true) .usestreamlistener(acceptincomingstream) .build();connection http2connection = connection( config: config, inputstream: inputstream, outputstream: outputstream);configuration settings are shared between multiple connections areconfigured through connectionconfigurationbuilder stores in connectionconfiguration instance. remaining parameters are unique each connection instance are configured directly thorugh connectionconstructor parameters. most important arguments the connection are:inputstream/outputstream: connection will the io streams read data the remote side send data the remote side. connection take ownership these streams close outputstream done.config: configuration the connection, is possibly shared other connection instances. most important arguments the connectionconfiguration are:isserver: specifies whether local side the connection represents http/2 server (true) client (false).usestreamlistener: sets the callback function will invokedevery a stream is initiated the remote side. means iscurrently required http/2 server applications. istream instance represents initiated stream is passed thecallback function an argument. callback function should either returntrue it wants process new stream false otherwise. the application wants process new stream must it anothertask must block callback.usesettings: http/2 settings should used. settings.defaultrepresents default values the http/2 specification should usually a choice. are utilized not explicitely specified.besides there are various optional arguments allow further control the desired behavior. the connection was set it handle http/2 protocol relatedconcerns to point where underlying connection gets closed. istream class allows read write headers bytes a singlehttp/2 stream. methods readheadersasync() writeheadersasync()allow read write headers a connection. returned valuetask readheadersasync only fulfilled onceheaders the remote side where received.according the http/2 request/reponse lifecycle applications to sendheaders the start each stream - means is allowed senddata before headers been sent. received headers contain pseudo-headers are used http/2 transmission the http method(:method), status code (:status), etc. are automatically extracted seperated fields istream is used requests responses -depending whether library is used a client server. however higherlevel frameworks easily extract fields the returned header lists. library always validate received sent headers correctness. means user the library the server side rely the fact the :method, :scheme :path pseudo headers are preset that the real header field pseudo header field follows. headers were sent a stream data be written the stream. istream implements bytestream abstractions this library, data be written through provided writeasync function. returned task only fulfilled the data be sent through underlyingconnection. will the available flow control windows account. stream be closed the calling closeasync function. alternativly endofstream parameter writeheadersasync be used closing stream without sending data (e.g. http requests). read writedirections http/2 are fully independet. means closing local side the stream still allow reading headers data the remote side. stream is fully closed all headers data were consumed theremote side addition the local side having been closed. read data the stream readasync function be used. function signal end stream the stream was closed the remote side. a stream wasclosed the remote side trailers be read through readtrailersasyncfunction. send trailers data must transferred instead closing stream closeasync setting endofstream true writetrailersasync function must used. cancel function the istream be used reset stream. will move stream the closed state it wasn't closed before. order notify remote side rst_stream frame be sent. streams must either fully processed (read side fully consumed - write side closed) cancelled/reset the application. otherwise stream be leaked. dispose method stream also cancel stream. following example shows handling a stream the server side:static async void handleincomingstream(istream stream){ try { // read headers var headers = await stream.readheadersasync(); var method = headers.(h => h.name == \":method\").value; var path = headers.(h => h.name == \":path\").value; // print request method path console.writeline(\"method: {0}, path: {1}\", method, path); // read request body write to console var buf = byte[2048]; while (true) { var readresult = await stream.readasync( arraysegment<byte>(buf)); (readresult.endofstream) break; // print received bytes console.writeline(encoding.ascii.getstring(buf, 0, readresult.bytesread)); } // send response consists headers a payload var responseheaders = headerfield[] { headerfield { name = \":status\", value = \"200\" }, headerfield { name = \"content-type\", value = \"text/html\" }, }; await stream.writeheadersasync(responseheaders, false); await stream.writeasync( arraysegment<byte>( encoding.ascii.getbytes(\"hello world!\")), true); // request is fully handled here } catch (exception) { stream.cancel(); }} istream apis are completely thread-safe, means can used an arbitrary thread. however user application must still follow basichttp/2 contracts, e.g. means now trailers may sent before data wassent, that neither data nor trailers might sent the end the streamwas already indicated.client stream creation library be used build http/2 clients. this usecase outgoingistreams need be created, represent sent request. can achieved through connection.createstreamasync() method, creates new outgoing stream. user must pass the required headers (including pseudo-headers :method, :path, :scheme optionally :authority) anargument, calling method directly lead sending http/2 headersframe the requested header fields. method return newlycreated stream.example creating using client stream, case http/2 connection hasalready been established configured client-side :headerfield[] headers = headerfield[]{ headerfield { name = \":method\", value = \"\" }, new headerfield { name = \":scheme\", value = \"http\" }, headerfield { name = \":path\", value = \"/\" },};var stream = await http2connection.createstreamasync( headers, endofstream: true);// wait response headersvar reponseheaders = await stream.readheadersasync();// read response datavar readdataresult = await stream.readasync(buffer);checking stream id exhaustion http/2 specification allows 2^30 streams be created a singleconnection. a client requires make more requests some it needs create new connection. library allows check whether newconnection needs be created through connection.isexhausted property, will return true no additional outgoing stream be created.checking the maximum concurrent streams limit the remote side library currently does take maximum concurrent streams setting account, is indicated a remote through http/2 settings frame. means will try create amount streams the user requests, the risk the remote side resetting those streams. future update mightprovide additional possibility check current maximum concurrent streamlimit.server side connection upgrades section applies unsecure http. the case https protocolnegotiation must always happen the means application-layer protocolnegotiation (alpn).upgrading http/1.1 library supports http connection upgrade requests server side.example code how upgrade be performed be found theupgradeexampleserver. order upgrade http/1.1 http/2, external http/1.1 parser isneeded reads complete upgrade request memory (including optional body). the headers the received http/1.1 request contain related upgradeheaders (connection: upgrade, http2-settings), payload be checked whether is valid upgrade request not. order perform step serverupgraderequestbuilder instance must created, gets fed theinformation (headers, payload, request method, etc.) the http/1.1 request. the serverupgraderequestbuilder.build() method serverupgraderequest be created, exposes isvalid property property reflectswhether incoming request is fully valid upgrade request. if upgrade request is valid http/2 connection object may created, get's inital upgrade request injected the constructor part the connection.options struct. this case connection create http/2 stream the content the initial upgrade request, can handled any http/2 stream/request. case upgrade request is valid, is applications responsibility send http/1.1 101 switching protocols response before creating http/2connection object - won't perform step, instead directly speakhttp/2. case upgrade request is valid, application may choose eithertreat request a normal http/1.1 request ( filtering ugprade related)headers, by responding an http error. if upgrade headers are available valid the initial http/1.1request, applications may choose to perform upgrade instead handle request a normal http/1.1 request. example scenario this is the upgrade request indicates large body (through content-length header), would needed be completely read memory before upgrade beperformed: the application doesn't perform upgrade just handles request traditional fashion, request body be streamed normalhttp/1.1 fashion. is generelly recommended accept upgrade requests contain body payload. however client side libraries performupgrades (e.g. nghttp), perform upgrade via and headrequests anyway.handling http/2 ( and without upgrade) http/1 parallel some scenarios might required implement http server supports of following scenarios:support standard http/1.1 requestssupport http/2 requests prior knowledge ( client knows theserver speaks http/2 no upgrade is required).support upgrading http/1.1 http/2 library supports scenario, a suitable example implementation be found the upgradeexampleserver example. idea is the application ( web-server is built around library) starts off reading parsing initial http/1.1 request headerthrough 's preferred http parser. the request header exactly equals pri * http/2.0 's start a http/2 connection prior knowledge. this case application directly create http/2 connection object top the incoming stream delegate further processing it. this special case, application must sure the stream is passed the connectionobject still emits pri * http/2.0 header the connectionstarts reading it. otherwise connection establishment fail. means application must inspect, not consume header. the request is another http/1.1 request contains ugprade headers, application handle as described the upgrading http/1.1 server sidesection. this case 's applications responsibility consume ugprade request the underlying stream send necessary upgradestatus response. the request header is http/1.1 request without upgrade headers, application directly handle in 's preferred .if incoming data resembles http request all, application also handle in 's preferred , e.g. optionally sending http errorcode closing connection. the two cases actual http requests the connection furtherflow the application through the means this libraries istreamabstraction. the third case depends the approach http/1.1 parrsing processing. 's applications responsibility transform requestkinds a common request/response representation needed.client side connection upgradesupgrading http/1.1 library supports http connection upgrade requests client side asimilar fashion they are supported the server side. example code how upgrade be performed be found the cliexample. order upgrade http/1.1 http/2, user has send normalhttp/1.1 request contains required upgrade headers the server.sending request the underyling tcp connection is outside the scope this library. the http/1.1 response status line headers are received user codemust check whether upgrade was successful not. the success case http/2 connection object be constructed top the connection. connection object obtain ownership the underlying streams ( which http/1.1 data already has been consumed) an information that fact the connection was created part an upgrade, in case stream already existing startup. performing client side upgrades, first step is create clientupgraderequestbuilder, allows configure http/2 settings will later used. through clientupgraderequestbuilder.build()method clientupgraderequest be created. clientupgraderequest exposes isvalid property reflects whether upgrade request is valid. if upgrade request is valid http/2 connection object may created. clientupgraderequest contains base64encodedsettings property, returns base64 encoded settings the user must send the serverinside http2-settings header during upgrade attempt. case user received http/1.1 101 switching protocols status connection object be created top the underlying streams. connection must informed the pending upgrade attempt through connection.options.clientupgraderequest constructor option. response the http/1.1 request triggered upgrade in case delivered through http/2 stream, will always utilize stream id 1. the stream was created implicitly through upgrade notdue calling createstreamasync() created istream must returned the user another fashion: user retrieve reference this stream through clientupgraderequest.upgraderequeststream property, returns task<istream> will fulfilled once connection has beencreated used upgraderequest. due this fact clientupgraderequest instance may not reused performing multipleconnection upgrade requests. will bound the connection which gets handed .handling http/2 ( and without upgrade) http/1 parallel order handle http/2 client side a possible fallback http/1.1 servers do support http/1.1 upgrade mechanism be used: first request form client be started a http/1.1 request, contains connection upgrade request it's headers. the server responds 101 switching protocols a http/2 connection be established top this connection the response this request well furtherrequests be performed http/2 fashion. the server ignores upgrade response must normally processed a http/1.1 reader.ping handling library automatically respond received ping frames sending associated ping acks. user also issue pings the local side the connection through pingasync method the connection class. calling method issuesending ping frame the remote side the connection. returns task will completed once either remote side acknowledges ping theconnection was closed. the connection closes before ack was received returned task fail a connectionclosedexception.example measuring connection latency through ping mechanism:try{ var stopwatch = stopwatch(); stopwatch.start(); await http2connection.pingasync(); // ping request was sent acknowledge has been received stopwatch.stop(); var latency = stopwatch.elapsed;}catch (connectionclosedexception){ // connection was closed before acknowledge the ping // was received}informational headers library supports sending informational headers (http status code the 1xyrange) server side receiving on client side. send informational headers server side user simply callstream.writeheadersasync multiple times. is possible send multiplesets informational headers before set headers the final statuscode is written. the final header set may set endofstream true.users should write data before header a final :status code (outside the 100 range) was sent - this be detected a protocol error the client side. receive informational headers the client side stream.readheadersasync()may called multiple times the client side the special case where callreturns headers a status: 1xy field. these cases next call readheadersasync() block until next set headers (either informational of final response) be received.example:var headers = await stream.readheadersasync(); (headers.(h => h.name == \":status\").value == \"100\"){ // received informational headers headers = await stream.readheadersasync(); // headers contains next set received headers.}remark: the server sends multiple sets informational headers possibly final headers before user calls stream.readheadersasync(), call only deliver last delivered set headers the user. headers are queued internally overwritten. however known -cases informationalheaders ( 100 continue header) causes problem, since server only send more headers user interaction (sending data).performance considerations achieving best possible performance following things should considered: io stream abstractions are handed to connection should optimized handling small writes reads a fast . e.g. librarymight often try read write a few bytes, the header a http/2frame. this case io operation should operate synchronously possible. tcp socket wrappers are provided inside library (socketextensions.createstreams()) e.g. provide behavior trying perform synchronous nonblocking read write operations before falling into async behavior. library try allocate send receive buffers a customarraypool<byte> allocator can provided the user through connectionconfigurationbuilder.usebufferpool() setting. no allocator isspecified arraypool<byte>.shared is used, might be optimal http/2 operations. library use allocator allocate buffers up settings.maxframesize bytes normal operation. therefore configured allocator be optimized these kind buffer sizes.current limitations library currently faces following limitations:missing support push promises.missing support reading remote settings application side. scheduling outgoing data frames is very basic relies mostly flowcontrol windows the maximum supported frame size. is currently guaranteed concurrent streams equal flow control windows get same amount bandwith.http/2 priorization features are not supported - however are optionalaccording the http/2 specification may be required lots applications."
}