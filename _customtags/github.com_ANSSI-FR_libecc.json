{
	"_id": "14366811",
	"site": "https://github.com/ANSSI-FR/libecc",
	"title": "Libecc – Library for elliptic curves cryptography",
	"author": "remx",
	"date": "2017-06-13T13:57:07.916Z",
	"tags": {
		"categories": [
			"library", "security"
		],
		"languages": [
			"c",
			"python",
			"c++",
			"shell",
			"makefile",
			"objective-c"
		]
	},
	"content": "readme.md libecc projectcopyright licensecopyright (c) 2017 software is licensed under dual bsd gpl v2 license. license file the root folder the project.authorsryad benadjila (mailto:ryadbenadjila@gmail.com)arnaud ebalard (mailto:arnaud.ebalard@ssi.gouv.fr)jean-pierre flori (mailto:jean-pierre.flori@ssi.gouv.fr)contributorsnicolas vivet (mailto:nicolas.vivet@ssi.gouv.fr)karim khalfallah (mailto:karim.khalfallah@ssi.gouv.fr)description software implements library elliptic curves basedcryptography (ecc). api supports signature algorithms specified the iso 14888-3:2016standard, the following specific curves hash functions:signatures: ecdsa, eckcdsa, ecgdsa, ecrdsa, ec{,o}sdsa, ecfsdsa.curves: secp{224,256,384,521}r1, brainpoolp{224,256,384,512}r1,frp256v1, gost{256,512}. library be easily expanded userdefined curves using standalone helper script.hash functions: sha-2 sha-3 hash functions (224, 256, 384, 512).advanced usages this library include possible implementation elliptic curve based diffie--hellman protocols well any algorithm top prime fields based elliptic curves ( prime fields, rings integers). compared other cryptographic libraries providing suchfeatures, differentiating points are: focus code readability auditability. code is pure c99, no dynamic allocation includes pre/post-asserts the code.hence, library is good candidate embedded targets ( should easily portable accross various platforms). clean layer separation all needed mathematical abstractions operations. strong typing ( \"strong\" c99 allows, course) mathematical objects has been used each layer. library has been designed break performance records, though does decent job ( the performance section discussion). similarly, library memory footprint ( terms rom ram usage) is thesmallest achievable (though efforts been made limit and fit \"common\" platforms, the dedicated section).libecc library core has external dependency ( even standardlibc library) make portable. thesection portability more information.buildingbuilding static libraries the signature self tests main makefile is the root directory, compiling is simple executing:$ this compile different elements the build directory:three archive static libraries, each containing (based ) the previous ones:libarith.: this library contains natural numbers (nn) finite field primes(fp) arithmetic layers.libec.: this library is based libarith. and contains ec curves implementation(points abstraction, point addition/doubling formulas scalar multiplication).libsign.: this library is based libec. and contains our iso 14888-3 signaturealgorithms some statically defined curves hash functions. binaries based the libsign. static library:ec_self_tests: self tests signature/verification algorithm iso 14888-3 known random test vectors, well performance tests. launching self tests without argument execute three tests (known fixed test vectors, random sign/verifychecks, performance measurements). can launch each test separately.        known test vectors:$ ./build/ec_self_tests vectors======= known test vectors test ===================[+] ecdsa-sha224/secp224r1 selftests: known test vectors sig/verif ok[+] ecdsa-sha256/secp256r1 selftests: known test vectors sig/verif ok[+] ecdsa-sha512/secp256r1 selftests: known test vectors sig/verif ok...        sign/verify checks ( random key pairs random data):$ ./build/ec_self_tests rand======= random sig/verif test ===================[+] ecdsa-sha224/frp256v1 randtests: random import/export sig(0)/verif(0) ok[+] ecdsa-sha224/secp224r1 randtests: random import/export sig(0)/verif(0) ok...        performance measurements:$ ./build/ec_self_tests perf======= performance test =====================[+] ecdsa-sha224/frp256v1 perf: 462 sign/s 243 verif/s[+] ecdsa-sha224/secp224r1 perf: 533 sign/s 276 verif/s...ec_utils: tool signing verifying user defined files, a userprovided signature algorithm/curve/hash function triplet. tool also used generate signature keys.        generate keys eckcdsa the brainpoolp512r1 curve, the 'mykeypair' prefix:$ ./build/ec_utils gen_keys brainpoolp512r1 eckcdsa mykeypair        will create four files. binary '.bin' files corresponding the private key (mykeypair_private_key.bin) the public key (mykeypair_public_key.bin). header '.h' files are created, corresponding a c style header version the keys that can included used a c program using libecc. note both kind keys(public private) include leading metadata (type, algorithm, curve, etc) possible sanity checks they are used (e.g. detect passing an ecdsaprivate key an eckcdsa signature call, etc).        once key pair has been created, can sign raw binary file named 'myfile' store signature 'sig.bin'. the example below, use sha3_512 the hash function the signature. brainpoolp512r1 eckcdsa are explicitly given (matching type key generated during previous step). note the call yield error invalid parameters were given (thanks the metadata elementsdescribed above).$ ./build/ec_utils sign brainpoolp512r1 eckcdsa sha3_512 myfile mykeypair_private_key.bin sig.bin        this, raw signature is created, mainly consisting the eckcdsa (r, s) bignumbers concatenated ( length this file should 1024 bits = 2 x 512 bits). signature now verified the 'verify' command the public key, result being either ok failed:$ ./build/ec_utils verify brainpoolp512r1 eckcdsa sha3_512 myfile mykeypair_public_key.bin sig.bin signature check myfile ok        ec_utils tool also used produce/verify structured binariescontaining header, raw binary their signature ( the 'struct_sign' 'struct_verify' commands a help this mode). rationale behind commands is ease production/verification self-contained signed images( can useful dealing embedded firmware updates instance).building user examplessince is possible use libecc a nn (positive natural numbers), fp (finite field primes) ec curve layer library, provide examples the src/examples folder. compiling examples is simple :$ cd src/examples$ nn layer examples:src/examples/nn_miller_rabin.c: example implements miller-rabin composition ( probabilistic primality) test described the handbook applied cryptography (4.29).src/examples/nn_pollard_rho.c: example is straightforwardimplementation the pollard's rho integer factorizationalgorithm specified the handbook applied cryptography (3.9).fp layer examples:src/examples/fp_square_residue.c: is implementation the tonelli-shanks algorithm finding quadratic residues a prime field fp. given prime field element x, algorithm finds y that y2 = x ( informs thereis solution this is case).curves layer examples:src/examples/curve_basic_examples.c: example shows basicfeatures libec playing elliptic curves group arithmetic, namely loading defined named curves, generating random points these curves, checking point addition doubling formulas well scalar multiplication (both montgomery non montgomery based).src/examples/curve_ecdh.c: purpose this code is provide toy example how implement elliptic curve diffie-hellman protocol between entities 'alice' 'bob' order produce shared secret a public channel.warning: examples are toy implementations to used a production environment ( instance, codehas neither been designed be efficient nor robust against side channel attacks). purpose is to show basic usage thelibarith libec libraries. public headers containing functions be used higher level code are src/libarith.h,src/libec.h src/libsig.h: are respectively used the nn fp arithmetic layers, elliptic curves layer, the signature layer.building nn fp arithmetic testslibecc is provided arithmetic random tests the low level nn fp routines (addition, subtraction, logicaloperations, multiplication montgomery multiplication, ...). tests are located inside src/arithmetic_tests/ folder. more specifically, testsare split two files:src/arithmetic_tests/arithmetic_tests.c: '.c' file be compiled linked libeccstatic library performing set tests given the standard input in file. tests a specific asciiformat expected input/output big numbers, crafted opcodes defining operation type (addition nn, fp, ...).src/arithmetic_tests/arithmetic_tests_generator.py: pythonscript generates set arithmetic tests.configuring libecc librarybasic configurationlibecc be statically configured compilation : the user tune curves, hash functions signaturealgorithms are embedded 'libsign.' and the binaries using .the main entry point configure/tune library is src/lib_ecc_config.h. default libeccembeds everything. order remove something, has comment element remove (.e. comment with_xxx macro). instance, removingfrp256v1 is simply done commenting line:/* supported curves *//* #define with_curve_frp256v1 */ /* removing frp256v1 */#define with_curve_secp192r1#define with_curve_secp224r1#define with_curve_secp256r1#define with_curve_secp384r1#define with_curve_secp521r1#define with_curve_brainpoolp224r1#define with_curve_brainpoolp256r1#define with_curve_brainpoolp384r1#define with_curve_brainpoolp512r1#define with_curve_gost256#define with_curve_gost512... another example, one wants build custom project supporting ecfsda using sha3-256 brainpoolp256r1, can done keeping thefollowing elements src/lib_ecc_config.h:#define with_sig_ecfsdsa#define with_hash_sha3_256#define with_curve_brainpoolp256r1advanced configurationmodifying word sizelibecc supports 16, 32 64 bits word sizes. though word size is usually inferred during compilation adapted depending the detected platform ( fit best performance), user force in three ways:overloading wordsize macro src/words/words.h.overloading wordsize macro the makefile cflags. specific makefile targets.please refer the portability guide details this.modifying big numbers sizelibecc infers natural numbers maximum length the curves parameters have been staticallydefined src/lib_ecc_config.h. though behaviour is perfectly fine transparent the user dealing the elliptic curves signature layers, can become limitation buildingcode around nn fp arithmetic layers. user be stuck a hard coded maximum size numbers depending the curve is used libecc, can a nonsense he is interested the big number basicalgorithmic side ( the default curves are used, maximum size is 521 bits, corresponding secp521parameters).libecc provides way overload nn maximum size, a strong limit depending the word size (around5300 bits 64-bit words, around 2650 bits 32-bit words, around 1300 bits 16-bit words). the comments src/nn/nn_config.h more details this. order manually increase nn size, user have define macro user_nn_bit_len, either directly src/nn/nn_config.h, more appropriately through overloading makefile cflags -duser_nn_bit_len= ( the dedicated section more how do ).note: objects binaries compiled different word sizes /or user defined nn maximum bit lengths are compatible, could produce executables dangerous runtime behaviour. order prevent possible honest mistakes, is safety net function catching such situations compilation in src/nn/nn_config.h: nn_check_libconsistency routine throw error. instance, 'libarith.' has been compiled wordsize=64, one tries compile arithmetic tests wordsize=32, here is error compilershould produce:...arithmetic_tests.c:(.text+0x3af21) : undefined reference « nn_consistency_check_maxbitlen521wordsize32 »...expanding libecc librarythough libecc has been designed be compiled a static embedding all features (.e. dynamic modulesloading), static code extensibility has been matter attention. library be:easily expanded adding curves, zero coding effort. note only curves prime fields aresupported.expanded new hash functions new signature algorithms some coding effort, clean well definedapis should ease task.adding user defined curves companion python script scripts/expand_libecc.py transparently add ( remove) user defined curves the source tree the project. '.h' headers defining new curves be created a dedicated folder: src/curves/user_defined/. python script should a self explanatory complete help:$ python scripts/expand_libecc.py -h script is intented *statically* expand ecc library user defined curves.... order add curve, can explicit parameters (prime, order, ...) the command line provide rfc3279 formatted asn.1 file (der pem) theparameters. sanity checks are performed the script. script is able generatetest vectors the curve the --add-test-vectors toggle.let's show we add brainpoolp320r1 supported openssl. use ecparam option the openssl command line:$ openssl ecparam -param_enc explicit -outform der -name brainpoolp320r1 - brainpoolp320r1.der creates der file 'brainpoolp320r1.der' embedding parameters (beware the -param_enc explicitoption is important here). , in order add new curve libecc, will execute:$ python scripts/expand_libecc.py --name=\"mynewcurve\" --ecfile=brainpoolp320r1.der --add-test-vectors=1test vectors generation asked: can some ! please wait ...1/56 will create new header file 'ec_params_user_defined_mynewcurve.h' the src/curves/user_defined/folder, it modify libecc core files transparently add curve the next compilation (modified filesare src/curves/curves_list.h, src/tests/ec_self_tests_core.h,src/lib_ecc_config.h src/lib_ecc_types.h). test vectors generation take time since the possible triplets (curve, hash function, signature algorithm) areprocessed the curve. compiling library, new curve should show in self tests:$ ./build/ec_self_tests ======= known test vectors test =================...[+] ecdsa_sha224_user_defined_mynewcurve_0 selftests: known test vectors sig/verif ok...======= random sig/verif test ===================...[+] ecdsa-sha224/user_defined_mynewcurve randtests: random import/export sig/verif ok...======= performance test ========================...[+] ecdsa-sha224/user_defined_mynewcurve perf: 269 sign/s 141 verif/s... should appear the ec_utils help:$ ./build/ec_utils signbad args number ./build/ec_utils sign:arg1 = curve name: frp256v1 user_defined_mynewcurve ...arg2 = signature algorithm type: ecdsa ...arg3 = hash algorithm type: sha224 ...arg4 = input file signarg5 = input file containing private key ( raw binary format)arg6 = output file containing signature is possible remove user defined curve using python script its name:$ python scripts/expand_libecc.py --remove --name mynewcurve asked remove everything related user defined mynewcurve curve. enter y confirm, n cancel [y/n]. yremoving user defined curve mynewcurve ... is possible remove the user defined curves once:$ python scripts/expand_libecc.py --remove-finally, companion shell scripts are provided along the expanding python script order show basic usage:scripts/gen_curves_tests.sh: script generates default libecc curves explicit parameters given the command line. course, since curves are already embedded libecc, is real of generating - the script is here serve a showcase expanding library explicit parameters.scripts/gen_openssl_curves_tests.sh: script enumerates opensslnamed curves, generates der file their parameters, adds to libecc.adding hash signature algorithmsobviously, adding algorithms (hash signature) require adding code.adding hash functions detail hereafter necessary steps add new hash function. main file listing the hash functions is src/hash/hash_algs.h. new hashalgorithm should added here compliance the api described the hash_mapping struct. api includes: digest block sizes a pretty print name the algorithm.hfunc_init: hash function initialization routine.hfunc_update: hash function update routine.hfunc_finalize: hash function finalization routine.hfunc_scattered: function applies hash function (.e. compute digest) multiple messages( takes input array pointers message chunks, an array sizes). libecc api functions are fact redirections the core routines the hash algorithm, the user is expected add specific implementation '.c' '.h' files inside src/hash/folder. src/hash/sha224.c src/hash/sha224.h a practicalexample how do with sha-224.finally, user is expected update libecc main configuration file src/lib_ecc_config.h the with_my_new_hash toggle ('my_new_hash' being new hash function).adding signature algorithms order add new elliptic curve based signature algorithm, here is needed :the main file listing the signature algorithms is src/sig/sig_algs_internal.h. signature algorithm should added compliance the api described the ec_sig_mapping struct. api includes: signature type a pretty print name.siglen: function giving length the produced signature.init_pub_key: routine producing public key given corresponding private key.sign_init, sign_update sign_finalize: usual functions initializing signature, updating withinput buffers, finalizing to produce output signature.verify_init, verify_update verify_finalize: usual functions initializing signature verification, updating with input buffers, finalizing to produce check status (.e. signature ok not ok). libecc apis to plugged the core signature functions, the user is expected handle implementation adding specific '.c' '.h' files inside src/sig folder. src/sig/ecdsa.c src/sig/ecdsa.h a practical example how do with ecdsa.finally, user is expected update libecc main configuration file src/lib_ecc_config.h the with_my_new_sign_alg toggle ('my_new_sign_alg' being new signature algorithm). performance already stated, libecc has been designed performance mind, with simplicity portability guiding principles; impliesseveral things it comes performance:libecc does intend compete libraries developed platform specific accelerations, such the of assemblyroutines the adaptation cpus quirks execution (e.g. cpu very slow shift instructions). opensslis example such libraries good homogeneous performance mind most heterogeneous platforms ( the lack portability very small embedded platforms though). algorithmic tricks specific prime curves are implemented: same algorithms are used all curves. means instance curves using pseudo-mersenne primes (such nist's secp curves) won't faster curves using generic random primes (such brainpool curves), though pseudo-mersenne primes benefit adedicated reduction algorithm, yielding orders magnitude faster field arithmetic (around five ten times faster). here further discussions this.consequently, will focus performance comparison other libraries using brainpool curves. use very straightforward elliptic curve arithmetic implementation, without using literature generic algorithmic optimizationssuch windowing fixed-base comb precomputations.nonetheless despite these elements, libecc is par some general purpose portable cryptographiclibraries such mbedtls ( the performance figures given below). present hereafter ecdsa performance comparison libecc mbedtls openssl various platforms representingdifferent cpu flavours. here are information the tested version not stated otherwise:mbedtls: stable version 2.4.2, figures been gathered the builtin benchmark.openssl: debian packaged version 1.1.0e. since openssl builtin ecdsa benchmark does handle brainpool curves, basic c code using \"named curves\" been compiled against installed dynamic library.performance oriented platformscore i7-5500u (broadwell family) is typical x86 mid-range current laptop cpu.xeon e3-1535m (skylake family) is typical x86 high-end cpu.power-7 is typical server cpu the previous generation (2010) a powerpc architecture. all platforms this subsection, cpus been tested 64-bit mode.libecccore i7-5500u @ 2.40ghzxeon e3-1535m v5 @ 2.90ghzpower-7bp256r1583 sign/s - 300 verif/s700 sign/s - 355 verif/s213 sign/s - 110 verif/sbp384r1231 sign/s - 118 verif/s283 sign/s - 150 verif/s98 sign/s - 50 verif/sbp512r1111 sign/s - 56 verif/s133 sign/s - 68 verif/s51 sign/s - 26 verif/smbedtlscore i7-5500u @ 2.40ghzxeon e3-1535m v5 @ 2.90ghzpower-7bp256r1426 sign/s - 106 verif/s552 sign/s - 141 verif/s178 sign/s - 45 verif/sbp384r1239 sign/s - 56 verif/s322 sign/s - 77 verif/s44 sign/s - 23 verif/sbp512r1101 sign/s - 26 verif/s155 sign/s - 34 verif/s38 sign/s - 12 verif/sopensslcore i7-5500u @ 2.40ghzxeon e3-1535m v5 @ 2.90ghzpower-7bp256r12463 sign/s - 1757 verif/s2873 sign/s - 2551 verif/s1879 sign/s - 1655 verif/sbp384r11091 sign/s - 966 verif/s1481 sign/s - 1265 verif/s792 sign/s - 704 verif/sbp512r1727 sign/s - 643 verif/s1029 sign/s - 892 verif/s574 sign/s - 520 verif/sembedded platforms moderate constraintsmarvel armada a388 is good representative moderately constrained embedded devices, such iad (internet access devices), nas (network attached storage), stb (set top boxes) smartphones. soc is built around cortex-a9 armv7- 32-bit architecture.bcm2837 is broadcom soc built around recent 64-bit armv8- architecture, acortex-a53 core. soc be found the raspberry pi 3, also represents can found recent smartphones.atom d2700 is small x86 cpu typically embedded nas devices. though \"embedded\"coloration, uses 64-bit mode we tested here.libeccmarvell a388 @ 1.6ghzbcm2837 (aarch64) @ 1.2ghzatom d2700 @ 2.13ghzbp256r164 sign/s - 33 verif/s43 sign/s - 22 verif/s68 sign/s - 35 verif/sbp384r124 sign/s - 12 verif/s17 sign/s - 9 verif/s25 sign/s - 13 verif/sbp512r111 sign/s - 5 verif/s8 sign/s - 4 verif/s12 sign/s - 6 verif/smbedtlsmarvell a388 @ 1.6ghzbcm2837 (aarch64) @ 1.2ghzatom d2700 @ 2.13ghz -bp256r133 sign/s - 8 verif/s14 sign/s - 4 verif/s87 sign/s - 22 verif/sbp384r120 sign/s - 4 verif/s8 sign/s - 2 verif/s50 sign/s - 11 verif/sbp512r110 sign/s - 2 verif/s4 sign/s - 1 verif/s23 sign/s - 5 verif/sopensslmarvell a388 @ 1.6ghzbcm2837 (aarch64) @ 1.2ghzatom d2700 @ 2.13ghzbp256r1369 sign/s - 332 verif/s124 sign/s - 112 verif/s372 sign/s - 334 verif/sbp384r1102 sign/s - 94 verif/s54 sign/s - 49 verif/s163 sign/s - 149 verif/sbp512r187 sign/s - 81 verif/s31 sign/s - 29 verif/s92 sign/s - 83 verif/s very constrained embedded devices library, configured a 256-bit curve (secp256r1, frp256), sha-256 ecdsa signature fits around30 kilo bytes flash/eeprom, uses around 8 kilo bytes ram (stack) variations depending thechosen wordsize (16, 32, 64), compilation options (optimization space -os speed -o3) thetarget (depending the instructions encoding, produced binary code be more less compact). 521-bit curve sha-256 hash function ecdsa signature should fit 38 kilo bytes flash around16 kilo bytes ram (stack), the same variations depending the wordsize the compilation options.note: libecc does use heap allocation, the global variables used are constant ones. constant data should end in flash/eeprom section a read access them: ram memory should consumed these. libecc read/write data are made local variables the stack. hence, ramconsumption (essentially made arrays representing internal objects such numbers, point curves ...)should reasonably constant across platforms. however, platforms using harvard architecture ( opposed von neumann's )can big limitations accessing called \"program memory\" data. 8-bitatmel avr mcuis such example. compilers toolchains such architectures usually copy read data ram run ,and/ provide non-standard ways access read data flash/eeprom program memory (through specific macros, pragmas, functions). first case means the ram consumption increase libecc compared the stack usage ( of runtime copy). second case means libecc code have be adapted the platform the user to keep ram usage its lowest. any case, tracking where const qualified data reside be important the amount ram is critical matter. full software stack containing known test vector scenario has been compiled tested a cortex-m0(stm32f030r8t6 @ 48mhz 64kb flash 8kb ram). has been compiled tested a cortex-m3 (stm32f103c8t6@ 72mhz 64kb flash 20kb ram). results the flash/ram occupancy are given the table below, well the timings the ecdsa signature verification operations.note: cortex-m0 case is bit special the arm family. since mcu lacks 32-bit x 32-bit 64-bitmultiplication instruction, multiplication is implemented using builtin software function. yields poor performance wordsize=64 compared wordsize=32 ( might explained the calling cost the builtin function).libeccstm32f103c8t6 (cortex-m3 @ 72mhz)stm32f030r8t6 (cortex-m0 @ 48mhz)flash size32kb30kbram size8kb8kbsign 950ms2146msverif 1850ms4182ms order compare libecc performance these embedded platforms, give figures mbedtls cortex-m3 taken a recent study arm. we previously discussed, the figures without nist curves specific optimizations are interest a fair comparison:mbedtlslpc1768 (cortex-m3 @ 92mhz)1flash size??ram size3kb2sign 1893msverif 3788ms1 beware the mcu frequency difference comparing libecc test case.2 figure includes heap usage (stack usage is unknown this is arough lower limit ram usage). compatibility portabilitylibecc compatibility dealing the portability a program across various platforms, many issues are fact hidden behind property. is due the very complex nature what platform is, namely: core cpu architecture (x86, arm, mips, powerpc, ...). target os (linux, windows, mac os, ...) more low level firmware (including bare-metalprogramming model exotic real- os microcontrollers instance). proper compilation (cross-)toolchain producing binaries the platform. toolchain usuallyinclude compiler a linker, both possibly specific flags limitations.regarding libecc, here are main elements be aware when dealing a \"\" platform:libecc is pure c-99 ( assembly), it should compile any platform a decent c-99compatible compiler. code is endian neutral, meaning libecc should on little endian big endian platforms. makefile has been tested clang gcc under linux, well gcc cross-compilation variantssuch mingw windows gcc mac os version. order adapt makefile behaviour thecompiler is gcc/clang compatible, user modify cflags well the ldflags exporting .the library supports 16-bit/32-bit/64-bit word sizes, should ensure compatibility most the platforms 8-bit mcus 64-bit cpus. the toolchain does have stdint.hheader, is still possible compile libecc exporting libecc_nostdlib=1: this case, code try guess fit native c types throw error that user adapt src/words/types.h its specific case. library core is platform independent. however, the platform is recognized (.e. everything aside unix/windows/mac os), error is thrown compilation asking user provide implementations external dependencies src/external_deps/, namely: printing helper src/external_deps/print.c. helper serves output debugging purposes. timing helper src/external_deps/.c. helper is used measure performances thelibrary the performance self tests. random helper src/external_deps/rand.c. helper is used the core library the signatureschemes. should notice a random source is crucial the security elliptic curve based signature schemes, great care must taken implementing .some external dependencies arise depending the compilation chain /or platform. such example is implementation the gcc clang stack protection option, usually expecting user provide stack canaries generation( random values) failover behavior. compiling libecc arm cortex-m gnu gcc-armcompiling cortex-m targets should straightforward using arm-gcc none-eabi ( bare metal) cross-compiler well the specific cortex-m target platform sdk. order compile core libsign. static library, only thing do is execute makefile command overloading ccand cflags:$ cc=arm-none-eabi-gcc cflags=\"$(target_opts) -w -wextra -wall -wunreachable-code \\-pedantic -fno-builtin -std=c99 -os \\-ffreestanding -fno-builtin -nostdlib -dwordsize=64\" \\ build/libsign.where $(target_opts) are flags specific the considered target: -mcpu=cortex-m3 -mthumb cortex-m3 example. word sizeflag should adapted -dwordsize=32 the specific case cortex-m0/m0+ discussed the performance section( of lacking 32-bit 64-bit native multiplication instruction). library then used be linked against filecontaining main calling function, the linking part depend thetarget platform ( addition the target cpu): will the linker scripts provided the platform/board manufacturer produce firmware suitable the target (st stm32, nxp lpc, atmel sam, ...). the external dependencies been implemented the user, is possible build self-tests binary adding gnu ld linker script specific the target platform (linker_script.ld the example below):$ cc=arm-none-eabi-gcc cflags=\"$(target_opts) -w -wextra -wall -wunreachable-code \\-pedantic -fno-builtin -std=c99 -os \\-ffreestanding -fno-builtin -nostdlib -dwordsize=64\" \\ldflags=\"-t linker_script.ld\" \\ build/libsign.note1: default, linker scripts share ram between heap stack. since libecc uses stack, is convenient(sometimes necessary, specifically devices very constrained ram, such cortex-m0 8kb) adapt stack base address that stack overflow errors occur. errors be tricky detect since generally produce hard faults silently run .note2: is to user link against libc ( standard functions are necessary) not, this obviously influence program size flash. already stated, libc footprint is included the figured have been given the performance section.note3: libecc has been successfully tested other non-gnu compilation sdk toolchains such keil mdkconfigured use arm compiler. libecc portability guide section is dedicated giving more details how compile libecc non-gnu compilersare used (.e. c compilers do support gcc syntax), /or compiling environments do provide gnu compilation style ( is generally case all--one ides such visual studio other bsp sdk provided proprietary integrated circuits founders board manufacturers).1 - compilers c99 standard compliance we already stated, libecc requires c99 compiler. more specifically, libecc makes of four feature the c99 standard ( the older c89/c90 standard), namely: long long int type.designated initializers structures. usage the inline keyword. usage variadic macros.hence, compiling a given compiler, will to check the compiler iseither fully c99 compliant, that four features are least implemented extensions.such details are generally provided the compiler documentation.note: one wants adapt libecc compilers where of necessary c99 features are missing, here is big picture the necessary :the long long int structures initializers are used over libecc code, they arestrong requirements, would imply deep code modifications. inline keyword be removed most cases, except the context header files where is used define static inline functions. functions have be moved '.c' files, one have deal minor adaptations. usage variadic macros is marginal can removed minimal efforts: are used deal debug helpers src/utils.2 - compiling environments without gnu libecc uses gnu style makefile automate compilation process. can however othercompilation environments are gnu compatible implementing following guidelines: the compilation toolchain compile '.o' objects the necessary '.c' files src/nn,src/fp, src/curve, src/sig, src/utils src/hash. the compilation toolchain link necessary object files generate static libraries: libarith.: °°°°°°°°°°° src/fp/fp_rand.o src/fp/fp_mul.o src/fp/fp_montgomery.o src/fp/fp_mul_redc1.o src/fp/fp_add.o src/fp/fp.o src/fp/fp_pow.o src/nn/nn_mul.o src/nn/nn_mul_redc1.o src/nn/nn_logical.o src/nn/nn.o src/nn/nn_modinv.o src/nn/nn_add.o src/nn/nn_rand.o src/nn/nn_div.o src/utils/print_nn.o src/utils/print_fp.o src/utils/print_keys.o src/utils/print_curves.o src/utils/utils.o libec.: °°°°°°°° src/fp/fp_rand.o src/fp/fp_mul.o src/fp/fp_montgomery.o src/fp/fp_mul_redc1.o src/fp/fp_add.o src/fp/fp.o src/fp/fp_pow.o src/nn/nn_mul.o src/nn/nn_mul_redc1.o src/nn/nn_logical.o src/nn/nn.o src/nn/nn_modinv.o src/nn/nn_add.o src/nn/nn_rand.o src/nn/nn_div.o src/utils/print_nn.o src/utils/print_fp.o src/utils/print_keys.o src/utils/print_curves.o src/utils/utils.o src/curves/prj_pt.o src/curves/curves.o src/curves/aff_pt.o src/curves/prj_pt_monty.o src/curves/ec_shortw.o src/curves/ec_params.o libsign.: °°°°°°°°°° src/fp/fp_rand.o src/fp/fp_mul.o src/fp/fp_montgomery.o src/fp/fp_mul_redc1.o src/fp/fp_add.o src/fp/fp.o src/fp/fp_pow.o src/nn/nn_mul.o src/nn/nn_mul_redc1.o src/nn/nn_logical.o src/nn/nn.o src/nn/nn_modinv.o src/nn/nn_add.o src/nn/nn_rand.o src/nn/nn_div.o src/utils/print_nn.o src/utils/print_fp.o src/utils/print_keys.o src/utils/print_curves.o src/utils/utils.o src/curves/prj_pt.o src/curves/curves.o src/curves/aff_pt.o src/curves/prj_pt_monty.o src/curves/ec_shortw.o src/curves/ec_params.o src/hash/sha384.o src/hash/sha3-512.o src/hash/sha512.o src/hash/sha3-256.o src/hash/sha3-224.o src/hash/sha3.o src/hash/sha256.o src/hash/sha3-384.o src/hash/sha224.o src/hash/hash_algs.o src/sig/ecsdsa.o src/sig/ecdsa.o src/sig/ecrdsa.o src/sig/ecosdsa.o src/sig/ecfsdsa.o src/sig/eckcdsa.o src/sig/ecgdsa.o src/sig/ecsdsa_common.o src/sig/sig_algs.o src/sig/ec_key.ocompiling binaries (such ec_self_tests ec_utils) is nothing more compiling concerned '.c' files under src/tests linking with libsign..3 - dealing the standard library stdint important preprocessor flags are expected be defined compiling libecc:wordsize=: is preprocessor flag defining libecc internal words size (16, 32, 64). default libecc detect best size depending the platform, if platform is recognized user is expected provide flag.with_stdlib: flag is used standard library usage inside libecc. exporting environment variablelibecc_nostdlib=1 trigger non usage standard includes libraries. standard c library headers filesare used two things the project:defining standard types through stdint.h header.though using header helps libecc properly define basic types src/words/types.h, is required use and heuristics be used define types without standard headers ( explanations that src/words/types.h) comments.defining standard library functions used external dependencies well ec_utils. compiling without with_stdlibflag means one has provide .in case, the user forgot provide important preprocessing flags whenever are necessary, errors be thrown during compilation process. explained src/words/types.h, stdint.h is used (.e. with_stdlib defined), heuristics are used guess primitive types sizes. heuristics fail the user have adapt typesdefinitions accordingly depending the platform. 4 - overloading makefile variables compiling using compilers are compatible the gcc syntax, still using gnu compilation environment, is possible adpat makefile behavior. addition the libecc_nostdlib=1environment variable previously described, here is list the variables tune compilation process:cc: usual, overloads compiler be used.cflags ldflags: flags be overloaded user defined ones. user defined flags completelyshadow default flags both static libraries (libarith., libec., libsign.) and produced binaries.lib_cflags, bin_cflags, bin_ldflags: one wants specifically tune compilation linking flags the static libraries the binaries, flags be used they shadow cflags ldflags.ar ranlib: flags override ar ranlib tools used generate static library archives. a simple example when how use environment variables overloading system, let's the following case: wants compile libecc an old version gcc does support -fstack-protector-strong option( is case gcc < 4.9). since is flag used default libecc makefile, error be triggered. is possible overcome issue overloading cflags the following:$ cflags=\"-w -werror -wextra -wall -wunreachable-code -pedantic -fno-builtin -std=c99 -d_fortify_source=2 \\-fstack-protector- -o3 -dwith_stdlib -fpic\" as can , we keep other cflags default compilation while replacing -fstack-protector-strong the less efficient more compatible -fstack-protector-.in addition compilation flags, is possible overload library word sizes well debugmodes through makefile targets: debug compile debug version the library binaries, debugging symbols. 16, 32 make 64 respectively compile library 16, 32 64 bits word sizes. debug16, debug32 make debug64 compile debug versions these. force_arch32 make force_arch64 force 32-bit 64-bit architectures compilation (-m32 -m64flags under gcc). targets allow cross-compilation a 32-bit (respectively 64-bit) target under 64-bit (respectively32-bit) host: typical example is compiling i386 under x86_64.note: targets we described here be used conjunction overloading cflags ldflags. hence,: cflags=\"-fstack-protector-\" make debug16 indeed compile the binaries debug, a word size 16 bits a -fstack-protector- stack protection option.5 -  concrete example sdcc an example show to adapt compilation process compilers are compatible thegnu compilers syntax, will detail to proceed exploring sdcc(small device c compiler) toolchain. porting libecc this compiler is interesting many reasons: sdcc compiler uses specific syntax, though shares similarities other compilers (-c flag generate object files, -o flag define output file). compiler is \"almost\" c99 compliant: depending the target, has c99 featurespartially implemented. compiler has \"exotic\" targets such the zilog z80 mcu. suppose the user has provided external dependecies print, random timefunctions (otherwise explicit errors be thrown). will show overloading makefile flags be use this case. that want compile libecc order embed in game boy rom. game boy console uses proprietaryversion the z80 mcu supported sdcc under target name gbz80.hence, first attempt compilation be :overload cc=sdcc change default compiler.overload ar=sdar ranlib=sdranlib overload archives handling binaries ( are specific sdcc).overload cflags=\"-mbgz80 --std-sdcc99\" specify target, ask the c99 compatibility mode.overload ldflags=\" \" nothing since do want default gcc linking flags break compilation. first attempt trigger error:$ cc=sdcc ar=sdar ranlib=sdranlib cflags=\"-mgbz80 --std-sdcc99\" ldflags=\" \" ...src/external_deps/../words/words.h:62:2: error: #error \"unrecognized platform. \\please specify word size your target ( make 16, 32, 64)\" we explained, the platform is recognized has specify word size. will it overloading wordsize=16: z80 is 8-bit cpu, it seems reasonable fit wordsize 16-bit (8-bit half words). second attempt go further will fail some point:$ cc=sdcc ar=sdar ranlib=sdranlib cflags=\"-mgbz80 --std-sdcc99 -dwordsize=16\" ldflags=\" \" ...at 1: error 119: don't what do file 'src/tests/ec_self_tests_core.o'. file extension unsupportedhowever, can notice the static libraries been compiled, is first step! compiling full binary is bit technical due the fact sdcc does know to deal '.o' object files '.a' archives. however, can find way of by renaming 'libsign.' to 'libsign.lib', adding missing objects the library. compiling ec_self_testsbinary needs external dependencies (src/external_deps/print.c,src/external_deps/rand.c src/external_deps/.c) well the '.c' files src/tests/ec_self_tests_core.c src/tests/ec_self_tests.c, latter being one containing mainfunction. we first add necessary objects files the existing library sdar:$ cp build/libsign. build/libsign.lib$ sdar q build/libsign.lib src/external_deps/print.o src/external_deps/rand.o src/external_deps/.o src/tests/ec_self_tests_core.o, we compile link src/tests/ec_self_tests.c the library:$ sdcc -mgbz80 -dwordsize=16 --std-sdcc99 src/tests/ec_self_tests.c build/libsign.lib should create ec_self_tests.ihx, has intel hexfile format firmware programming. this file, is usually straightforward create game boy rom file can interpreted an emulator ( are however quirks related the game boy platform hardware architecture, the note below).note: purpose the section was show to adapt compilation process compilers noncompatible the gnu c . consequently, fully porting libecc the game boy platform is left a complementary , and is a \" easy\" task. among things, will to deal the rom size limitation 32kb can solved using bank switching, will involve code compilation tuning. another issue be ram size 8kb properly handling stack pointer base described the previous sections.libecc constant though efforts been made have ( of) core algorithmsconstant , turning libecc a library shielded against side channel attacksis still work progress.beyond pure algorithmic considerations, many aspects a program turnsecret leakage resistance a very complex problem, especially writingportable c code. among things, can list following:low level issues arise dealing heterogeneous platforms (instructions might be constant ) and compilers optimizations( c code seems constant is fact compiled a non constant assembly). shared hardware resource become leakage source ( caches, branch prediction unit, ...). dealing a portable source codemeant run most platforms, is an easy task think all leakage sources. a thorough discussion cryptography constant challenges, can check page.software architecture source code is composed eight main parts consist thecore source code:[1] machine code: src/wordsabstraction layer handle word size depending the target machine ( word size also forced duringcompilation). useful low level macros functions arehandled .[2] natural numbers layer: src/nn part implements the functionsrelated positive integers arithmetic (including modulararithmetic).[3] fp layer: src/fpfinite field prime order (binary fields areintentionally supported).[4] elliptic curves core: src/curves layer implements the primitiveshandling elliptic curves prime fields, including pointaddition doubling, affine projective coordinates, ...[5] curves definitions: src/curves/known src/curves/user_defined are definitions some standard curves (secp, brainpool,frp, ...).[6] ec*dsa signature algorithms: src/sig layer implements mainelliptic curves based signature algorithms (ecsdsa, eckcdsa,ecfsdsa, ecgdsa, ecrdsa, ecosdsa). exposes sign verify api the standard init/update/final logic.[7] hash functions: src/hashhash functions (sha-2 sha-3 based algorithms now).[8] utils: src/utilsvarious useful libc functions (memcpy, memset, ...) well well pretty printing functions our nn, fp curves layers. addition the core source code the library, various resourcesare present the source tree. descrive hereafter. self tests are provided the signature algorithms all curves using the hash functions [9], well tests targetting arithmeticoperations nn fp more specifically [10]:[9] sig self tests: src/testsfunctions test the compiled library isproperly working regard the signature algorithms the curves statically defined the library. tests consiste known test vectors, random testvectors (.e. random data sign/verify) well performance measurements.[10] arithmetic self tests: src/arithmeticfunctions test the compiled arithmetic library isproperly working its basic operations (addition, subtraction,multiplication, ...). examples help user interact the nn, fp cruves layersare provided:[11] user examples: src/examplesuser examples each the nn, fp curves layers. examples show are headers use, how interact the abstract mathematical objects each layer. configuration the library [13] well an external dependenciesabstraction layer are provided:[12] external dependencies: src/external_deps files contain functions are considered external dependencies, meaning theirimplementation is platform dependent ( concerns debugoutput a console file, random generation, measurement). no c standard library is provided, user must implementthose functions.[13] configuration files: src/lib_ecc_config.h are top c headers are used libecc configuration, .e. activate given hash/curve/signaturealgorithms compilation through ifdefs.finally, various useful scripts are provided:[14] scripts: scriptstools expand libecc new user defined curves.here is big picture the library architecture summarizing linksbetween modules previously described: +-------------------------+ |ec*dsa signature | |algorithms | <------------------+ |(iso 14888-3) [6] | | +-----------+-------------+ | ^ | | | +-----------+-------------+ +----------+------------+ |curves (secp, brainpool, | | hash | |frp, ...) | | functions | | [5] | | [7] | +-----------+-------------+ +-----------------------+ ^ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | @ {useful auxiliary modules}@ +-----------+-------------+ @ +------------------------+@ | elliptic curves [4] | @ | utils [8] |@ | core (scalar mul, ...) | @ +------------------------+@ +-----------+-------------+ @ | sig self tests [9] |@ ^ @ | arith self tests [10] |@ | @ | user examples [11] |@ | @ +------------------------+@ | @ | external deps [12] |@ +-----------+-------------+ @ +------------------------+@ | fp finite fields [3] | @ | libecc conf files [13] |@ | arithmetic | @ +------------------------+@ +-----------+-------------+ @ | scripts [14] |@ ^ @ +------------------------+@ | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@ +-----------+-------------+ +------------------------+ | nn natural [2] | <------+ machine related | | numbers arithmetic | | (words, ...) [1] | +-------------------------+ +------------------------+"
}