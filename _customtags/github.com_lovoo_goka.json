{
	"_id": "14362398",
	"site": "https://github.com/lovoo/goka",
	"title": " Goka â€“ distributed stream processing library for Kafka written in Go",
	"author": "flosch",
	"date": "2017-06-13T13:07:42.317Z",
	"tags": {
		"categories": [
			"library", "system"
		],
		"languages": [
			"go",
			"html"
		]
	},
	"content": "readme.md goka goka is compact yet powerful distributed stream processing library apache kafka written go. goka aims reduce complexity building highly scalable highly available microservices.goka extends concept kafka consumer groups binding state table them persisting in kafka. goka provides sane defaults a pluggable architecture.featuresmessage input outputgoka handles the message input output you. only to provide or more callback functions handle messages any the kafka topics are interested . you ever to deal deserialized messages.scalinggoka automatically distributes processing state across multiple instances a service. enables effortless scaling the load increases.fault tolerance case a failure, goka redistribute failed instance's workload state across remaining healthy instances. state is safely stored kafka messages delivered at-least-once semantics.built- monitoring introspectiongoka provides web interface monitoring performance querying values the state.modularitygoka fosters pluggable architecture enables to replace example storage layer the kafka communication layer.documentation readme provides brief, high level overview the ideas behind goka.package api documentation is available godoc.installation can install goka running following command:$ get -u github.com/lovoo/gokaconceptsgoka relies kafka message passing, fault-tolerant state storage workload partitioning.emitters deliver key-value messages kafka. an example, emitter be database handler emitting state changes kafka other interested applications consume.processor is set callback functions consume perform state transformations upon delivery these emitted messages. processor groups are formed one more instances a processor. goka distributes partitions the input topics across processor instances a processor group. enables effortless scaling fault-tolerance. a processor instance fails, partitions state are reassigned the remaining healthy members the processor group. processors also emit further messages kafka.group tables are partitioned key-value tables stored kafka belong a single processor group. a processor instance fails, remaining instances take the group table partitions the failed instance recovering from kafka.views are local caches a processor group's complete group table. views provide read- access the group tables can used provide external services example through grpc interface. started example goka application look the following. emitter emits single message key \"-key\" value \"-value\" the \"example-stream\" topic. processor processes \"example-stream\" topic counting number messages delivered \"some-key\". counter is persisted the \"example-group-state\" topic. locally start dockerized zookeeper kafka instances, execute start the makefile the examples folder.package mainimport (\"fmt\"\"log\"\"os\"\"os/signal\"\"syscall\"\"github.com/lovoo/goka\"\"github.com/lovoo/goka/codec\")var (brokers = []string{\"localhost:9092\"}topic goka.stream = \"example-stream\"group goka.group = \"example-group\")// emits single message leavefunc runemitter() {emitter, err := goka.newemitter(brokers, topic, (codec.string)) err != nil {log.fatalf(\"error creating emitter: %v\", err)}defer emitter.finish()err = emitter.emitsync(\"-key\", \"-value\") err != nil {log.fatalf(\"error emitting message: %v\", err)}fmt.println(\"message emitted\")}// process messages until ctrl-c is pressedfunc runprocessor() {// process callback is invoked each message delivered // \"example-stream\" topic.cb := func(ctx goka.context, msg interface{}) {var counter int64// ctx.value() gets the group table value is stored // the message's key. val := ctx.value(); val != nil {counter = val.(int64)}counter++// setvalue stores incremented counter the group table in// message's key.ctx.setvalue(counter)log.printf(\"key = %s, counter = %v, msg = %v\", ctx.key(), counter, msg)}// define new processor group. group defines inputs, outputs, // serialization formats. group-table topic is \"example-group-state\".g := goka.definegroup(group,goka.input(topic, (codec.string), cb),goka.persist((codec.int64)),)p, err := goka.newprocessor(brokers, g) err != nil {log.fatalf(\"error creating processor: %v\", err)} func() { err = p.start(); err != nil {log.fatalf(\"error running processor: %v\", err)}}()wait := (chan os.signal, 1)signal.notify(wait, syscall.sigint, syscall.sigterm)<-wait // wait sigint/sigtermp.stop() // gracefully stop processor}func main() {runemitter() // emits message stopsrunprocessor() // press ctrl-c stop} to contributecontributions are always welcome.please fork repo, create pull request against master, be sure tests pass. the github flow details."
}