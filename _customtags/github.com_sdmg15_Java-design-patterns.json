{
	"_id": "14489125",
	"site": "https://github.com/sdmg15/Java-design-patterns",
	"title": "A gentle intro to Java design patterns",
	"author": "yagamidev",
	"date": "2017-06-13T14:10:06.087Z",
	"tags": {
		"categories": [
			"media", "development"
		],
		"languages": [
			"java"
		]
	},
	"content": "readme.md java design patternsdesign patterns are very popular among software developers. design pattern is well-described solution common software problem. of benefits using design patterns are :design patterns are already defined provides industry standard approach solve recurring problem, it saves if use design pattern .using design pattern promotes re-usability leads more robust highly maintainable code.since design patterns are already defined, makes code easy understand debug. lead faster development new members team understand easily. is design pattern ? software design pattern is general reusable solution a commonly occurring problem within given context software design --- wikipediajava design patterns are divided tree parts : creational, structural behavioral.creational design patternscreational design pattens provide solution instantiate object the best possible for specific situations. basic form object creation result design problems add unwanted complexity the design. creational design patterns solve problem controlling object creation different ways. are five creational design patterns we discuss :singleton patternfactory patternabstract factory patternbuilder patternprototype patternpattern singletonpattern singleton: > class, instance.singleton is of gangs four design patterns comes the creational design pattern category.singleton pattern restricts instantiation a class ensures only instance the class exists the java virtual machine. singleton class must provide global access point get instance the class. singleton pattern is used logging, driver objects, caching thread pool. singleton design pattern is used other design patterns abstract factory, builder, prototype, facade etc. singleton design pattern is used core java classes , for example java.lang.runtime , java.awt.desktop. implement singleton pattern, are really many approaches all them following common concepts: private constructor avoid instantiation the class, private static variable the same class 's only instance the class.public static method returns instance the class, is global access point the outer world get instance the class.'ll implement thread safe here. classes are the package com.singleton;import com.singleton.singletonthreadsafe; public class singletontest { public static void main(string[] args){ singletonthreadsafe sing = singletonthreadsafe.getinstance(); system..println(sing); // let's instanciate another class singletonthreadsafe sing1 = singletonthreadsafe.getinstance(); system..println(sing1); // check your console.... the hell, two instances the same reference :o } }pattern factoryfactory design pattern is used we a super class multiple sub-classes based input, need return of sub-class. pattern out responsibility instantiation a class client program the factory class. lets learn to implement factory pattern java then will learn benefits we see usage jdk.super class : super class factory pattern be interface, abstract class a normal java class. our example, have super class abstract class overridden tostring() method testing purpose. com.factory.sub-classes: lets we two sub-classes pc server implementation com.factoryhere's we in image : let's write test class. import com.factory.factoryclass ; // factory class import com.factory.pc; //sub-class import com.factory.server; //sub-class //pc server classes extend computer. public static void main(string[] args){ factoryclass fc = factoryclass(); computer comp1 = fc.getcomputer(\"pc\",16,499,4.3); system..println(comp1); computer comp2 = fc.getcomputer(\"server\",30,900,9); system..println(comp2); // you see output your console. } pattern provides advantages such :it provides approach code the interface rather the implementation. removes instantiation the actual implementation classes client code, making more robust. provides abstraction between implementation client classes through inheritance. examples its implementation jdk have :java.util.calendar, resourcebundle() numberformat getinstance();valueof() method wrapper classes boolean , integer etc.abstract factory is of creational pattern almost similar factory pattern except fact it's likefactory factories. you're familiar factory design pattern java , 'll notice we a single factory class returns different sub-classes based the input provided the factory class uses -else switch statement achieve . like factory pattern post, will the same super class sub-classes.codes are available com.abstractfactory.here's implementation the test class: public class abstractfactorytest{ public static void main(string[] args){ computer c = computerfactory.getcomputer( pcfactory(\"4g\",\"400g\",\"2.9ghz\")); /* computerfactory class contains static method getcomputer(abstractfactory fac) */ system..print(c); } }pattern builderbuilder pattern is creational design pattern factory pattern abstract factory pattern. pattern was introduced solve of problems factory abstract factory patterns the object contains lot attributes. pattern deals a static nested class then copy the arguments the outer class the builder class. sample code where have computer class computerbuilder build are available the package com.builder.computer.here's test program showing to builder class get object. import com.builder.computer;public class testbuilderpattenr{ public static void main(string[] args){ computer comp = computer.computerbuilder( \"500 gb\",\"2 gb\").setbluetoothenabled(true) .setgraphicscardenabled(true).build(); // -) ) }} are really various implementations this pattern jdk : java.lang.stringbuilder#append() (unsynchronized) java.lang.stringbuffer#append() (synchronized) .pattern prototypeprototype pattern is of creational design pattern, it provides mechanism object creation. prototype pattern is used the object creation is costly affair requires lot time resources you a similar object already existing. this pattern provides mechanism copy original object a object then modify according our needs. pattern uses java cloning copy object.import java.util.arraylist;import java.util.list;public class users implements cloneable{ private list<string> emplist; public users(){ emplist = arraylist<>(); }public users(list<string> list){.emplist=list;}//read data the database.public void loaddata(){ emplist.add(\"japak\"); emplist.add(\"king\"); emplist.add(\"david\"); emplist.add(\"romeo\");}public list<string> getemplist() { return emplist;} @override public object clone() throws clonenotsupportedexception{ list<string> temp = arraylist<string>(); (string s : .getemplist()){ temp.add(s); } return users(temp);}} //notice the clone method is overridden provide deep copy the users list.here's program will show benefit the prototype pattern usage.public class prototypepatterntest { public static void main(string[] args) throws clonenotsupportedexception { users usr = users(); user.loaddata();// the clone method get user object users usenew = (users) user.clone(); users usenew1 = (users) user.clone(); list<string> list = usenew.getemplist(); list.add(\"john\"); list<string> list1 = usersnew1.getemplist(); list1.remove(\"pankaj\"); system..println(\"users list: \"+ users.getemplist()); system..println(\"users list: \"+list); system..println(\"users new1 list: \"+list1); }}structural design patternsstructural patterns provide different ways create class structure, example using inheritance composition create large object small objects.adapter pattern pattern is used such way two unrelated interfaces work together. object joins unrelated interfaces is called adapter. a real life example, can of mobile charger an adapter mobile battery needs 3 volts charge the normal socket produces either 120v () or 240v (india). the mobile charger works an adapter between mobile charging socket the wall socket. of we'll two classes : volt - measure volts) socket :public class volt { private int volts; public volt(int v){ .volts=v; } public int getvolts() { return volts; } public void setvolts(int volts) { .volts = volts; }}public class socket { public volt getvolt(){ return volt(120);}} we to build adapter can produce 3 volts, 12 volts default 120 volts. first all will create adapter interface these methods.public interface socketadapter {public volt get120volt();public volt get12volt();public volt get3volt();}while implementing pattern, are approaches : that deals inheritance another that deals composition. note they are almost same thus, here 'll deal one inheritance. let's implement adapter class !public class socketclassadapterimpl extends socket implements socketadapter{ @override public volt get120volt() { return getvolt(); } @override public volt get12volt() { volt v= getvolt(); return convertvolt(v,10); } @override public volt get3volt() { volt v= getvolt(); return convertvolt(v,40); } private volt convertvolt(volt v, int ) { return volt(v.getvolts()/); }}now let's how this ! here's test main function illustrate.public class adapterpatterntest { public static void main(string[] args) { testclassadapter(); testadapter(); // results goes your console :)}private static void testadapter() { socketadapter sockadapter = socketobjectadapterimpl(); volt v3 = getvolt(sockadapter,3); volt v12 = getvolt(sockadapter,12); volt v120 = getvolt(sockadapter,120); system..println(\"v3 volts using object adapter=\"+v3.getvolts()); system..println(\"v12 volts using object adapter=\"+v12.getvolts()); system..println(\"v120 volts using object adapter=\"+v120.getvolts());}private static volt getvolt(socketadapter sockadapter, int ) { switch (){ case 3: return sockadapter.get3volt(); case 12: return sockadapter.get12volt(); case 120: return sockadapter.get120volt(); default: return sockadapter.get120volt(); }}} pattern has many usage the jdk :java.util.arrays#aslist() java.io.inputstreamreader(inputstream) (returns reader),java.io.outputstreamwriter(outputstream) (returns writer).composite pattern"
}