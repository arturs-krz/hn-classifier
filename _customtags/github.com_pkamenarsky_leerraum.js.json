{
	"_id": "14349571",
	"site": "https://github.com/pkamenarsky/leerraum.js",
	"title": " Leerraum.js â€“ A PDF typesetting library with hyphenated line breaking",
	"author": "pka",
	"date": "2017-06-13T13:08:16.741Z",
	"tags": {
		"categories": [
			"library", "design"
		],
		"languages": [
			"typescript",
			"javascript"
		]
	},
	"content": "readme.md leerraum.jsleerraum.js is pdf typesetting / layouting library based typeset ( provides implementation the knuth plass line breaking algorithm) pdfkit. goals are simplicity perfect control the positioning graphic elements.demo pdf - sourcetable contentsmotivationinstallationgenerating example pdfbasic usagedocumentationbounding boxesstreamsbasic streamsstylesrendererstextpolygonstablespage breakscombinatorsformatspdf outputmiscellaneousmotivationleerraum.js does aim be replacement latex. main difference other typesetting systems patoline sile is it is a javascript library rather being full blown document processing system a domain specific language. motivation behind decision is while initial setup cost may a bit higher, many circumstances convenience a general purpose language is a bit too hard give (i.e. extensibility, generative design, templating, pulling records a database, etc.)leerraum.js is especially suited situations which perfect control positioning, layout high quality hyphenated line breaking is essential.leerraum.js is well suited math typesetting, books when features latex other typesetting systems are required.installationnpm install leerraumbasic usageconst leer = require('leerraum');const text = [ { leading: 60, spans: [ { fontfamily: 'fonts/roboto-regular.ttf', fontsize: 60, text: 'leerraum.js', }, ] } ];leer.rendertopdf('test.pdf', leer.formats.a4, [ { bboxes: leer.withmargins(leer.formats.a4, 72, 72, 72, 72), renderer: leer.rendertext(text) } ]);generating example pdfinstall typescript. :git clone https://github.com/pkamenarsky/leerraum.js.gitcd leerraum.jsnpm installtsc -p .node node js/examples/example.jsexample.pdf should generated the current directory.documentationeverything leerraum.js is measured points.bounding boxes bounding box is rectangle, along an optional tag:type bbox = { tag?: string, x: number, y: number, width: number, height: number}streams stream is pure function an index a bbox:type stream<bbox> = (index: number) => bboxtags may used mark specific bounding boxes - .e. first bounding box every page be marked a 'new_page' tag, allowing a renderer skip ahead the next page break.basic streamsfunction withmargins( format: format, margintop: number, marginright: number, marginbottom: number, marginleft: number): stream<bbox>withmargins generates infinite stream bounding boxes the provided format the specified margins points. each bounding box is tagged a new_page tag.function columnswithmargins( format: format, gap: number, margintop: number, marginright: number, marginbottom: number, marginleft: number): stream<bbox>columnswithmargins generates infinite stream bounding boxes the provided format the specified margins points, laid in columns. every bounding box an index is tagged a new_page tag.stylesstyles combine basic drawing parameters:type style = { linewidth?: number, strokecolor?: string, fillcolor?: string, strokeopacity?: number, fillopacity?: number, linejoin?: 'miter' | 'round' | 'bevel', linecap?: 'butt' | 'round' | 'square',}colors are '#' + hexadecimal, opacities are the 0 - 1 range.renderers basic building block leerraum.js is renderer:type renderer = (measures: measures, bboxes: stream<bbox>) => [bbox[], rendernode[]]simply said, renderer is pure function a stream bounding boxes (describing geometry which to--rendered graphic element be laid ) to array actually occupied bounding boxes an array abstract rendernodes.why are renderers operating streams instead simple arrays? oftentimes is possible estimate area ( thus size number bounding boxes) certain graphic elements, text, are going occupy before actually laying out. lazy, infinite stream bounding boxes solves problem.textfunction renderparagraph(paragraph: paragraph): rendererrenderparagraph renders paragraph text:type paragraph = { align?: 'left' | 'center' | 'justify', leftindentation?: (line: number) => number, rightindentation?: (line: number) => number, leading: number, paragraphleading?: number, tolerance: number, spans: span[], hypher?: }leftindentation rightindentation control left right indentation ( points) per line, respectively. leading ( points) indicates distance between successive lines text, while paragraphleading specifies distance between current next paragraphs.hypher is optional hypher instance used hyphenation. none is provided, hyphenation.en- is used.tolerance specifies maximum amount allowed space stretching / shrinking ( none is provided, default value 10 is used). note if paragraph not laid according the provided tolerance, text be rendered.paragraph contains array spans:type span = { fontfamily: string, fontsize: number, text: string, hyphenate?: boolean, style?: style, options?: }fontfamily must contain full path a pdfkit-compatible font file. fontsize is font size points, hyphenate is flag indicating whether span should hyphenated. text contains span text be rendered an optional drawing style provided style. options field is passed pdfkit directly.rendertext is a convenience function rendering array paragraphs:type text = paragraph[]function rendertext(text: text): rendererpolygonsrenderpolygon renders polygon the provided style specified an array points:type point = { x: number, y: number }function renderpolygon(points: point[], style: style): renderertablesfunction rendertable(gap: number, cols: [number], cells: renderer[][]): rendererrendertable renders table the provided column widths, points, the cell renderers specified cells ( may anything - text, polygons, tables). now, absolute column widths are supported (due laziness, prs welcome.)page breaksconst pagebreak: rendererpagebreak introduces page break ( skipping ahead the next bounding box a new_page tag.)combinators power leerraum.js stems the fact renderers are pure functions thus easily combined create renderers. combinators are provided of box:vertically(renderers: renderer[]): renderervertically produces new renderer laying the provided array renderers vertically:combine(renderers: [(bbox: bbox) => bbox, renderer][]): renderercombine takes array tuples bounding box-mapping functions (.e. (bbox) => bbox) renderers. essence, combine produces new renderer transforming original stream bounding boxes according the mapping functions, feeding each transformed stream its corresponding renderer finally returning union occupied bounding boxes originating each streamed bounding box:formatstype format = { width: number, height: number} format specifies page dimensions. map leerraum.formats contains number useful formats (a4, letter, etc).function landscape(f: format): formatlandscape turns portrait format landscape.pdf outputfunction rendertopages( doc, format: format, layers: rendernode[][], background?: (page: number) => rendernode[][])rendertopages is lower-level function outputting rendernodes obtained a renderer. the trivial case, might the following:const leer = require('leerraum');const pdfdocument = require('pdfkit');const fs = require('fs');const doc = pdfdocument({layout: 'portrait', size: [leer.formats.a4.width, leer.formats.a4.height]});const measures = leer.pdfmeasures(doc);doc.pipe(fs.createwritestream('test.pdf'));const [_, render_nodes] = leer.rendertext(...)(measures, leer.withmargins(leer.formats.a4, 72, 72, 72, 72));leer.rendertopages(doc, leer.formats.a4, [render_nodes]);doc.end();note rendertopages takes array rendernode arrays, allows rendering multi-layered documents. each layer may obtained different combinations bounding box streams renderers.'s an optional background parameter, is function a page index a number rendernode layers ( above). background layers, specified, are rendered , on every page.why set layers? principle, might provide background layers every page layers. problem however, is different layers 't share information each , which makes impossible e.g. render blue background every page stop there's more text be rendered another layer. more convenient function use is rendertopdf:function rendertopdf( filename: string, format: format, renderers: { bboxes: stream<bbox>, renderer: renderer}[], background?: (page: number) => { bboxes: stream<bbox>, renderer: renderer}[]): void above example be expressed much simpler the following :const leer = require('leerraum');leer.rendertopdf('test.pdf', leer.formats.a4, [ { bboxes: leer.withmargins(leer.formats.a4, 72, 72, 72, 72), renderer: leer.rendertext(...) } ]);miscellaneousmeasures is collection functions measuring font metrics.rendernodes are abstract descriptions laid , ready--be-rendered elements (text fragments, polygons, etc).contributionsbug reports, bug fixes, ideas, prs welcome!"
}