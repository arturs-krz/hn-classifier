{
	"_id": "14370638",
	"site": "http://github.com/alixander/stanchion",
	"title": " Stanchion.js â€“ JavaScript library for managing network requests",
	"author": "litzer",
	"date": "2017-06-13T13:07:42.767Z",
	"tags": {
		"categories": [
			"development", "library"
		],
		"languages": [
			"javascript",
			"html"
		]
	},
	"content": "readme.md stanchionadd priorities your web app's network requests.installationnpm install --save stanchionyarn add stanchion it's solving exists ceilings maximum number requests implemented browsers [1]. the browser's network request queue operates a -in--out order. stanchion is adding application-aware network queue where requests are dispatched based the priority are assigned.why should use this is benefit web apps can a large number network calls any given . a large number is that exceeds maximum concurrent requests able be made any the browsers app supports. every network call is equal it comes delivering responsive user experience. example, network requests which ui elements wait should priority calls persist data the -end, should priority calls analytics-collection. maybe of calls are made periodically intervals some are made response events. instead managing ordering a micro level, stanchion takes simple approach assigning priorities.demo case are gifs images loading chrome browser. the server, every image response is delayed 2000ms when request is received. since number max parallel requests is 6, takes first 6 images always loads those first batch. those are flight, rest the images 've been processed queued , so priority comes consideration images past 6th. note the gifs: didn't start recording the same times, the gif start isn't representative a baseline any timing.default (without using library)using stanchion prioritizing lower numbersusing stanchion prioritizing higher numbers that last gif, here's logging info what's happening. first 6 queued are dispatched right away, the rest are held queue until response comes . when responses are received more requests be dispatched, highest priority requests the queue are dispatched .apiinitialize(config)config: object - list options initialize logger: function - [optional] is callback used logging. will called parameter object the format {loglevel: ..., message: ...}.maxopenconnections: number - [optional] override library's determination the number open connections browser supports total. almost certainly don't need .maxopenconnectionsperhostname: number - [optional] override library's determination the number open connections browser supports per hostname. almost certainly don't need .queue(requestconfig)requestconfig: object - list options the network requesttask: promise - promise is expected make request called resolved finishedpriority: number - priority this request. defaults 1, makes queue fifo.url: string - [optional] url which are making request. should pass in you network requests going different hostnames, otherwise treats every request if were going the same hostname. browsers different maximum open connections per hostname vs open connections total.onsuccess: function - [optional] callback after task is resolvedonerror: function - [optional] callback if task is rejectedfaq i to opt- every network request through library can use for a subset? you omit requests bundles javascript files, would as they were included highest priority, since are inserted the browser queue soon they are called. if browser is unsupported? the maximum number open connections is known the particular browser, will bypass request management just dispatch immediately. don't need special handle in client code.is production-ready? yet."
}